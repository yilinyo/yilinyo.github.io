<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/26/WebSockect%20%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/2022/11/26/WebSockect%20%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="WebSockect-实现聊天室"><a href="#WebSockect-实现聊天室" class="headerlink" title="WebSockect 实现聊天室"></a>WebSockect 实现聊天室</h2><p><strong>说明：最近二手交易课设有一个需求是实现 购买者和商品发布者有一个聊天对话的功能，类似于咸鱼的聊天对话功能吧。想到的就是WebSocket协议来实现，问了一个前端小伙伴，他一般使用socketio(一个websocket框架)，我看了下也有java版的，但思考了下决定还是使用原生websocket来写前后端。</strong></p><h4 id="什么是websocket？"><a href="#什么是websocket？" class="headerlink" title="什么是websocket？"></a>什么是websocket？</h4><p>这里放一个知乎的高赞回答，看完很清楚。<a href="https://www.zhihu.com/question/20215561/answer/40316953">WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎</a> </p><p>首先我们先说说大家都很了解的Http协议，在B/S开发中，我们常用这种协议来进行各种响应和处理。</p><p>他的特点就是一个Request 和 一个Response而且是无状态的（想要保持状态需要间接通过session和cookie）。虽然在一些不那么复杂的需求下，这样的机制已经足够了，但是一些复杂的应用场景如需要一直监听某个数据的变化就显得力不从心了。当然我们也可以使用ajax来轮询，但这样其实是非常低效率的，你把自己想成服务器，假设有个人（客户端）一直在你耳边叨叨（数据更新了没。。。）我想你也一定要疯掉了吧。</p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12570/u=3797482105,2011720067&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto" alt="img" style="zoom:50%;" /><p>其次Http协议的另一个特点，浏览器只能主动发送请求接收信息，不能被动接收服务器信息。这一点确实蛋疼，使得一旦数据有了变化我需要自己去请求，但是我又怎么知道数据什么时候更新了呢？</p><p>然鹅，websocket的出现就可以巧妙的解决这些问题。</p><p>websocket协由握手和数据传输构成</p><p>握手基于HTTP协议，然后客户端和服务端实现长连接，所以说websocket 和 http是有交集的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12570/6651f2f811ec133b0e6d7e6d0e194b4c_720w.webp" alt="img"></p><p>那么数据如何传输呢？只需要在服务端设立转发的服务，那么数据就可以实现从A客户端到B客户端的发送，拿聊天举例，正是这种长连接机制以及允许客户端主动接收服务端消息的机制使得聊天消息能够看上去好像在两个客户端建立了连接。其实就是服务器做了一次转发。</p><h4 id="Java怎么写服务端的WebSocket（SpringBoot）"><a href="#Java怎么写服务端的WebSocket（SpringBoot）" class="headerlink" title="Java怎么写服务端的WebSocket（SpringBoot）"></a>Java怎么写服务端的WebSocket（SpringBoot）</h4><p>非常类似Servlet，这里我们需要写<strong>ServeEndPoint</strong></p><p>这里我们主要重写三个方法</p><ol><li>onOpen(建立连接时自动调用)</li><li>onMessage(接收消息时自动调用)</li><li>onClose(关闭连接时自动调用)</li></ol><p>当然还有onError等方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//这个 注解类似http的map ，比如说这样你的 websocket url 就是 ws：localhost/chat</span><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatEndPoint</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  建立连接被调</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br>      <br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收数据被调用</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message,Session session)</span>&#123;<br><br><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(Session session)</span>&#123;<br><br><br><br>    &#125;<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里需要注意，上面session指的是websocket的session，不是http的session，也是用来标识每一个长连接的对象，看到这里聪明的小伙伴应该能想到实现消息转发可以用session来标识每一个用户。</p><p>所以我们想要实现聊天消息转发可以使用map来存储websocket的session。这里我存储EndPoint实例类似，因为我们可以使用endpoint实例来获取session对象，记住每一个用户进行一次websocket长连接，就会创建一个endpoint对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>说到这里有小伙伴想问了，项目的一些数据存储在HttpSession中既然websocket是基于http的，那么我能不能取出Httpsession在Endpoint里使用啊？答案是可以的，只需要在springboot配置中在注入对象前ServerEndpointConfig放入这个httpsession就可以了</p><p>配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title function_">serverEndpointExporter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerEndpointExporter</span>();<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetHttpSessionConfigurator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServerEndpointConfig</span>.Configurator &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyHandshake</span><span class="hljs-params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession)request.getHttpSession();<br><br>        <span class="hljs-comment">//将httpsession存到配置对象</span><br><br>        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br></code></pre></td></tr></table></figure><p>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@OnOpen</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br>       <span class="hljs-built_in">this</span>.session = session;<br><br>       <span class="hljs-comment">//获取Httpssion</span><br><br>      <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession) config.getUserProperties().get(HttpSession.class.getName());<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="前端怎么写WebSocket"><a href="#前端怎么写WebSocket" class="headerlink" title="前端怎么写WebSocket"></a>前端怎么写WebSocket</h4><p>前端其实也类似，写起来更简单，只需要new一个websocket对象就能够实现连接。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">ws</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-comment">//连接</span><br>  <span class="hljs-title function_">connect</span>(<span class="hljs-params"></span>) &#123;<br>    ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:8081/api/chat&#x27;</span>);<br>  &#125;,<br><span class="hljs-comment">//获取实例</span><br>  <span class="hljs-title function_">getWs</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ws;<br>  &#125;,<br>  <span class="hljs-comment">//关闭连接，删除实例</span><br><br>  <span class="hljs-title function_">removeWs</span>(<span class="hljs-params"></span>) &#123;<br>    ws.<span class="hljs-title function_">close</span>();<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Typescript"><span class="hljs-comment">//调用方法</span><br>ws.<span class="hljs-title function_">connect</span>();<br><br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <br>  &#125;;<br><br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) &#123;<br>  &#125;<br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <br>  &#125;;<br></code></pre></td></tr></table></figure><h4 id="聊天怎么实现"><a href="#聊天怎么实现" class="headerlink" title="聊天怎么实现"></a>聊天怎么实现</h4><p>思路</p><ol><li> 每一个客户端与服务端建立连接就将EndPoint实例存入userHashMap（这里使用静态的）中。</li><li>客户端断开连接，就将此用户从userHashMap去除，所以userHashMap始终存储在线用户</li><li>客户端发消息，消息内容需要有发消息人，收消息人，内容，时间，封装成一个对象。</li><li>服务端onmessage接收到就检查用户里userHashMap有没有此人（有表示在线），有就找到session直接转发给他，没有需要暂时存储到chatsHashMap，存消息列表 。</li><li>那么我们还要修改1步骤，这里连接上就要检查chatsHashMap有没有自己的消息，有就转发给自己并去除chatsHashMap的消息，这样一来就实现了离线和在线用户的聊天功能。</li></ol><p>后端全部代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatEndPoint</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  用来存储每个客户端对象对应的聊天记录 key 是uid value 是json</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, ArrayList&lt;String&gt;&gt; chats = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * websocket session</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span>  Session session;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * httpsession</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> HttpSession httpSession;<br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  建立连接被调</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br>        <span class="hljs-built_in">this</span>.session = session;<br><br>        <span class="hljs-comment">//获取Httpssion</span><br><br>       <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession) config.getUserProperties().get(HttpSession.class.getName());<br><br>       <span class="hljs-built_in">this</span>.httpSession = httpSession;<br><br><br>       <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>        <span class="hljs-comment">// 将当前对象存储在 容器中 key为uid</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> String.valueOf(user.getUid());<br><br>       users.put(uid,<span class="hljs-built_in">this</span>);<br><br>       <span class="hljs-comment">// 判断并建立 暂存 聊天记录的数据结构</span><br><br>       <span class="hljs-keyword">if</span>(!chats.containsKey(uid)) &#123;<br><br>           ArrayList&lt;String&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           System.out.println(uid+<span class="hljs-string">&quot;调用了一次&quot;</span>);<br>           chats.put(uid,arr);<br><br>       &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageUtils.getMessage(<span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, getUsers());<br><br>        System.out.println(message);<br>        <span class="hljs-comment">//连接就一条广播</span><br>        broadcastAllUsers(MessageUtils.getMessage(<span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;当前在线用户人数：&quot;</span>+users.size()+<span class="hljs-string">&quot;人&quot;</span>));<br>        broadcastAllUsers(message);<br><br>        <span class="hljs-comment">//获取该用户暂存离线消息并推送</span><br><br>        ArrayList&lt;String&gt; chatCache = chats.get(uid);<br><br><br>        <span class="hljs-keyword">for</span>(String chat:chatCache)&#123;<br><span class="hljs-comment">//            ChatEndPoint chatEndPoint = users.get(uid);</span><br><span class="hljs-comment">//            System.out.println(chat);</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.session.getBasicRemote().sendText(chat);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        chats.remove(uid);<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取容器里的用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; <span class="hljs-title function_">getUsers</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-keyword">return</span> ChatEndPoint.users.keySet();<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 推送所有客户端</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">broadcastAllUsers</span><span class="hljs-params">(String message)</span>&#123;<br><br>        Set&lt;String&gt; usersSet = users.keySet();<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                <span class="hljs-keyword">for</span> (String user : usersSet) &#123;<br>                    <span class="hljs-type">ChatEndPoint</span> <span class="hljs-variable">chatEndPoint</span> <span class="hljs-operator">=</span> users.get(user);<br>                    chatEndPoint.session.getBasicRemote().sendText(message);<br>                &#125;&#125; <span class="hljs-keyword">catch</span>(IOException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br><br><br>            &#125;<br><br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收数据被调用</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message,Session session)</span>&#123;<br><br><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">mess</span> <span class="hljs-operator">=</span> mapper.readValue(message, Message.class);<br><br><span class="hljs-comment">//            System.out.println(mess);</span><br><span class="hljs-comment">// 消息的接收者</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">toUid</span> <span class="hljs-operator">=</span> mess.getToUid();<br><br>            <span class="hljs-type">ChatEndPoint</span> <span class="hljs-variable">chatEndPoint</span> <span class="hljs-operator">=</span> users.get(toUid);<br><br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>            <span class="hljs-keyword">if</span>(chatEndPoint!=<span class="hljs-literal">null</span>)&#123;<br><br>                <span class="hljs-comment">// 接收用户在线直接转发</span><br><br><br><br>                <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)&#123;<br><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.LOGIN_ERROR);<br>                &#125;<br><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message1</span> <span class="hljs-operator">=</span> MessageUtils.getMessage(<span class="hljs-literal">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess);<br><br>                chatEndPoint.session.getBasicRemote().sendText(message1);<br><br><br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">//接收用户不在线 先暂时存储消息</span><br><br>                ArrayList&lt;String&gt; messages = chats.get(toUid);<br><br>                <span class="hljs-keyword">if</span>(messages == <span class="hljs-literal">null</span>)&#123;<br>                    messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    chats.put(toUid,messages);<br><br>                &#125;<br><br>                <span class="hljs-comment">//存的就是json</span><br>                messages.add(MessageUtils.getMessage(<span class="hljs-literal">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess));<br><br><br><br>            &#125;<br><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(Session session)</span>&#123;<br><br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br>        users.remove(user.getUid().toString());<br><br>        System.out.println(user.getUserName()+<span class="hljs-string">&quot;下线了，当前在线人数：&quot;</span>+users.size()+<span class="hljs-string">&quot;人&quot;</span>);<br><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前时间戳，秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getUnix</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br><br>        time = time / <span class="hljs-number">1000</span>;<br><br>        <span class="hljs-keyword">return</span> String.valueOf(time);<br><br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>前端接收怎么存储呢？我暂时只想到存储在sessionStorage或者localStorage中，但这部分数据存储需要考虑去重和数据对应每个用户，不要疏忽了让别的用户看到了不属于自己的对话内容，那就出大问题了。整体思路挺简单的就是要细心。</p><h4 id="实现展示"><a href="#实现展示" class="headerlink" title="实现展示"></a>实现展示</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12570/image-20221125171042690.png" alt="image-20221125171042690"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12570/image-20221125171211620.png" alt="image-20221125171211620"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/12570/image-20221125171244569.png" alt="image-20221125171244569"></p><p>组件采用的是react-jwchat 感觉挺好看的，各项功能都正常，就是有时候会websocket连接了就断开了，猜测是没写error处理吧。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>最后看我的二手交易系统的前后端源码（websocket源码也在里面）</p><p><a href="https://gitee.com/wx_504ae56474/react-jwchat">react-jwchat 聊天组件</a></p><p><a href="https://gitee.com/yilinyo/lkd-javee-trade-frontend">二手交易系统前端</a></p><p><a href="https://gitee.com/yilinyo/lkd-javaee-trade-backend">二手交易系统后端</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello Git</title>
    <link href="/2022/10/27/hello-git/"/>
    <url>/2022/10/27/hello-git/</url>
    
    <content type="html"><![CDATA[<p>Git 入门笔记，带你快速使用 Git Bash 命令</p><h1 id="Git-入门"><a href="#Git-入门" class="headerlink" title="Git 入门"></a>Git 入门</h1><p>git 分布式版本控制</p><p>记录版本号 ，每个版本都有（高效的压缩解压算法）</p><h2 id="本地库"><a href="#本地库" class="headerlink" title="本地库"></a>本地库</h2><p>本地结构</p><pre><code class="hljs">1. 本地库1. 暂存区1. 工作区</code></pre><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>初始化本地库</p><h4 id="git-add-git-commit"><a href="#git-add-git-commit" class="headerlink" title="git add git commit"></a>git add <strong>git commit</strong></h4><p>工作区 -》<strong>git add</strong> 【】暂存区 -》<strong>git commit</strong> 【】 本地库</p><p>工作区 下（.git 同级）未 git add</p><p>缓存区 已经 git add 未 git commit</p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>查看工作状态</p><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>提交日志（由近到远）</p><p>每一条内容 有一个 key 索引唯一对应</p><p>不同展示样式：</p><h5 id="git-log-–pretty-oneline"><a href="#git-log-–pretty-oneline" class="headerlink" title="git log –pretty=oneline"></a>git log –pretty=oneline</h5><h5 id="git-log-–oneline"><a href="#git-log-–oneline" class="headerlink" title="git log –oneline"></a>git log –oneline</h5><h5 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h5><h4 id="git-reset-–【】索引"><a href="#git-reset-–【】索引" class="headerlink" title="git reset –【】索引"></a>git reset –【】索引</h4><p>1.使用 hard（使用最多）</p><p>​ 本地库的指针移动的同时 同步工作区、暂存区、本地库</p><p>2.使用 mixed</p><p>​ 本地库的指针移动的同时 同步赞存区、本地库</p><p>2.使用 soft</p><p>​ 只会让本地移动</p><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>比较工作区和暂存区的差异 （带文件比文件 ，不带比所有）</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>新建分支会先将主分支的最新版本然后加到分支</p><p><em>各自分支相互独立</em></p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><h5 id="git-branch-v"><a href="#git-branch-v" class="headerlink" title="git branch -v"></a>git branch -v</h5><p>​ 查看当前所有分支</p><h5 id="git-branch-【】"><a href="#git-branch-【】" class="headerlink" title="git branch 【】"></a>git branch 【】</h5><p>创建分支</p><h5 id="git-checkout-【】"><a href="#git-checkout-【】" class="headerlink" title="git checkout 【】"></a>git checkout 【】</h5><p>切换分支</p><p>主分支合并 其他分支</p><ol><li>切换到主分支</li><li>使用 git merge 【分支】（当主分支和其他分支 都修改了同一文件的同一位置就会冲突）</li><li>解决冲突方法：直接文件选择性删除 （再添加 提交）</li></ol><h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><p><strong>github</strong></p><p><strong>gitee</strong></p><p><strong>gitlab</strong></p><h4 id="git-remote-add-【name】【https-…-】"><a href="#git-remote-add-【name】【https-…-】" class="headerlink" title="git remote add 【name】【https://…..】"></a>git remote add 【name】【https://…..】</h4><p>本地库起远程库别名</p><h4 id="git-remote-v"><a href="#git-remote-v" class="headerlink" title="git remote -v"></a>git remote -v</h4><p>查看别名</p><p><strong>git push 【name】【分支】</strong></p><p>向远程仓库（别名）推送 本地仓库 的指定分支</p><p><strong>git clone 【https://…..】</strong></p><p>初始化本地库 从远程库克隆到本地 起了别名 origin</p><p><strong>库的拥有者拉取</strong></p><ol><li>fetch +merge 操作</li></ol><h5 id="git-fetch-【name】-【分支】"><a href="#git-fetch-【name】-【分支】" class="headerlink" title="git fetch 【name】 【分支】"></a>git fetch 【name】 【分支】</h5><p>从远程库抓取到本地库，工作区不变 这时候本地有个分支是 <strong>name/分支</strong></p><p>切换到本地 master 分支 调用 git merge name/分支 就可以合并</p><ol start="2"><li>pull 操作</li></ol><h5 id="git-pull【name】-【分支】"><a href="#git-pull【name】-【分支】" class="headerlink" title="git pull【name】 【分支】"></a>git pull【name】 【分支】</h5><p>冲突产生 需要到本地 解决再 push 到 远程仓库</p><h2 id="免密操作"><a href="#免密操作" class="headerlink" title="免密操作"></a>免密操作</h2><p>$ ssh-keygen -t rsa -C【email】</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>idea 远程 pull 前提准备</p><p>git pull origin master –allow-unrelated-histories</p><p>推送到上游其它分支</p><p>git push –set-upstream origin myblog（分支）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/26/hello-world/"/>
    <url>/2022/10/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
