<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nginx 入门 server块 书写之 location 规则 （一）</title>
    <link href="/2023/04/09/Nginx%20%E5%85%A5%E9%97%A8%20server%E5%9D%97%20%E4%B9%A6%E5%86%99%E4%B9%8B%20location%20%E8%A7%84%E5%88%99%20%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/04/09/Nginx%20%E5%85%A5%E9%97%A8%20server%E5%9D%97%20%E4%B9%A6%E5%86%99%E4%B9%8B%20location%20%E8%A7%84%E5%88%99%20%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h4 id="Nginx-入门-server块-书写之-location-规则-（一）"><a href="#Nginx-入门-server块-书写之-location-规则-（一）" class="headerlink" title="Nginx 入门 server块 书写之 location 规则 （一）"></a>Nginx 入门 server块 书写之 location 规则 （一）</h4><p>一个高性能的支持高并发的Web服务器，代理服务器</p><ol><li> 反向代理</li><li> 负载均衡</li><li> Web服务器</li><li> 安全校验，接口限流</li></ol><h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;            <span class="hljs-comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      <span class="hljs-comment"># 提供服务的端口，默认80</span><br>        server_name  localhost；       <span class="hljs-comment"># 提供服务的域名主机名</span><br>        location / &#123;            <span class="hljs-comment"># 第一个location区块开始</span><br>            root   html；       <span class="hljs-comment"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      <span class="hljs-comment"># 默认的首页文件，多个用空格分开</span><br>        &#125;          <span class="hljs-comment"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接受请求后会通过listen 以及 server_name 来匹配server模块，然后根据location匹配路径资源，一个典型的应用就是一个二级域名下的子域名全部代理到同一个端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;            <span class="hljs-comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      <span class="hljs-comment"># 提供服务的端口，默认80</span><br>        server_name  demo1.aaa.com；       <span class="hljs-comment"># 提供服务的域名主机名</span><br>        location / &#123;            <span class="hljs-comment"># 第一个location区块开始</span><br>            root   html1；       <span class="hljs-comment"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      <span class="hljs-comment"># 默认的首页文件，多个用空格分开</span><br>        &#125;          <span class="hljs-comment"># 第一个location区块结果</span><br>&#125;<br>server &#123;            <span class="hljs-comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      <span class="hljs-comment"># 提供服务的端口，默认80</span><br>        server_name  demo2.aaa.com；       <span class="hljs-comment"># 提供服务的域名主机名</span><br>        location / &#123;            <span class="hljs-comment"># 第一个location区块开始</span><br>            root   html2；       <span class="hljs-comment"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      <span class="hljs-comment"># 默认的首页文件，多个用空格分开</span><br>        &#125;          <span class="hljs-comment"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="location语法"><a href="#location语法" class="headerlink" title="location语法"></a>location语法</h4><h5 id="先说alias-和-root-的区别"><a href="#先说alias-和-root-的区别" class="headerlink" title="先说alias 和 root 的区别"></a>先说alias 和 root 的区别</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /img/ &#123;<br><span class="hljs-built_in">alias</span> /var/www/image/;<br>&#125;<br><span class="hljs-comment">#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件</span><br>location /img/ &#123;<br>root /var/www/image;<br>&#125;<br><span class="hljs-comment">#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件</span><br></code></pre></td></tr></table></figure><p>所以使用alias 最后一定是 以 / 结尾 .</p><h5 id="修饰符匹配"><a href="#修饰符匹配" class="headerlink" title="修饰符匹配"></a>修饰符匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    server_name website.com;<br>    location = /abcd &#123;<br>    […]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">#  `http://website.com/abcd`**匹配**</span><br><span class="hljs-comment">#  `http://website.com/ABCD`**可能会匹配** ，也可以不匹配，取决于操作系统的文件系统是否大小写敏感（case-sensitive）。ps: Mac 默认是大小写不敏感的</span><br><span class="hljs-comment">#  `http://website.com/abcd?param1&amp;param2`**匹配**，忽略 querystring</span><br><span class="hljs-comment">#  `http://website.com/abcd/`**不匹配**，带有结尾的`/`</span><br><span class="hljs-comment">#  `http://website.com/abcde`**不匹配**</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    server_name website.com;<br>    location ~ ^/abcd$ &#123;<br>    […]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># ^/abcd$这个正则表达式表示字符串必须以/开始，以$结束，中间必须是abcd</span><br><span class="hljs-comment">#区分大小写的正则匹配</span><br><span class="hljs-comment">#http://website.com/abcd匹配（完全匹配）</span><br><span class="hljs-comment">#http://website.com/ABCD不匹配，大小写敏感</span><br><span class="hljs-comment">#http://website.com/abcd?param1&amp;param2匹配</span><br><span class="hljs-comment">#http://website.com/abcd/不匹配，不能匹配正则表达式</span><br><span class="hljs-comment">#http://website.com/abcde不匹配，不能匹配正则表达式</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    server_name website.com;<br>    location ~* ^/abcd$ &#123;<br>    […]<br>    &#125;<br>&#125;<br><span class="hljs-comment">#不区分大小写的正则匹配</span><br><span class="hljs-comment">#http://website.com/abcd匹配 (完全匹配)</span><br><span class="hljs-comment">#http://website.com/ABCD匹配 (大小写不敏感)</span><br><span class="hljs-comment">#http://website.com/abcd?param1&amp;param2匹配</span><br><span class="hljs-comment">#http://website.com/abcd/ 不匹配，不能匹配正则表达式</span><br><span class="hljs-comment">#http://website.com/abcde 不匹配，不能匹配正则表达式</span><br></code></pre></td></tr></table></figure><p>&#x20;以下表格   ~ 代表自己输入的英文字母</p><table><thead><tr><th align="center">匹配符</th><th align="center">匹配规则</th><th align="center">优先级</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">精确匹配</td><td align="center">1</td></tr><tr><td align="center">^~</td><td align="center">以某个字符开头</td><td align="center">2</td></tr><tr><td align="center">~</td><td align="center">区分大小写的匹配正则</td><td align="center">3</td></tr><tr><td align="center">~*</td><td align="center">不区分大小写的匹配正则</td><td align="center">4</td></tr><tr><td align="center">!~</td><td align="center">区分大小写的不匹配正则</td><td align="center">5</td></tr><tr><td align="center">!~*</td><td align="center">不区分大小写的不匹配正则</td><td align="center">6</td></tr><tr><td align="center">/</td><td align="center">通用匹配,所有请求都匹配</td><td align="center">7</td></tr></tbody></table><p>**    前缀匹配下，返回最长匹配的 location，与 location 所在位置顺序无关**</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    server_name website.com;<br><span class="hljs-comment">#前缀匹配</span><br>    location /doc &#123;<br>        <span class="hljs-built_in">return</span> 702;<br>    &#125;<br>    location /docu &#123;<br>        <span class="hljs-built_in">return</span> 701;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># curl -I website.com:8080/document 依然返回 HTTP/1.1 701</span><br></code></pre></td></tr></table></figure><p>**    正则匹配使用文件中的顺序，找到返回**</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>listen 8080;<br>server_name website.com;<br><br>    location ~ ^/doc[a-z]+ &#123;<br>        <span class="hljs-built_in">return</span> 701;<br>    &#125;<br><br>    location ~ ^/docu[a-z]+ &#123;<br>        <span class="hljs-built_in">return</span> 702;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># curl -I website.com:8080/document 返回 HTTP/1.1 701</span><br><br>server &#123;<br>listen 8080;<br>server_name website.com;<br><br>    location ~ ^/docu[a-z]+ &#123;<br>        <span class="hljs-built_in">return</span> 702;<br>    &#125;<br>    <br>    location ~ ^/doc[a-z]+ &#123;<br>        <span class="hljs-built_in">return</span> 701;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># curl -I website.com:8080/document 返回 HTTP/1.1 702</span><br></code></pre></td></tr></table></figure><p>所以当有多个匹配时匹配优先级如下</p><p><strong>先精确匹配，没有则查找带有 <code>^~</code>的前缀匹配，没有则进行正则匹配，最后才返回前缀匹配的结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = / &#123;<br><span class="hljs-comment"># 仅仅匹配请求 /</span><br>[ configuration A ]<br>&#125;<br> <br>location / &#123;<br><span class="hljs-comment"># 匹配所有以 / 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。如果有正则表达式可以匹配，则</span><br><span class="hljs-comment"># 优先匹配正则表达式。</span><br>[ configuration B ]<br>&#125;<br> <br>location /documents/ &#123;<br><span class="hljs-comment"># 匹配所有以 /documents/ 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。</span><br><span class="hljs-comment">#如果有正则表达式可以匹配，则优先匹配正则表达式。</span><br>[ configuration C ]<br>&#125;<br> <br>location ^~ /images/ &#123;<br><span class="hljs-comment"># 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找。所以，即便有符合的正则表达式location，也</span><br><span class="hljs-comment"># 不会被使用</span><br>[ configuration D ]<br>&#125;<br> <br>location ~* \.(gif|jpg|jpeg)$ &#123;<br><span class="hljs-comment"># 匹配所有以 gif jpg jpeg结尾的请求。但是 以 /images/开头的请求，将使用 Configuration D</span><br>[ configuration E ]<br>&#125;<br><br><br><span class="hljs-comment">###########请求</span><br>/ -&gt; configuration A<br>/index.html -&gt; configuration B<br>/documents/document.html -&gt; configuration C<br>/images/1.gif -&gt; configuration D<br>/documents/1.jpg -&gt; configuration E<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nignx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket 实现聊天室</title>
    <link href="/2023/03/05/WebSocket%20%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/2023/03/05/WebSocket%20%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="WebSockect-实现聊天室"><a href="#WebSockect-实现聊天室" class="headerlink" title="WebSockect 实现聊天室"></a>WebSockect 实现聊天室</h2><p><strong>说明：最近二手交易课设有一个需求是实现 购买者和商品发布者有一个聊天对话的功能，类似于咸鱼的聊天对话功能吧。想到的就是 WebSocket 协议来实现，问了一个前端小伙伴，他一般使用 socketio(一个 websocket 框架)，我看了下也有 java 版的，但思考了下决定还是使用原生 websocket 来写前后端。</strong></p><h4 id="什么是-websocket？"><a href="#什么是-websocket？" class="headerlink" title="什么是 websocket？"></a>什么是 websocket？</h4><p>这里放一个知乎的高赞回答，看完很清楚。<a href="https://www.zhihu.com/question/20215561/answer/40316953">WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear 的回答 - 知乎</a></p><p>首先我们先说说大家都很了解的 Http 协议，在 B/S 开发中，我们常用这种协议来进行各种响应和处理。</p><p>他的特点就是一个 Request 和 一个 Response 而且是无状态的（想要保持状态需要间接通过 session 和 cookie）。虽然在一些不那么复杂的需求下，这样的机制已经足够了，但是一些复杂的应用场景如需要一直监听某个数据的变化就显得力不从心了。当然我们也可以使用 ajax 来轮询，但这样其实是非常低效率的，你把自己想成服务器，假设有个人（客户端）一直在你耳边叨叨（数据更新了没。。。）我想你也一定要疯掉了吧。</p><div align=center><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/inkun.jpg" alt="img" width="200"></div><p>其次 Http 协议的另一个特点，浏览器只能主动发送请求接收信息，不能被动接收服务器信息。这一点确实蛋疼，使得一旦数据有了变化我需要自己去请求，但是我又怎么知道数据什么时候更新了呢？</p><p>然鹅，websocket 的出现就可以巧妙的解决这些问题。</p><p>websocket 协由握手和数据传输构成</p><p>握手基于 HTTP 协议，然后客户端和服务端实现长连接，所以说 websocket 和 http 是有交集的。</p><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230316170428.png" alt="关系图"></p><p>那么数据如何传输呢？只需要在服务端设立转发的服务，那么数据就可以实现从 A 客户端到 B 客户端的发送，拿聊天举例，正是这种长连接机制以及允许客户端主动接收服务端消息的机制使得聊天消息能够看上去好像在两个客户端建立了连接。其实就是服务器做了一次转发。</p><h4 id="Java-怎么写服务端的-WebSocket（SpringBoot）"><a href="#Java-怎么写服务端的-WebSocket（SpringBoot）" class="headerlink" title="Java 怎么写服务端的 WebSocket（SpringBoot）"></a>Java 怎么写服务端的 WebSocket（SpringBoot）</h4><p>非常类似 Servlet，这里我们需要写<strong>ServerEndPoint</strong></p><p>这里我们主要重写三个方法</p><ol><li>onOpen(建立连接时自动调用)</li><li>onMessage(接收消息时自动调用)</li><li>onClose(关闭连接时自动调用)</li></ol><p>当然还有 onError 等方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//这个 注解类似http的map ，比如说这样你的 websocket url 就是 ws：localhost/chat</span><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatEndPoint</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  建立连接被调</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收数据被调用</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message,Session session)</span>&#123;<br><br><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(Session session)</span>&#123;<br><br><br><br>    &#125;<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里需要注意，上面 session 指的是 websocket 的 session，不是 http 的 session，也是用来标识每一个长连接的对象，看到这里聪明的小伙伴应该能想到实现消息转发可以用 session 来标识每一个用户。</p><p>所以我们想要实现聊天消息转发可以使用 map 来存储 websocket 的 session。这里我存储 EndPoint 实例类似，因为我们可以使用 endpoint 实例来获取 session 对象，记住每一个用户进行一次 websocket 长连接，就会创建一个 endpoint 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>说到这里有小伙伴想问了，项目的一些数据存储在 HttpSession 中既然 websocket 是基于 http 的，那么我能不能取出 Httpsession 在 Endpoint 里使用啊？答案是可以的，只需要在 springboot 配置中在注入对象前 ServerEndpointConfig 放入这个 httpsession 就可以了</p><p>配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title function_">serverEndpointExporter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerEndpointExporter</span>();<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetHttpSessionConfigurator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServerEndpointConfig</span>.Configurator &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyHandshake</span><span class="hljs-params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession)request.getHttpSession();<br><br>        <span class="hljs-comment">//将httpsession存到配置对象</span><br><br>        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br></code></pre></td></tr></table></figure><p>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@OnOpen</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br>       <span class="hljs-built_in">this</span>.session = session;<br><br>       <span class="hljs-comment">//获取Httpssion</span><br><br>      <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession) config.getUserProperties().get(HttpSession.class.getName());<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="前端怎么写-WebSocket"><a href="#前端怎么写-WebSocket" class="headerlink" title="前端怎么写 WebSocket"></a>前端怎么写 WebSocket</h4><p>前端其实也类似，写起来更简单，只需要 new 一个 websocket 对象就能够实现连接。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">ws</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-comment">//连接</span><br>  <span class="hljs-title function_">connect</span>(<span class="hljs-params"></span>) &#123;<br>    ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:8081/api/chat&#x27;</span>);<br>  &#125;,<br><span class="hljs-comment">//获取实例</span><br>  <span class="hljs-title function_">getWs</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ws;<br>  &#125;,<br>  <span class="hljs-comment">//关闭连接，删除实例</span><br><br>  <span class="hljs-title function_">removeWs</span>(<span class="hljs-params"></span>) &#123;<br>    ws.<span class="hljs-title function_">close</span>();<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Typescript"><span class="hljs-comment">//调用方法</span><br>ws.<span class="hljs-title function_">connect</span>();<br><br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>  &#125;;<br><br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) &#123;<br>  &#125;<br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>  &#125;;<br></code></pre></td></tr></table></figure><h4 id="聊天怎么实现"><a href="#聊天怎么实现" class="headerlink" title="聊天怎么实现"></a>聊天怎么实现</h4><p>思路</p><ol><li> 每一个客户端与服务端建立连接就将 EndPoint 实例存入 userHashMap（这里使用静态的）中。</li><li> 客户端断开连接，就将此用户从 userHashMap 去除，所以 userHashMap 始终存储在线用户</li><li> 客户端发消息，消息内容需要有发消息人，收消息人，内容，时间，封装成一个对象。</li><li> 服务端 onmessage 接收到就检查用户里 userHashMap 有没有此人（有表示在线），有就找到 session 直接转发给他，没有需要暂时存储到 chatsHashMap，存消息列表 。</li><li> 那么我们还要修改 1 步骤，这里连接上就要检查 chatsHashMap 有没有自己的消息，有就转发给自己并去除 chatsHashMap 的消息，这样一来就实现了离线和在线用户的聊天功能。</li></ol><p>后端全部代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatEndPoint</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  用来存储每个客户端对象对应的聊天记录 key 是uid value 是json</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, ArrayList&lt;String&gt;&gt; chats = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * websocket session</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span>  Session session;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * httpsession</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> HttpSession httpSession;<br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  建立连接被调</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br>        <span class="hljs-built_in">this</span>.session = session;<br><br>        <span class="hljs-comment">//获取Httpssion</span><br><br>       <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession) config.getUserProperties().get(HttpSession.class.getName());<br><br>       <span class="hljs-built_in">this</span>.httpSession = httpSession;<br><br><br>       <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>        <span class="hljs-comment">// 将当前对象存储在 容器中 key为uid</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> String.valueOf(user.getUid());<br><br>       users.put(uid,<span class="hljs-built_in">this</span>);<br><br>       <span class="hljs-comment">// 判断并建立 暂存 聊天记录的数据结构</span><br><br>       <span class="hljs-keyword">if</span>(!chats.containsKey(uid)) &#123;<br><br>           ArrayList&lt;String&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           System.out.println(uid+<span class="hljs-string">&quot;调用了一次&quot;</span>);<br>           chats.put(uid,arr);<br><br>       &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageUtils.getMessage(<span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, getUsers());<br><br>        System.out.println(message);<br>        <span class="hljs-comment">//连接就一条广播</span><br>        broadcastAllUsers(MessageUtils.getMessage(<span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;当前在线用户人数：&quot;</span>+users.size()+<span class="hljs-string">&quot;人&quot;</span>));<br>        broadcastAllUsers(message);<br><br>        <span class="hljs-comment">//获取该用户暂存离线消息并推送</span><br><br>        ArrayList&lt;String&gt; chatCache = chats.get(uid);<br><br><br>        <span class="hljs-keyword">for</span>(String chat:chatCache)&#123;<br><span class="hljs-comment">//            ChatEndPoint chatEndPoint = users.get(uid);</span><br><span class="hljs-comment">//            System.out.println(chat);</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.session.getBasicRemote().sendText(chat);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        chats.remove(uid);<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取容器里的用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; <span class="hljs-title function_">getUsers</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-keyword">return</span> ChatEndPoint.users.keySet();<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 推送所有客户端</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">broadcastAllUsers</span><span class="hljs-params">(String message)</span>&#123;<br><br>        Set&lt;String&gt; usersSet = users.keySet();<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                <span class="hljs-keyword">for</span> (String user : usersSet) &#123;<br>                    <span class="hljs-type">ChatEndPoint</span> <span class="hljs-variable">chatEndPoint</span> <span class="hljs-operator">=</span> users.get(user);<br>                    chatEndPoint.session.getBasicRemote().sendText(message);<br>                &#125;&#125; <span class="hljs-keyword">catch</span>(IOException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br><br><br>            &#125;<br><br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收数据被调用</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message,Session session)</span>&#123;<br><br><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">mess</span> <span class="hljs-operator">=</span> mapper.readValue(message, Message.class);<br><br><span class="hljs-comment">//            System.out.println(mess);</span><br><span class="hljs-comment">// 消息的接收者</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">toUid</span> <span class="hljs-operator">=</span> mess.getToUid();<br><br>            <span class="hljs-type">ChatEndPoint</span> <span class="hljs-variable">chatEndPoint</span> <span class="hljs-operator">=</span> users.get(toUid);<br><br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>            <span class="hljs-keyword">if</span>(chatEndPoint!=<span class="hljs-literal">null</span>)&#123;<br><br>                <span class="hljs-comment">// 接收用户在线直接转发</span><br><br><br><br>                <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)&#123;<br><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.LOGIN_ERROR);<br>                &#125;<br><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message1</span> <span class="hljs-operator">=</span> MessageUtils.getMessage(<span class="hljs-literal">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess);<br><br>                chatEndPoint.session.getBasicRemote().sendText(message1);<br><br><br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">//接收用户不在线 先暂时存储消息</span><br><br>                ArrayList&lt;String&gt; messages = chats.get(toUid);<br><br>                <span class="hljs-keyword">if</span>(messages == <span class="hljs-literal">null</span>)&#123;<br>                    messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    chats.put(toUid,messages);<br><br>                &#125;<br><br>                <span class="hljs-comment">//存的就是json</span><br>                messages.add(MessageUtils.getMessage(<span class="hljs-literal">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess));<br><br><br><br>            &#125;<br><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(Session session)</span>&#123;<br><br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br>        users.remove(user.getUid().toString());<br><br>        System.out.println(user.getUserName()+<span class="hljs-string">&quot;下线了，当前在线人数：&quot;</span>+users.size()+<span class="hljs-string">&quot;人&quot;</span>);<br><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前时间戳，秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getUnix</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br><br>        time = time / <span class="hljs-number">1000</span>;<br><br>        <span class="hljs-keyword">return</span> String.valueOf(time);<br><br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>前端接收怎么存储呢？我暂时只想到存储在 sessionStorage 或者 localStorage 中，但这部分数据存储需要考虑去重和数据对应每个用户，不要疏忽了让别的用户看到了不属于自己的对话内容，那就出大问题了。整体思路挺简单的就是要细心。</p><h4 id="实现展示"><a href="#实现展示" class="headerlink" title="实现展示"></a>实现展示</h4><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171042690.png" alt="image-20221125171042690"></p><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171211620.png" alt="image-20221125171211620"></p><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171244569.png" alt="image-20221125171244569"></p><p>组件采用的是 react-jwchat 感觉挺好看的，各项功能都正常，就是有时候会 websocket 连接了就断开了，猜测是没写 error 处理吧。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>最后看我的二手交易系统的前后端源码（websocket 源码也在里面）</p><p><a href="https://gitee.com/wx_504ae56474/react-jwchat">react-jwchat 聊天组件</a></p><p><a href="https://gitee.com/yilinyo/lkd-javee-trade-frontend">二手交易系统前端</a></p><p><a href="https://gitee.com/yilinyo/lkd-javaee-trade-backend">二手交易系统后端</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Git</title>
    <link href="/2023/02/06/hello-git/"/>
    <url>/2023/02/06/hello-git/</url>
    
    <content type="html"><![CDATA[<p>Git 入门笔记，带你快速使用 Git Bash 命令</p><h1 id="Git-入门"><a href="#Git-入门" class="headerlink" title="Git 入门"></a>Git 入门</h1><p>git 分布式版本控制</p><p>记录版本号 ，每个版本都有（高效的压缩解压算法）</p><h2 id="本地库"><a href="#本地库" class="headerlink" title="本地库"></a>本地库</h2><p>本地结构</p><pre><code class="hljs">1. 本地库1. 暂存区1. 工作区</code></pre><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>初始化本地库</p><h4 id="git-add-git-commit"><a href="#git-add-git-commit" class="headerlink" title="git add git commit"></a>git add <strong>git commit</strong></h4><p>工作区 -》<strong>git add</strong> 【】暂存区 -》<strong>git commit</strong> 【】 本地库</p><p>工作区 下（.git 同级）未 git add</p><p>缓存区 已经 git add 未 git commit</p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>查看工作状态</p><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>提交日志（由近到远）</p><p>每一条内容 有一个 key 索引唯一对应</p><p>不同展示样式：</p><h5 id="git-log-–pretty-oneline"><a href="#git-log-–pretty-oneline" class="headerlink" title="git log –pretty=oneline"></a>git log –pretty=oneline</h5><h5 id="git-log-–oneline"><a href="#git-log-–oneline" class="headerlink" title="git log –oneline"></a>git log –oneline</h5><h5 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h5><h4 id="git-reset-–【】索引"><a href="#git-reset-–【】索引" class="headerlink" title="git reset –【】索引"></a>git reset –【】索引</h4><p>1.使用 hard（使用最多）</p><p>​ 本地库的指针移动的同时 同步工作区、暂存区、本地库</p><p>2.使用 mixed</p><p>​ 本地库的指针移动的同时 同步暂存区、本地库</p><p>2.使用 soft</p><p>​ 只会让本地移动</p><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>比较工作区和暂存区的差异 （带文件比文件 ，不带比所有）</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>新建分支会先将主分支的最新版本然后加到分支</p><p><em>各自分支相互独立</em></p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><h5 id="git-branch-v"><a href="#git-branch-v" class="headerlink" title="git branch -v"></a>git branch -v</h5><p>​ 查看当前所有分支</p><h5 id="git-branch-【】"><a href="#git-branch-【】" class="headerlink" title="git branch 【】"></a>git branch 【】</h5><p>创建分支</p><h5 id="git-checkout-【】"><a href="#git-checkout-【】" class="headerlink" title="git checkout 【】"></a>git checkout 【】</h5><p>切换分支</p><p>主分支合并 其他分支</p><ol><li>切换到主分支</li><li>使用 git merge 【分支】（当主分支和其他分支 都修改了同一文件的同一位置就会冲突）</li><li>解决冲突方法：直接文件选择性删除 （再添加 提交）</li></ol><h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><p><strong>github</strong></p><p><strong>gitee</strong></p><p><strong>gitlab</strong></p><h4 id="git-remote-add-【name】【https-…-】"><a href="#git-remote-add-【name】【https-…-】" class="headerlink" title="git remote add 【name】【https://…..】"></a>git remote add 【name】【https://…..】</h4><p>本地库起远程库别名</p><h4 id="git-remote-v"><a href="#git-remote-v" class="headerlink" title="git remote -v"></a>git remote -v</h4><p>查看别名</p><p><strong>git push 【name】【分支】</strong></p><p>向远程仓库（别名）推送 本地仓库 的指定分支</p><p><strong>git clone 【https://…..】</strong></p><p>初始化本地库 从远程库克隆到本地 起了别名 origin</p><p><strong>库的拥有者拉取</strong></p><ol><li>fetch +merge 操作</li></ol><h5 id="git-fetch-【name】-【分支】"><a href="#git-fetch-【name】-【分支】" class="headerlink" title="git fetch 【name】 【分支】"></a>git fetch 【name】 【分支】</h5><p>从远程库抓取到本地库，工作区不变 这时候本地有个分支是 <strong>name/分支</strong></p><p>切换到本地 master 分支 调用 git merge name/分支 就可以合并</p><ol start="2"><li>pull 操作</li></ol><h5 id="git-pull【name】-【分支】"><a href="#git-pull【name】-【分支】" class="headerlink" title="git pull【name】 【分支】"></a>git pull【name】 【分支】</h5><p>冲突产生 需要到本地 解决再 push 到 远程仓库</p><h2 id="免密操作"><a href="#免密操作" class="headerlink" title="免密操作"></a>免密操作</h2><p>$ ssh-keygen -t rsa -C【email】</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>idea 远程 pull 前提准备</p><p>git pull origin master –allow-unrelated-histories</p><p>推送到上游其它分支</p><p>git push –set-upstream origin myblog（分支）</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鱼皮用户中心收获</title>
    <link href="/2023/02/05/%E9%B1%BC%E7%9A%AE%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E6%94%B6%E8%8E%B7/"/>
    <url>/2023/02/05/%E9%B1%BC%E7%9A%AE%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="鱼皮用户中心收获"><a href="#鱼皮用户中心收获" class="headerlink" title="鱼皮用户中心收获"></a>鱼皮用户中心收获</h1><p>用户中心花了大概30+小时 看了🐟所有视频</p><p>借鉴了部分同学的 笔记 ，虽然这种项目以前也做过，很多东西之前也体验过，但还是一步一步地 跟着来了一边完整的，收获确实很多。同时这个过程还额外自己补了很多细节基础。</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>首先最大的收获应该 不是代码层面的 因为业务很简单就是普通的对用户表的crud，而应该是整个 后端Java 的开发流程和规范 ，比如一些工具类，请求类，错误类的封装，这里尤其有收获的是 business错误类的引入 和  GlobelExceptionHandel 引入来处理错误信息 来像前端提供规范以及安全接口数据。其次就是 一些逻辑上的细节，还有一些敏捷开发的插件。整个后端 构建的流程和过程是很有意义的。</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>然后就是前端方面的一些，这里之前只有简单三件套的基础，虽然能听懂，但还是促使我去稍微入门学习了 一下Vue、React 还有TS ，框架上手很简单但不熟练，所以看ant design pro 和 umi我看了好几遍，勉强能简单应用，在前端视频中 我觉得比较重要的收获是 前端这些主流框架的 项目结构 ，无论是Vue react还是umi 其实都差不多，所以听一遍理解其它很快捷，然后就是ts的细节了，ts确实对java程序员很友好，学了ts的一些语法理解ant design pro 非常的便捷，然后在前端的细节其实有很多，比如api的封装以及组件库的复用、路由的利用、生产模式对proxy代理的利用、以及异步axios请求（umi里的REQUEST）请求拦截器、响应拦截器、基础配置等等。总而言之，前端总是很细。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>哦，有一点就是登录保持登陆状态这个以前没系统学，利用这个antdesign 的框架大概熟悉了 整个流程 和 如何实现前后端 ，之前笔记有提到。</p><h3 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h3><p>多环境指的是在前端和后端要配置 多种环境的数据 （数据库、消息队列、redis、端口）在启动时可供选择</p><h3 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a>部署上线</h3><p>然后就是部署上线</p><p>这里 基础的几个方式我就不讲了，主要收获应该是Docker容器部署吧，因为很早就想学了但是一直没机会.Docker 其实就是 服务器里的清新小服务器（有自己的端口、目录啥） ，在里面下环境只需要几行代码 ，然后我们利用镜像来打包 代码和环境，这样形成一个又一个的小软件就能够 通过Docker 来运行，方便快捷且独立。</p><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>然后是跨域问题</p><p>之前解决过跨域问题，但没有带cookie这次带了cookie 由于做nginx之前没看鱼皮视频 自己搞了半天 踩了好多坑，这里的收获就是前端携带 cookie 就必须要在后端设置 返回头要带上 几个重要的头，尤其是cookie要设置path和当前请求url保持一致 ，这样setcookie才会生效。这里Nginx反向代理需要配置正常</p><p>然后还有不使用反向代理，直接后端也有几种解决方法。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>然后我也自己拓展了一些接口比如查询等等</p><p>这个项目应该会成为后面项目用户的数据中心吧，可以更单多的拓展。</p><p>最后也希望以后写自己项目时时刻要提醒自己这些规范，以后要多回来看看，感谢鱼皮。</p>]]></content>
    
    
    
    <tags>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伙伴匹配系统收获</title>
    <link href="/2023/02/05/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E6%94%B6%E8%8E%B7/"/>
    <url>/2023/02/05/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="伙伴匹配系统收获"><a href="#伙伴匹配系统收获" class="headerlink" title="伙伴匹配系统收获"></a>伙伴匹配系统收获</h1><p>伙伴匹配系统前前后后花了40+小时，最后完成了这个基于Vue、Vant、Vite 以及SpringBoot的移动端 项目，有了用户中心的 基础架构，这个系统主要围绕功能如用户组队匹配以及性能优化进行开发，由于是轻量前端框架，开发上手较为容易。</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>本次项目 的 Swagger + Knife4j 接口文档的 引入 极大的提高了之前前后端联调的效率，可以自动根据Controller上的handler 方法的参数 生成对应的 前端数据格式。这个在日常开发还是很常用的.</p><p>在登录优化时引入了分布式Session, 以前的登录的Session 我们 是直接存在一台机器的服务上，但单个SpringBoot session 应用只能应用本服务。如果我们将项目拆分成微服务 或 集群部署，Session的状态就无法共享,引入spring-session-data-redis 就能够轻松的将Session 信息在redis维护，实现了分布式Session。</p><p>Redis 基于内存的 nosql 数据库 的引入让我体验到其性能的强大，除了这种分布式Session的应用，它还能广泛的应用于数据缓存，在此系统的用户表我插入了大量的模拟用户，导致查询性能大大下降，后端响应到前端的时间大概要花10来秒。这样一来用户的体验感会大大下降。利用redis 的 基于内存的存储 成功的将 第二次访问的 速度降低到了毫秒级别。</p><p>好像计算机的世界里 无论遇到什么问题加一层 缓存总能解决问题。然而引入 一个新的东西总会带来新的问题。从业务层面来说就是 我们需要维护 数据库和缓存的数据一致，但既然存在缓存我们就不可避免 两者的数据 会出现不一致，要做的就是将这种情况带来损失降低，比如设置合适的过期时间，既能带给用户良好的体验也不至于数据长时间不更新。其次就是就是只对变化不明显的数据使用缓存，这样用户感知体验会很少。从性能层面来说就是redis利用了内存，我们不能长时间占有，所以缓存的数据量一定要合适，而且一定要设置过期时间，一旦内存爆了，不然不但提升不了性能还会降低性能，同时redis 自我淘汰机制还会将重要数据淘汰掉。</p><p>还有一个细节就是使用了缓存可是我们每次第一次访问还是比较慢，这里想要第一次也读的是缓存数据就需要缓存预热，缓存预热可以是定时任务也可以是触发某个事件。然后这里引出了基于Redisson的分布式锁(感觉这里有点为了用这个技术而用了🙄) 解决分布式环境下多个应用服务只想执行一次 缓存预热的定时任务。有点类似线程里的lock锁，设置然后抢锁然后执行预热然后释放锁.多线程和分布式其实就好像一个微观下一个宏观下的竞争对手，都是为了抢夺资源，只不过前者是为了抢夺计算机资源，后者是为了提供用户的服务的资源。这里Redisson的Rlock还实现了看门狗机制，就是如果一个服务抢到锁后 在执行分布式锁住的内容时 如果过了设置最大时间还没完就会自动续期一段时间。</p><p>这个项目运用到的Redis 客户端有spring-boot-starter-data-redis、Redisson 后者比较高级支持线程安全同步。Rlock就是里面的。前者是SpringBoot推荐的。而且默认使用了jdk的序列化方法，就是最后到redis里都是一堆乱码其实是序列化号的，我们可以定制其的序列化方式增强可读性或者效率,只需要定制化配置redisTemplate的bean。</p><p>然后值得一提的就是数据库表的建立以前都是一堆数据放在一张表，查起来确实爽但是极大的浪费了性能，大量的数据冗余。维护一张关系表虽然操作起来麻烦但还是能减少IO，记得使用事物注解就行了。这次开发又熟悉了下mybatis plus。它确实强大。记得自己写的sql语句没有自动添加逻辑删除的条件。</p><p>最最最大收获就是这次的业务逻辑了，这次真的是经历了业务的完整流程，首先一定要想好需求分析再想好怎么实现，整个项目最多的地方就是在鉴权，因为队伍的创建者以及队伍的状态是有区别的。我们需要层层的判断是否有权限进行操作不然就会出现问题，有些鉴权可以直接判断，而有一些鉴权需要查数据库比如一个人最多加入5个队伍，我们要尽量让那些不要查数据库的鉴权在前面检查以减少数据库的访问。在开发过程尽量不要直接传递数据库的查询对象，多封装dto，vo来隔离原始数据，保证数据安全和数据格式统一。必要的时候对于相同的也逻辑要整体抽离。</p><p>算法这一块用的是dp实现的最小编辑距离方法，感觉这个算法还是有局限性的，可以实现更好的匹配或者推荐算法，后续有机会我再试一试。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端这次用的3V三剑客，总体来说比较轻量，这次基本学会了其使用方法，这次🐟带我们实现了之前用户中心他们实现的一些功能，比如如和自己封装axios 全局拦截器，比如自己实现用户缓存，比如vue router跳转等等，了解到了Vue开发项目的结构，比如设置模板设置组件设置路由页面，其实这个项目就是一个单页面项目，Vue-router确实方便。总体上Vue3和React还是很像的，甚至更简单，v-if，v-for太好用了，ref响应式变量也很好好用，就是要注意Vue的生命周期，这些在后面再后面细细学习把</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这个项目还可以构建小程序等等，由于赶着总结项目找实习先不弄了，这次项目后端知识点很零碎但还是不算太难，然后就是lambda表达式操作集合类是真的很爽！！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
