<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Makefile 以及 Dockfile 详解及用法.</title>
    <link href="/2025/11/05/Makefile%20%E4%BB%A5%E5%8F%8A%20Dockfile%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>/2025/11/05/Makefile%20%E4%BB%A5%E5%8F%8A%20Dockfile%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile-以及-Dockfile-详解及用法"><a href="#Makefile-以及-Dockfile-详解及用法" class="headerlink" title="Makefile 以及 Dockfile 详解及用法"></a>Makefile 以及 Dockfile 详解及用法</h1><p>虽然两者实际上没有什么关联 但名字挺像就拿来一起总结呢~~~~</p><h2 id="x20-Makefile是什么？"><a href="#x20-Makefile是什么？" class="headerlink" title="&#x20;Makefile是什么？"></a>&#x20;Makefile是什么？</h2><p><a href="https://en.wikipedia.org/wiki/Make_%28software%29">Make</a>是最常用的构建工具，诞生于1977年，主要用于C语言的项目。实际上对<strong>文件或者linux上任何操作</strong> 都可以进行 构建 (build)</p><p>通常我们可以在Makefile 文件或者makefile 构建 make 具体的方法</p><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">&lt;target&gt; : &lt;prerequisites&gt; <br>[tab]  &lt;commands&gt;<br></code></pre></td></tr></table></figure><p>target 是目标（也可以是某个文件也可以是个伪目标&lt;非文件&gt;)，这个必须有，&lt;prerequisites&gt; 前置条件（通常是文件）可有可无参数，但一旦存在就必须存在该文件</p><p>commands 命令细节 ，可有可无</p><p>这里主要讲 make 的两个主要 功能&#x20;</p><p>文件生成 构造(make)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment">#Makefile 定义</span><br><span class="hljs-section">hello: hello.c</span><br>gcc hello.c -o hello<br></code></pre></td></tr></table></figure><p>以最初的c语言编译为例，当执行make 命令的时候，会将hello.c源文件 预处理编译汇编最后生成目标文件hello；如果此时再次调用make呢？<br>1.若源文件hello.c 没有改变则会返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">make: &#x27;hello&#x27; is up to date.</span><br></code></pre></td></tr></table></figure><p>2.若源文件hello.c 发生变化 则会新生成hello覆盖原来的</p><p>所以make可以用来构建一组编译方法自动判断哪些文件需要重新编译、链接或生成</p><p>另外，还有以下例子，用来描述了如何 make c.txt</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">c.txt: a.txt b.txt</span><br>    cat b.txt a.txt &gt; a.txt<br></code></pre></td></tr></table></figure><p>除了构建文件，还能构建工具如下 调用make clean，make test，make deploy 即可执行对应目标命令，可以看到每个规则都是只有目标和命令没有前提条件，且目标也不是文件，理论上没有.PHONY: clean test deploy 也能够正常执行，但是由于之前说到的目标会被make检查是否存在，所以假设目录下有同名的clean、test、deploy文件那将无法进行make执行命令，由于没有前置条件也不会发生修改所以make就会一直make: ‘xxx’ is up to date.但是引入.PHONY: clean test deploy 就不一样了，这里定义了clean test deploy 为伪目标（非文件）其实就是个标识,之后再使用make就不去检查文件是否存在了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean test deploy</span><br><br><span class="hljs-section">clean:</span><br>rm -rf build/<br><br><span class="hljs-section">test:</span><br>pytest<br><br><span class="hljs-section">deploy:</span><br>rsync -avz ./build/ user@server:/var/www/<br><br></code></pre></td></tr></table></figure><p>运用make可以自定义任何 以“下一键启动命令”</p><ul><li>  自动生成文档；</li><li>  打包/发布项目；</li><li>  部署服务器；</li><li>  清理中间文件；</li><li>  执行测试任务；</li><li>  构建前端资源（配合 npm、webpack）；</li></ul><p>最后介绍一个小技巧</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">source: file1 file2 file3</span><br></code></pre></td></tr></table></figure><p>source 是一个伪目标，只有三个前置文件，没有任何对应的命令。make source会直接创建3个文件file1 file2 file3<br><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">可以参考阮一峰博客了解更多细节</a>，个人感觉是一篇介绍makefile比较清晰的博客</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 就是用来自定义镜像的，用于docker 进行构建images并推送到远程</p><h3 id="基础镜像（FROM）"><a href="#基础镜像（FROM）" class="headerlink" title="基础镜像（FROM）"></a>基础镜像（FROM）</h3><p>每个 Dockerfile 的第一条指令必须是 FROM，用于指定构建新镜像所基于的基础镜像。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br></code></pre></td></tr></table></figure><h3 id="工作目录（WORKDIR）"><a href="#工作目录（WORKDIR）" class="headerlink" title="工作目录（WORKDIR）"></a>工作目录（WORKDIR）</h3><p>进入容器内部时默认的目录就是工作目录<br>设置容器内的工作目录，后续的 COPY、RUN 等指令都会在这个目录下执行。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br></code></pre></td></tr></table></figure><p>可以在 Dockerfile 中多次使用 WORKDIR指令。每次使用都会更改当前的工作目录<br>如果指定的目录不存在，WORKDIR 会自动创建该目录</p><p>复制文件（COPY或ADD）<br>如果想复制多个文件到镜像中，可以使用多个 COPY 指令将本地文件或目录复制到镜像中。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 复制当前目录的所有文件到镜像的 /app 目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app/</span><br><br><span class="hljs-comment"># 复制单个文件到镜像的 /app 目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> package.json /app/</span><br></code></pre></td></tr></table></figure><p>基本语法：</p><p><code>COPY &lt;src&gt; &lt;dest&gt;</code></p><p>功能：仅用于将文件或目录从构建上下文复制到镜像中</p><p><code>特点： 简单直观：COPY 的行为非常明确，只执行复制操作 不支持 URL：不能用于从远程 URL 下载文件 不支持自动解压缩：不能自动解压缩压缩文件（如 .tar, .zip 等）</code></p><p>除了复制文件或目录外，还支持从远程 URL 下载文件以及自动解压缩压缩文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 从远程 URL 下载文件并复制到镜像中</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> https://example.com/file.zip /app/</span><br><br><span class="hljs-comment"># 自动解压缩压缩文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> file.tar.gz /app/</span><br><br><span class="hljs-comment"># 复制并自动解压缩</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> source.tar.gz /app/</span><br></code></pre></td></tr></table></figure><p>在编写Dockerfile时，推荐优先使用COPY而不是ADD，原因有几个：<br>COPY命令的功能非常明确，就是将文件从本地复制到Docker镜像中。而ADD命令除了复制文件外，还可以执行URL下载和解压操作，这可能会引入不必要的复杂性<br>ADD命令如果用于复制本地tar文件，会自动解压文件。这种行为可能会导致构建过程变得不那么可预测，尤其是当你不期望文件被解压时。而COPY命令总是按原样复制文件，不会进行任何额外的处理<br>由于ADD可以处理URL，如果URL中包含特殊字符，可能会造成构建失败。此外，如果URL指向的文件是tar文件，它会被自动解压，这可能会导致不可预见的结果<br>使用COPY可以使得Dockerfile更加清晰，对于其他开发者来说更容易理解。它减少了构建上下文的歧义，使得构建过程更易于维护<br>许多Docker最佳实践指南推荐使用COPY，因为它遵循了最小惊讶原则（Principle of Least Astonishment），即系统行为应该尽可能符合用户的预期<br>因此，除非你需要从URL下载文件或者自动解压tar文件，否则应该优先使用COPY。这样可以使 Dockerfile 更加简洁、明确和可靠</p><h3 id="运行命令（RUN）"><a href="#运行命令（RUN）" class="headerlink" title="运行命令（RUN）"></a>运行命令（RUN）</h3><p>在镜像构建过程中执行命令，用于安装软件包或配置环境。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3</span><br></code></pre></td></tr></table></figure><h3 id="设置环境变量（ENV）"><a href="#设置环境变量（ENV）" class="headerlink" title="设置环境变量（ENV）"></a>设置环境变量（ENV）</h3><p>定义环境变量，可以在后续的指令中使用。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NAME World<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$NAME</span>&quot;</span></span><br></code></pre></td></tr></table></figure><p>或者构建好了使用变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> myimage sh -c <span class="hljs-string">&#x27;echo Hello $NAME&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="暴露端口（EXPOSE）"><a href="#暴露端口（EXPOSE）" class="headerlink" title="暴露端口（EXPOSE）"></a>暴露端口（EXPOSE）</h3><p>如果想放行多个端口，可以使用多个EXPOSE指令声明容器运行时监听的端口。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="容器启动时默认执行的命令（CMD或ENTRYPOINT）"><a href="#容器启动时默认执行的命令（CMD或ENTRYPOINT）" class="headerlink" title="容器启动时默认执行的命令（CMD或ENTRYPOINT）"></a>容器启动时默认执行的命令（CMD或ENTRYPOINT）</h3><table><thead><tr><th>指令</th><th>作用</th><th>是否可被覆盖</th><th>常见用途</th></tr></thead><tbody><tr><td><code>CMD</code></td><td>定义容器启动时默认要运行的命令</td><td>✅ 可以被 <code>docker run</code> 后的命令覆盖</td><td>适合提供“默认行为”</td></tr><tr><td><code>ENTRYPOINT</code></td><td>定义容器启动时固定要运行的主命令</td><td>⚠️ 一般不会被覆盖（除非加 <code>--entrypoint</code>）</td><td>适合作为“执行入口”</td></tr></tbody></table><p>如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> alpine<br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;Hello World&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>运行docker run myimage 输出 Hello World;若是docker run myimage echo Hi 输出 Hi，进行了覆盖</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">FROM</span> alpine<br>ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>运行 docker run myimage World 输出 Hello World；运行 docker run myimage echo hi 输出  Hello echo hi；所以这里只是传递参数不过会覆盖<br>修改只能这样操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --entrypoint <span class="hljs-built_in">ls</span> myimage /<br></code></pre></td></tr></table></figure><p>通常我们会采用 ENTRYPOINT + CMD 结合使用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> alpine<br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;echo&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;Hello World&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>另外无论是dockerfile里定义了多少ENTRYPOINT 和 CMD 都只会取最后一个</p><p>举一个完整的例子</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用 ubuntu 22.04 作为基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-comment"># 设置环境变量，防止交互式提示</span><br><span class="hljs-keyword">ENV</span> DEBIAN_FRONTEND=noninteractive<br><br><span class="hljs-comment"># 更新系统包列表</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span><br><span class="language-bash">    python3 \</span><br><span class="language-bash">    python3-pip \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 使用 COPY 指令复制本地 Python 脚本到容器的工作目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hello.py /app/</span><br><br><span class="hljs-comment"># 设置容器启动命令，运行 Python 脚本</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python3&quot;</span>, <span class="hljs-string">&quot;hello.py&quot;</span>]</span><br><br></code></pre></td></tr></table></figure><p>最后编写完dockerfile 可以docker build 进行构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build --tag ubuntu-python:1.0.0 ./<br></code></pre></td></tr></table></figure><p>dockfile和makefile 看似没有关系，其实都是一种构建，其实我们也可以定义docker build 的make（一种有强迫症的封装)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: dockerbuildimg</span><br><br><span class="hljs-section">dockerbuildimg:</span><br>docker build --tag ubuntu-python:1.0.0 ./<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Makefile</tag>
      
      <tag>Dockfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言的 slice 详解</title>
    <link href="/2025/11/01/Go%20%E8%AF%AD%E8%A8%80%E7%9A%84%20slice%20%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/11/01/Go%20%E8%AF%AD%E8%A8%80%E7%9A%84%20slice%20%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-语言的-slice-详解"><a href="#Go-语言的-slice-详解" class="headerlink" title="Go 语言的 slice 详解"></a>Go 语言的 slice 详解</h1><h2 id="go语言切片底层结构"><a href="#go语言切片底层结构" class="headerlink" title="go语言切片底层结构"></a>go语言切片底层结构</h2><p>slice 是 go 语言的可变数组，维护了 一个 结构体 如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>   array unsafe.Pointer<br>   <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span><br>   <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>slice 结构体 由一个指向 数组的指针和长度、容量构成 指针指向一个底层数组，len标识切片长度，标识切片的实际长度，cap标识底层数组的最大长度，若len&lt;cap，则数组中属于切片的只有 len长度，如下图示意图，slice1只有[0,1] 两个元素,后面的2，3，4非切片的元素</p><p><img src="https://s2.loli.net/2025/10/31/XJlK4W3dNo95zPM.png" alt=".png"></p><h2 id="切片的复制与截取"><a href="#切片的复制与截取" class="headerlink" title="切片的复制与截取"></a>切片的复制与截取</h2><p>将切片进行复制（赋值一个新变量），其实就是创建一个新的slice结构体，其中array指针指向被复制的结构体指向的底层数组</p><p><img src="https://s2.loli.net/2025/10/31/imWnsAthq5NO8wD.png" alt=".png"></p><p>显然，当底层数组指向相同那么修改slice2的某个元素，同样也会影响到slice1，如下列代码所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)<br>arr1 = <span class="hljs-built_in">append</span>(arr1, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>arr2 := arr1<br>arr2[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span><br>fmt.Println(arr1, arr2)<br>&#125;<br>    <span class="hljs-comment">// [-1,1] [-1,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>arr1 = <span class="hljs-built_in">append</span>(arr1, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>arr2 := arr1[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Printf(<span class="hljs-string">&quot;arr1=%v, addr1=%p, len1=%d, cap1 = %d\n&quot;</span>, arr1, arr1, <span class="hljs-built_in">len</span>(arr1), <span class="hljs-built_in">cap</span>(arr1))<br>fmt.Printf(<span class="hljs-string">&quot;arr2=%v, addr2=%p, len1=%d, cap2 = %d\n&quot;</span>, arr2, arr2, <span class="hljs-built_in">len</span>(arr2), <span class="hljs-built_in">cap</span>(arr2))<br>arr2[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span><br>fmt.Printf(<span class="hljs-string">&quot;arr1=%v, addr1=%p\n&quot;</span>, arr1, arr1)<br>fmt.Printf(<span class="hljs-string">&quot;arr2=%v, addr2=%p\n&quot;</span>, arr2, arr2)<br>&#125;<br><span class="hljs-comment">//arr1=[0 1 2 3 4], addr1=0x1400001e180, len1=5, cap1 = 5</span><br><span class="hljs-comment">//arr2=[1 2], addr2=0x1400001e188, len1=2, cap2 = 4     容量是原容量减去被截取的元素数量</span><br><span class="hljs-comment">//arr1=[0 -1 2 3 4], addr1=0x1400001e180</span><br><span class="hljs-comment">//arr2=[-1 2], addr2=0x1400001e188</span><br></code></pre></td></tr></table></figure><p>同样的当进行切片截取，底层的数组是不会变的，新的slice结构体的array指针会指向被截取的数组的开始位置的地址</p><h2 id="追加元素到切片当中"><a href="#追加元素到切片当中" class="headerlink" title="追加元素到切片当中"></a>追加元素到切片当中</h2><p>向切片中追加元素，使用append(slice,i),Go 会检查底层数组是否有足够的容量来容纳新的元素。如果有足够的容量，新元素会被添加到底层数组的末尾，切片的长度会增加。如果没有足够的容量，就需要进行扩容。</p><p>如果容量满足：</p><p>则不会进行扩容，那么append操作会直接修改slice 的len，以及在<strong>指向底层数组后直接追加元素</strong></p><p>如果容量不满足：</p><p>则会进行扩容，首先会在<strong>底层创建一个新的数组（数组大小由此次追加元素和现有容量决定），将原底层数组的值全部拷贝到新的数组里</strong>，然后再修改slice结构体里的array指向新的数组以及len以及cap容量。</p><p><img src="https://s2.loli.net/2025/11/01/EQBuadUwzWcjGtO.png" alt="append.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>arr1 = <span class="hljs-built_in">append</span>(arr1, <span class="hljs-number">0</span>)<br><span class="hljs-comment">//打印arr1 底层数组的地址，如果填&amp;arr1 打印的是 结构体的地址</span><br>fmt.Printf(<span class="hljs-string">&quot;arr1=%v, addr1=%p\n&quot;</span>, arr1, arr1)<br>arr1 = <span class="hljs-built_in">append</span>(arr1, <span class="hljs-number">1</span>)<br>fmt.Printf(<span class="hljs-string">&quot;arr1=%v, addr1=%p\n&quot;</span>, arr1, arr1)<br>arr1 = <span class="hljs-built_in">append</span>(arr1, <span class="hljs-number">2</span>)<br>fmt.Printf(<span class="hljs-string">&quot;arr1=%v, addr1=%p\n&quot;</span>, arr1, arr1)<br>&#125;<br><span class="hljs-comment">//arr1=[0], addr1=0x140000100a0</span><br><span class="hljs-comment">//arr1=[0 1], addr1=0x140000100a0</span><br><span class="hljs-comment">//arr1=[0 1 2], addr1=0x14000016040</span><br></code></pre></td></tr></table></figure><p>在go1.18版本后扩容机制大概如下，<a href="https://developer.aliyun.com/article/1509760">可以参考 Go 语言切片如何扩容？（全面解析原理和过程）</a></p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/wrp43id6ygvkg_dbbb7a08cd394e32b906dbccc8e81997.png" alt=".png"></p><p>所以可见，切片的一次扩容会进行数组的一次全值复制，所以在初始化切片的时候尽可能制定第三个参数估计一个恰当的容量，提前在内存分配合适的空间能够减少扩容时带来的开销。</p><p>下面我可以看一个例子看我们是否真的理解了。以下代码会打印的是一样的吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   arr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)<br>   arr1 = <span class="hljs-built_in">append</span>(arr1, <span class="hljs-number">1</span>)<br>   arr2 := <span class="hljs-built_in">append</span>(arr1, <span class="hljs-number">2</span>)<br>   arr3 := <span class="hljs-built_in">append</span>(arr1, <span class="hljs-number">3</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;arr1=%v, addr1=%p\n&quot;</span>, arr1, &amp;arr1)<br>   fmt.Printf(<span class="hljs-string">&quot;arr2=%v, addr2=%p\n&quot;</span>, arr2, &amp;arr2)<br>   fmt.Printf(<span class="hljs-string">&quot;arr3=%v, addr3=%p\n&quot;</span>, arr3, &amp;arr3)<br>   arr0 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>   arr0 = <span class="hljs-built_in">append</span>(arr0, <span class="hljs-number">1</span>)<br>   arr4 := <span class="hljs-built_in">append</span>(arr0, <span class="hljs-number">2</span>)<br>   arr5 := <span class="hljs-built_in">append</span>(arr0, <span class="hljs-number">3</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;arr0=%v, addr0=%p\n&quot;</span>, arr0, &amp;arr0)<br>   fmt.Printf(<span class="hljs-string">&quot;arr4=%v, addr4=%p\n&quot;</span>, arr4, &amp;arr4)<br>   fmt.Printf(<span class="hljs-string">&quot;arr5=%v, addr5=%p\n&quot;</span>, arr5, &amp;arr5)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">arr1=[1], addr1=0x140000ba000</span><br><span class="hljs-comment">arr2=[1 3], addr2=0x140000ba018</span><br><span class="hljs-comment">arr3=[1 3], addr3=0x140000ba030</span><br><span class="hljs-comment">arr0=[1], addr0=0x140000ba090</span><br><span class="hljs-comment">arr4=[1 2], addr4=0x140000ba0a8</span><br><span class="hljs-comment">arr5=[1 3], addr5=0x140000ba0c0</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><p>arr2 和 arr3 为什么都是[1,3];因为在进行对arr1追加元素2其实只是在原来的底层数组里面增加元素，因为初始的容量是4，append一个元素满足最大容量，所以实际上arr1、arr2、arr3结构体的数组指针指向的地址是同一个，但由于arr1的len是1，所以后续相对arr1进行append，其实都是加载底层数组array[1]上，则最后的arr3 会覆盖掉arr2 的append；但是第二种场景由于一开始的容量是1，进行append后容量是不够的需要扩容，扩容底层数组会构造新的所以arr0，arr4，arr5其实结构体指针指向的是不同数组，所以也不会发生覆盖</p><h2 id="切片在底层数组基础上的完全复制"><a href="#切片在底层数组基础上的完全复制" class="headerlink" title="切片在底层数组基础上的完全复制"></a>切片在底层数组基础上的完全复制</h2><p>基于相同底层数组的复制有时候会不小心修改错数据，其实go 也提供了一个copy函数支持将切片复制是在内存空间直接复制一个一模一样的数组，来隔离切片复制后的数组共享。如果复制时长度溢出则会截断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>   arr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br>   cnt := <span class="hljs-built_in">copy</span>(arr1, arr)<br>   fmt.Printf(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt)<br>   fmt.Printf(<span class="hljs-string">&quot;arr1=%v\n&quot;</span>, arr1)<br>&#125;<br><span class="hljs-comment">//cnt=3</span><br><span class="hljs-comment">//arr1=[1 2 3]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go语言进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 进阶</title>
    <link href="/2024/01/29/Docker%20%E8%BF%9B%E9%98%B6/"/>
    <url>/2024/01/29/Docker%20%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h1><blockquote><p>docker 提供网络 定义来方便各个 容器进行通信</p></blockquote><h2 id="Docker-网络类型"><a href="#Docker-网络类型" class="headerlink" title="Docker 网络类型"></a>Docker 网络类型</h2><p>Docker 提供了几种默认的网络模式：</p><h3 id="1-桥接网络"><a href="#1-桥接网络" class="headerlink" title="1. 桥接网络"></a>1. 桥接网络</h3><p>桥接网络是默认的 Docker 网络模式，容器在这种网络下通过桥接方式与主机通信。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create &lt;network-name&gt;<br><br>docker run --network mynet my-container <span class="hljs-comment">#为 my-container 添加一个桥接模式的网络mynet</span><br><br>ocker network connect mynet nacos <span class="hljs-comment">#容器运行时中途添加网络</span><br></code></pre></td></tr></table></figure><h3 id="2-主机模式"><a href="#2-主机模式" class="headerlink" title="2. 主机模式"></a>2. 主机模式</h3><p>器共享主机的网络栈，直接使用主机的网络命名空间。容器的网络与主机相同，不进行端口映射。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --network host my-container<br></code></pre></td></tr></table></figure><h3 id="桥接和主机模式差异"><a href="#桥接和主机模式差异" class="headerlink" title="桥接和主机模式差异"></a>桥接和主机模式差异</h3><ol><li>网络隔离：</li></ol><p>桥接模式：默认模式，每个容器都有自己的网络栈，容器之间相互隔离。Docker 容器使用网络地址转换 (NAT) 进行通信。<br>主机模式：容器与主机共享网络栈，没有额外的网络隔离。容器使用主机的网络命名空间，与主机共享网络配置。</p><ol start="2"><li>端口映射：</li></ol><p>桥接模式：Docker 容器可以使用端口映射（Port Mapping）将容器内部的端口映射到主机上，使外部可以访问容器中的服务。<br>主机模式：容器直接使用主机的端口，不进行端口映射。容器内的服务直接绑定到主机的端口上。</p><ol start="3"><li>主机名：</li></ol><p>桥接模式：Docker 容器有各自的主机名，可以通过容器名或 IP 地址进行通信。<br>主机模式：容器与主机共享主机名。在主机模式下，容器可以使用主机名直接访问主机上的服务，而无需通过网络。</p><ol start="4"><li>主机网络性能：</li></ol><p>桥接模式：因为涉及额外的网络转换，可能会引入一些性能开销。<br>主机模式：由于容器直接使用主机网络栈，可能会获得更好的性能，但与此同时，可能会引入一些安全性和隔离性的考虑。</p><h2 id="网络查看"><a href="#网络查看" class="headerlink" title="网络查看"></a>网络查看</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">docker network <span class="hljs-keyword">inspect </span>mynet  <span class="hljs-comment">#查看网络mynet</span><br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在一些跨容器通讯中无需记住 ip 只需要记住容器名就可以通信<br>如在 A 容器 直接 <strong>ping mysql</strong></p><h1 id="docker-卷映射"><a href="#docker-卷映射" class="headerlink" title="docker 卷映射"></a>docker 卷映射</h1><blockquote><p>卷映射 实现宿主机到容器内部文件的映射，并在容器销毁或迁移数据时提供了一种持久性存储的解决方案</p></blockquote><h2 id="字符串自定义卷自动映射"><a href="#字符串自定义卷自动映射" class="headerlink" title="字符串自定义卷自动映射"></a>字符串自定义卷自动映射</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>docker volume inspect &lt;volume-name&gt; <span class="hljs-comment">#docker 会在/var/lib/docker/volumes/&lt;volume-name&gt;linux默认自动创建卷位置</span><br><br></code></pre></td></tr></table></figure><p>运行时 docker run 指定-v 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>docker run -d --name my-container -v my-data-volume:/app/data my-image<br><span class="hljs-comment">#my-data-volume卷用字符串即可表示 /app/data#容器内文件</span><br><br></code></pre></td></tr></table></figure><h2 id="自定义绝对位置映射"><a href="#自定义绝对位置映射" class="headerlink" title="自定义绝对位置映射"></a>自定义绝对位置映射</h2><p>直接指定绝对位置，更灵活，但迁移性不强</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name my-container -v<br>/root/docer:/app/data my-image<br><span class="hljs-comment">#/root/docer宿主机绝对位置 /app/data#容器内文件</span><br></code></pre></td></tr></table></figure><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><blockquote><p>Docker Compose 就可以帮助我们实现多个相互关联的 Docker 容器的快速部署。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p></blockquote><table><thead><tr><th>docker run 参数</th><th>docker compose 指令</th><th>说明</th></tr></thead><tbody><tr><td>–name</td><td>container_name</td><td>容器名称</td></tr><tr><td>-p</td><td>ports</td><td>端口映射</td></tr><tr><td>-e</td><td>environment</td><td>环境变量</td></tr><tr><td>-v</td><td>volumes</td><td>数据卷配置</td></tr><tr><td>–network</td><td>networks</td><td>网络</td></tr></tbody></table><h3 id="yml-文件示例"><a href="#yml-文件示例" class="headerlink" title="yml 文件示例"></a>yml 文件示例</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/data:/var/lib/mysql&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hm-net</span><br>  <span class="hljs-attr">hmall:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">hmall</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:8080&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hm-net</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;18080:18080&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;18081:18081&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hmall</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hm-net</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">hm-net:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">hmall</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/31/48tomhJTgbkXAif.png" alt="image"></p><p><a href="https://docs.docker.com/compose/reference/">docercompose 文档</a></p><h3 id="启动与检查"><a href="#启动与检查" class="headerlink" title="启动与检查"></a>启动与检查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1启动所有, -d 参数是后台启动</span><br>docker compose up -d<br><br><span class="hljs-comment"># 结果：</span><br>[+] Building 15.5s (8/8) FINISHED<br> =&gt; [internal] load build definition from Dockerfile                                    0.0s<br> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s<br> =&gt; [internal] load .dockerignore                                                       0.0s<br> =&gt; =&gt; transferring context: 2B                                                         0.0s<br> =&gt; [internal] load metadata <span class="hljs-keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s<br> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s<br> =&gt; [internal] load build context                                                       0.0s<br> =&gt; =&gt; transferring context: 98B                                                        0.0s<br> =&gt; CACHED [2/3] RUN <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span>   0.0s<br> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s<br> =&gt; exporting to image                                                                  0.0s<br> =&gt; =&gt; exporting layers                                                                 0.0s<br> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s<br> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s<br>[+] Running 4/4<br> ✔ Network hmall    Created                                                             0.2s<br> ✔ Container mysql  Started                                                             0.5s<br> ✔ Container hmall  Started                                                             0.9s<br> ✔ Container nginx  Started                                                             1.5s<br><br><span class="hljs-comment"># 2.查看镜像</span><br>docker compose images<br><span class="hljs-comment"># 结果</span><br>CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE<br>hmall               root-hmall          latest              32eebee16acd        362MB<br>mysql               mysql               latest              3218b38490ce        516MB<br>nginx               nginx               latest              605c77e624dd        141MB<br><br><span class="hljs-comment"># 3.查看容器</span><br>docker compose ps<br><span class="hljs-comment"># 结果</span><br>NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS<br>hmall               root-hmall          <span class="hljs-string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp<br>mysql               mysql               <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp<br>nginx               nginx               <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非阻塞IO NIO --入门</title>
    <link href="/2024/01/27/NIO%E5%85%A5%E9%97%A8/"/>
    <url>/2024/01/27/NIO%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>非阻塞 IO</p><blockquote><p>本笔记资料 来自<a href="https://www.bilibili.com/video/BV1py4y1E7oA/?p=6&share_source=copy_web&vd_source=5c53fad723f9304699742f8633214dd3">黑马程序 Netty 教程 </a>及 自己的一些总结</p></blockquote><h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><p><strong>在内存开辟一个缓冲区，大小不宜过大</strong></p><h3 id="ByteBuffer-的分配和状态"><a href="#ByteBuffer-的分配和状态" class="headerlink" title="ByteBuffer 的分配和状态"></a>ByteBuffer 的分配和状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h5 id="一开始-的-状态是写模式-也就是分配完空间后"><a href="#一开始-的-状态是写模式-也就是分配完空间后" class="headerlink" title="一开始 的 状态是写模式 也就是分配完空间后"></a>一开始 的 状态是<strong>写模式</strong> 也就是分配完空间后</h5><p><img src="https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png"></p><p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p><p><img src="https://s2.loli.net/2024/01/26/DzacF3P7rvwTKEy.png"></p><h5 id="flip-动作发生后，position-切换为读取位置，limit-切换为读取限制"><a href="#flip-动作发生后，position-切换为读取位置，limit-切换为读取限制" class="headerlink" title="flip 动作发生后，position 切换为读取位置，limit 切换为读取限制"></a>flip 动作发生后，position 切换为读取位置，limit 切换为<strong>读取限制</strong></h5><p><img src="https://s2.loli.net/2024/01/26/ZEVTJ2I58Hekstn.png"></p><p>读取 4 个字节后，状态</p><p><img src="https://s2.loli.net/2024/01/26/tF2nQoiPXZ6I8VY.png"></p><h5 id="clear-动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用"><a href="#clear-动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用" class="headerlink" title="clear 动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用"></a>clear 动作发生后，状态又变回<strong>写</strong>，注意这里面内容也清空，所以一般读取完才调用</h5><p><img src="https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png"></p><p>compact 方法，是把<strong>未读完的部分向前压缩</strong>，然后切换至<strong>写模式</strong></p><p><img src="https://s2.loli.net/2024/01/26/4LqTp86f1bEiGnz.png"></p><p>不同类型的空间分配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);  <span class="hljs-comment">//分配堆内存 会GC调整 读写慢</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">16</span>); <span class="hljs-comment">//分配直接内存 调用操作系统 分配慢</span><br></code></pre></td></tr></table></figure><h3 id="ByteBuffer-常见方法"><a href="#ByteBuffer-常见方法" class="headerlink" title="ByteBuffer 常见方法"></a>ByteBuffer 常见方法</h3><h4 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf); <span class="hljs-comment">//channel写</span><br>buf.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>); <span class="hljs-comment">//put写</span><br>buf.put(<span class="hljs-type">byte</span>[]); <span class="hljs-comment">//写字符数组</span><br></code></pre></td></tr></table></figure><h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf); <span class="hljs-comment">//channel读</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get(); <span class="hljs-comment">//get读 且会让position后移</span><br>buf.get(<span class="hljs-type">int</span> i) <span class="hljs-comment">//方法获取索引 i 的内容，它不会移动读指针</span><br></code></pre></td></tr></table></figure><h4 id="调指针"><a href="#调指针" class="headerlink" title="调指针"></a>调指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">buf.rewind(); <span class="hljs-comment">//rewind 方法将 position 重新置为 0</span><br><span class="hljs-comment">// rewind 增强</span><br>buf.mark();<span class="hljs-comment">//为当前postion 做一个标记</span><br>buf.reset(); <span class="hljs-comment">//重置postion 为mark位置</span><br>buf.limit(); <span class="hljs-comment">//获取limit</span><br>buf.limit(<span class="hljs-number">16</span>); <span class="hljs-comment">//设置limit16</span><br></code></pre></td></tr></table></figure><h4 id="字节数组到-ByteBuffer-转换"><a href="#字节数组到-ByteBuffer-转换" class="headerlink" title="字节数组到 ByteBuffer 转换"></a>字节数组到 ByteBuffer 转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// string 到 buffer 完成后自动会变成读模式</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer2</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>).encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br><br><span class="hljs-comment">//转换 且需要在写模式</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer3</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buffer1);<br><br>System.out.println(buffer3.toString()); <span class="hljs-comment">//你好</span><br></code></pre></td></tr></table></figure><h2 id="⚠️-FileChannel-工作模式"><a href="#⚠️-FileChannel-工作模式" class="headerlink" title="⚠️ FileChannel 工作模式"></a>⚠️ FileChannel 工作模式</h2><blockquote><p>FileChannel 和传统的文件 I/O（例如 FileInputStream、FileOutputStream）之间有几个重要的区别：</p><p>非阻塞 I/O：</p><p>FileChannel 支持非阻塞 I/O 操作，这意味着你可以使用 FileChannel 的某些方法进行异步 I/O 操作，而不必等待每个操作完成。<br>传统的文件 I/O 是阻塞的，即在进行读或写操作时，程序会一直等待直到操作完成。<br>ByteBuffer 使用：</p><p>FileChannel 与 ByteBuffer 配合使用，通过将数据存储在 ByteBuffer 中来进行读写操作。<br>传统的文件 I/O 使用 InputStream 和 OutputStream，并且通常需要在读取或写入数据之前创建一个字节数组。<br>文件锁定：</p><p>FileChannel 具有支持文件锁定的能力，可以通过 FileLock 对象实现对文件的独占或共享锁定。<br>传统文件 I/O 通常不提供直接的文件锁定机制。<br>内存映射：</p><p>FileChannel 允许将文件的一部分或整个文件映射到内存中，以便直接在内存中进行读写操作，提高性能。<br>传统文件 I/O 没有内存映射的直接支持。<br>性能优势：</p><p>由于 FileChannel 允许进行一些底层的优化，因此在某些情况下，它可以提供更好的性能，特别是对于大量数据的读写操作。<br>传统文件 I/O 可能会在处理大量数据时变得相对较慢。</p></blockquote><blockquote><p>FileChannel 只能工作在阻塞模式下</p></blockquote><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定，指定 rw</li></ul><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buffer);<br></code></pre></td></tr></table></figure><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ...;<br>buffer.put(...); <span class="hljs-comment">// 存入数据</span><br>buffer.flip();   <span class="hljs-comment">// 切换读模式</span><br><br><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>    channel.write(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>获取当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> channel.position();<br></code></pre></td></tr></table></figure><p>设置当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">newPos</span> <span class="hljs-operator">=</span> ...;<br>channel.position(newPos);<br></code></pre></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1</li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>使用 size 方法获取文件的大小</p><h4 id="强制写入-✨✨"><a href="#强制写入-✨✨" class="headerlink" title="强制写入 ✨✨"></a>强制写入 ✨✨</h4><p><strong><em>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</em></strong></p><h4 id="两个-channel-传递数据"><a href="#两个-channel-传递数据" class="headerlink" title="两个 channel 传递数据"></a>两个 channel 传递数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">FROM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloword/data.txt&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">TO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloword/to.txt&quot;</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FROM).getChannel();<br>     <span class="hljs-type">FileChannel</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TO).getChannel();<br>    ) &#123;<br>    from.transferTo(<span class="hljs-number">0</span>, from.size(), to);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>System.out.println(<span class="hljs-string">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br></code></pre></td></tr></table></figure><h3 id="Selector-管理-Channel"><a href="#Selector-管理-Channel" class="headerlink" title="Selector 管理 Channel"></a>Selector 管理 Channel</h3><p><img src="https://s2.loli.net/2024/01/26/6jpHGOtM92TJQNS.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//建立Selector</span><br>     <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>     <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buff</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><br>     <span class="hljs-comment">//打开一个ServerSocketChannel</span><br>     <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br>     <span class="hljs-comment">//设置阻塞模式为非阻塞</span><br>     ssc.configureBlocking(<span class="hljs-literal">false</span>);<br><br>     <span class="hljs-comment">// 建立Selector 和 Channel的联系</span><br>     <span class="hljs-comment">// （管理员）事件发生后，得到事件和哪个channel发生</span><br>     <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sscKey</span> <span class="hljs-operator">=</span> ssc.register(selector, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br><br>     sscKey.interestOps(SelectionKey.OP_ACCEPT);<br>     <span class="hljs-comment">//bind 一个端口</span><br>     ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8888</span>));<br><br>     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>         <span class="hljs-comment">//没有事件就阻塞，有就继续</span><br>         <span class="hljs-comment">//事件未处理就不会阻塞</span><br>         selector.select();<br><br>         <span class="hljs-comment">//拿到所有事件集合</span><br>         Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br><br>         <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br><br>             <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br><br>             <span class="hljs-comment">//事件用掉要从集合删除</span><br>             iterator.remove();<br><br>             log.debug(<span class="hljs-string">&quot;key &#123;&#125;&quot;</span>,key);<br><br>             <span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;<br><br>                 <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br><br>                 <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> channel.accept();<br>                 <span class="hljs-comment">//设置非阻塞</span><br>                 sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                 <span class="hljs-comment">//注册到selecor</span><br>                 <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sk</span> <span class="hljs-operator">=</span> sc.register(selector, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br><br>                 sk.interestOps(SelectionKey.OP_READ);<br>             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br><br>                 <span class="hljs-keyword">try</span> &#123;<br>                     <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                     <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buff);<br>                     <span class="hljs-keyword">if</span>(read==-<span class="hljs-number">1</span>)   key.cancel(); <span class="hljs-comment">//正常断开</span><br>                     <span class="hljs-keyword">else</span> &#123;<br>                         buff.flip();             ByteBufferUtil.debugRead(buff);<br>                         buff.clear();<br>                     &#125;<br>                 &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                     <span class="hljs-comment">//反注册 移除selector的 key ，因为断开会发生一个读事件</span><br>                     key.cancel();<br>                     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br><br>                 &#125;<br><br>             &#125;<br><br>         &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 入门指南</title>
    <link href="/2023/06/27/Docker%20%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/06/27/Docker%20%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-入门指南"><a href="#Docker-入门指南" class="headerlink" title="Docker 入门指南"></a>Docker 入门指南</h1><p>（本文部分由ChatGpt完成–）<br>欢迎来到Docker入门指南！本文将介绍Docker的基本概念、常用命令和使用方法，帮助你快速上手使用Docker容器化应用程序。</p><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker是一个开源的容器化平台，可以将应用程序及其依赖打包成一个独立的容器，使其可以在任何环境中以相同的方式运行。每个Docker容器都是一个轻量级的、可移植的执行单元，具有自己的文件系统、网络和进程空间，与宿主机隔离。</p><p>使用Docker，你可以快速构建、分发和运行应用程序，无需担心运行环境的差异和依赖问题。它提供了一种可靠、可重复、可扩展和安全的方式来打包应用程序。</p><h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><p>以下是一些常用的Docker命令，让我们快速了解它们：</p><ul><li><code>docker run &lt;image&gt;</code>：从镜像创建一个新容器并启动。</li><li><code>docker stop &lt;container&gt;</code>：停止一个运行中的容器。</li><li><code>docker start &lt;container&gt;</code>：启动一个已停止的容器。</li><li><code>docker restart &lt;container&gt;</code>：重启一个容器。</li><li><code>docker rm &lt;container&gt;</code>：删除一个停止的容器。</li><li><code>docker ps</code>：列出当前正在运行的容器。</li><li><code>docker images</code>：列出本地存在的镜像。</li><li><code>docker pull &lt;image&gt;</code>：从仓库下载一个镜像。</li><li><code>docker push &lt;image&gt;</code>：将一个镜像推送到仓库。</li></ul><p>这只是一小部分常用命令，你可以使用<code>docker --help</code>命令或查阅Docker文档了解更多命令和选项。</p><h2 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h2><p>下面是使用Docker的基本步骤：</p><ol><li><p>安装 Docker：根据你的操作系统选择合适的Docker安装包并进行安装。</p></li><li><p>获取镜像：从Docker Hub或其他镜像仓库中获取一个镜像，例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> pull ubuntu:latest<br></code></pre></td></tr></table></figure></li><li><p>运行容器：使用<code>docker run</code>命令从镜像创建并运行一个容器，例如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> ubuntu:latest /bin/bash<br></code></pre></td></tr></table></figure><p>这将创建一个以Ubuntu镜像为基础的容器，并进入容器的终端。</p></li><li><p>在容器中操作：在容器终端中进行你想要的操作，例如安装软件、配置环境、运行应用程序等。你可以像在正常的操作系统中一样使用命令行工具和编辑器进行操作。</p></li><li><p>保存容器状态：如果在容器中做出了更改，你可以选择将容器的状态保存为一个新的镜像，以便日后重用。首先退出容器终端，然后使用以下命令保存容器状态：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">docker commit <span class="hljs-tag">&lt;<span class="hljs-name">container</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">image_name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这将创建一个新的镜像，其中包含容器的更改。</p></li><li><p>管理容器：使用<code>docker start</code>、<code>docker stop</code>、<code>docker restart</code>和<code>docker rm</code>等命令来管理容器的生命周期。你可以根据需要启动、停止、重启和删除容器。</p></li></ol><h2 id="Docker-Run的其它方法"><a href="#Docker-Run的其它方法" class="headerlink" title="Docker Run的其它方法"></a>Docker Run的其它方法</h2><p>当使用<code>docker run</code>命令创建和运行容器时，除了镜像名称之外，还可以使用一些其他重要的参数来配置容器的行为和环境。下面是一些常用的<code>docker run</code>参数：</p><ul><li><code>-d</code>：在后台以守护进程模式运行容器。</li><li><code>--name &lt;container_name&gt;</code>：为容器指定一个名称。</li><li><code>-p &lt;host_port&gt;:&lt;container_port&gt;</code>：将容器的端口映射到主机的指定端口。</li><li><code>-v &lt;host_path&gt;:&lt;container_path&gt;</code>：将主机的目录或文件挂载到容器中。</li><li><code>-e &lt;variable=value&gt;</code>：设置环境变量。</li><li><code>--network &lt;network_name&gt;</code>：指定容器所使用的网络。</li><li><code>--restart &lt;restart_policy&gt;</code>：设置容器退出后的重启策略。</li><li><code>--volume-driver &lt;driver&gt;</code>：指定要使用的卷驱动程序。</li></ul><p>这些参数可以根据你的需求进行组合和使用。下面是一个使用<code>docker run</code>的示例，演示了一些常用参数的用法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d --name my_container -p <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> -v <span class="hljs-regexp">/path/</span>on<span class="hljs-regexp">/host:/</span>path<span class="hljs-regexp">/in/</span>container -e ENV_VAR=value --network my_network --restart always my_image:latest<br></code></pre></td></tr></table></figure><p>上述示例中，我们以守护进程模式运行名为<code>my_container</code>的容器，将主机的端口8080映射到容器的端口80，挂载主机上的<code>/path/on/host</code>目录到容器的<code>/path/in/container</code>路径，设置了一个名为<code>ENV_VAR</code>的环境变量，将容器连接到名为<code>my_network</code>的网络，并设置容器退出后始终重启。</p><p>这只是一个简单的Docker入门指南，帮助你了解Docker的基本概念和使用方法。Docker拥有强大的功能和丰富的生态系统，你可以进一步探索Docker的高级特性和用法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次比赛开发心得</title>
    <link href="/2023/05/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%AF%94%E8%B5%9B%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/"/>
    <url>/2023/05/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%AF%94%E8%B5%9B%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="应用开发的理解及效率的提升？换语言如何开发？"><a href="#应用开发的理解及效率的提升？换语言如何开发？" class="headerlink" title="应用开发的理解及效率的提升？换语言如何开发？"></a>应用开发的理解及效率的提升？换语言如何开发？</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近结束了一个比赛的项目开发，做的是人工智能与图像识别相关的。本来是不打算参加的也是受人委托，当时拿到需求确实觉得简单，但是落实起来还是以遇到了许多困难。加上很久没有写大项目了也有些生疏了…虽然最后也完成了任务，但总觉得不够完美，当然此次开发确实是让我跳出了我自己的舒适圈，本来是打算上我最拿手的java,由于某些原因我不得不使用Python来开发后端,开发的过程完全是从0摸索，真的想吐槽一下Python，报错后的错误真的很难定位到…为什么包之间不向下兼容啊。技术实现还是大同小异，本篇博客不会着重描述，只是单纯记录开发历程和一些新get到的方法。我觉得还是蛮有意义的写这样一篇技术性随笔….<br><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000759.png" alt="图像识别"><br><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000809.png" alt="视频识别"></p><h3 id="为什么选择Python"><a href="#为什么选择Python" class="headerlink" title="为什么选择Python"></a>为什么选择Python</h3><p>起初项目孵化的时候，一些简单的crud我套用的是之前一个老SpringBoot的项目，后来由于项目使用了YoloV8，看了其相关文档，毕竟是Python环境下的项目，用Python直接提供了其调用Demo，如果使用java我查阅到的资料可能最后还是会回到在java中调用Python这种套娃情况。又或者写一个图像识别的Python服务然后采用Java在进程级别进行通信，可是这样的实施成本又太高了，权衡之下最终选择了直接上Python,因为之前老早就想试试Python的fastapi。<br>刚上手的时候确实我非常惊讶于fastapi的项目配置和启动，在以往的JavaWeb开发中光是配一个Tomcat我都弄了好久，加上入门时我还要为一个一个的Servlet配配置文件以及重写方法，当时学的时候就觉得这些好麻烦，而fastapi给我的体验就是一种打开了新世界大门的写法，一行挂载一行注释一个函数一个路由就写好了，这也太便捷了，这简直让web开发的成本一下降低了好几个档次。<br>如果你对fastapi感谢趣不妨去看看他的<a href="https://fastapi.tiangolo.com/zh/">官方文档</a>，你就会惊叹其便捷之处了！</p><h3 id="简单带来的问题"><a href="#简单带来的问题" class="headerlink" title="简单带来的问题"></a>简单带来的问题</h3><p>上手快的确带来了一时爽，在开发过程中健壮性、易维护性的问题却会逐渐的暴露出来，当然这里仅是一位初级Python web开发者的拙见。在运行时的报错虽然能够利用Pydanic来抑制错误信息的暴露，但在开发过程中错误的定位让我非常难受，有时候一个错误很细节但他的报错却深入到源码底层，不是特别熟悉的玩家还真是头大，其次就是一些包他实现的功能可能和你预期的不太一样，需要细细甄别，然后就是环境问题了，也许就是一个不同的版本的包造成的结果会是一堆爆红，如果你不是老手还真是很难发现其中的奥秘……总而言之我还是非常欣赏这种web开发框架的设计方式，规范问题需要的是程序员自己积累，开发一些小型后台api确实省时省力。</p><h3 id="协程函数"><a href="#协程函数" class="headerlink" title="协程函数"></a>协程函数</h3><p>这是自上次面试背八股在实际开发遇到的有关协程的问题。其实早在JavaScript 就有打过交道的await 和 async。协程不同于线程和进程，他是由程序员自己创建出来的帮我们提高代码IO阻塞代码效率的一种调度方式，当然这样说还是有点牵强的，但是有一点是必须的那就是协程一定是在线程之上的，一个线程的阻塞不会让协程也停止调度，异步IO将会挂起切换到其他协程，是一种分时复用的思想，听起来好像和多线程差不多，但是其实协程的切换是在用户态，他也不需要额外的内存空间，效率非常高。<a href="https://zhuanlan.zhihu.com/p/172471249">什么是协程?</a></p><table><thead><tr><th></th><th>进程</th><th>线程(特指内核态线程)</th><th>协程</th></tr></thead><tbody><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换时机</td><td>根据操作系统自己的切换策略，用户不感知</td><td>根据操作系统自己的切换策略，用户不感知</td><td>用户觉定</td></tr><tr><td>切换内容</td><td>页全局目录、内核栈、硬件上下文</td><td>内核栈、硬件上下文</td><td>硬件上下文</td></tr><tr><td>切换内容的保存</td><td>保存于内核栈中</td><td>保存于内核栈中</td><td>（用户栈/堆）</td></tr><tr><td>切换过程</td><td>用户态-内核态-用户态</td><td>用户态-内核态-用户态</td><td>用户态</td></tr></tbody></table><p><a href="https://m.elecfans.com/article/1589126.html">浅析Python中异步和同步函数</a></p><h3 id="工程化的项目"><a href="#工程化的项目" class="headerlink" title="工程化的项目"></a>工程化的项目</h3><p>软件开发的一个重要目标就是要容易维护，无论是前端还是后端严格的分层次带来的长期收益是巨大的，例如前端我以前经常会把一个页面的组件、逻辑、数据写到一个文件里，一旦逻辑复杂一点，整个项目就会显得非常臃肿.这次我几乎大改了新版的ant design pro,踩了好多坑也自己实现了许多之前他自带的很多全局方法。最重要的还是<strong>组件化的思想</strong>，组件可以独立的拆分你的UI视图，他们是可以复用的，独立的单元。和函数类似，React中组件接收的输入源称为props，并且返回react元素。react元素是对UI界面的描述。你可以告诉react你期望的UI界面，剩下的工作可以交给react来处理。我们拿乘坐计程车打比方，当你告诉司机你想要去的地方，司机就会按照你期望地点将你安全的送到目的地。而不用你自己亲自开车。<br>在FastApi 我依旧沿用了MVC 的开发模式，当然这里V由react代替了，只不过Python好像大部分也是在写函数式的M和C.<br><strong>函数式编程（Functional Programming）是一种编程方式，它将计算机运算视为数学函数的计算，并且避免了状态变量和可变数据。函数式编程强调函数的纯粹性，即一个函数的返回结果只由输入决定，不受外部环境影响。</strong> 这里要区别于面向过程和面向过程的编程，他们强调的点不一样,在此就不详细讨论了，后续会有专门的文章来讲讲其中的差异.</p><h3 id="人工智能将取代程序员？"><a href="#人工智能将取代程序员？" class="headerlink" title="人工智能将取代程序员？"></a>人工智能将取代程序员？</h3><p>说实话此次开发，chatgpt帮了我很多忙，我甚至让他帮我写了很多组件和工具函数，其中不乏一些核心的yolov8结合opencv的视频视频逻辑，其准确率异常的高，不得不说现在的人工智能的出现对一些行业是会出现一定的冲击。但是他依旧会存在一些问题如果你的需求不够具体，这就像产品经理像程序员提需求一样，不说个清楚，写出来又不满意哈哈◑﹏◐<br>但是要是说人工智能会取代我们程序员还是有待商榷，因为在一个项目中，其业务逻辑还是很复杂的，很有可能不同模块是不同人开发的，你让他完整的写一个程序他考虑的东西还是太少了，你让他写一部分程序，他又不能严格按照我们的代码风格为我们服务，总之用它写一些不需要多模块联动交互的逻辑工具方法还是挺方便的，能够极大提高效率，完全依赖于它也许不是一个很好的办法。我们还是动动脑子的…</p><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502001816.png" alt="chatgpt帮我写代码"></p>]]></content>
    
    
    
    <tags>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 入门 server块 书写之 location 规则 （二）</title>
    <link href="/2023/04/09/Nginx%20%E5%85%A5%E9%97%A8%20server%E5%9D%97%20%E4%B9%A6%E5%86%99%E4%B9%8B%20location%20%E8%A7%84%E5%88%99%20%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/04/09/Nginx%20%E5%85%A5%E9%97%A8%20server%E5%9D%97%20%E4%B9%A6%E5%86%99%E4%B9%8B%20location%20%E8%A7%84%E5%88%99%20%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx-入门-server块-书写之-location-规则-（二）"><a href="#Nginx-入门-server块-书写之-location-规则-（二）" class="headerlink" title="Nginx 入门 server块 书写之 location 规则 （二）"></a>Nginx 入门 server块 书写之 location 规则 （二）</h1><p>接上文，我们学习了location 路由匹配规则和优先级，今天我们深入其内部来探寻实际处理的各个属性书写方式。</p><h3 id="Return-指令"><a href="#Return-指令" class="headerlink" title="Return 指令"></a>Return 指令</h3><p><strong>return一般用于对请求的客户端直接返回响应状态码。在该作用域内return后面的所有nginx配置都是无效的。可以使用在server、location以及if配置中。除了支持跟状态码，还可以跟字符串或者url链接。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">  1 server&#123;<br>  2     listen 80;<br>  3     server_name www.aaa.com;<br>  4     <span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;hello&quot;</span>;<br>  5 &#125;<br> <br> <br><span class="hljs-comment">#说明：如果要想返回字符串，必须要加上状态码，否则会报错。</span><br> <br> <br>  1 location ^~ /aming &#123;<br>  2     default_type application/json ;<br>  3     <span class="hljs-built_in">return</span> 200  <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;xhy&quot;,&quot;id&quot;:&quot;100&quot;&#125;&#x27;</span>;<br>  4 &#125;<br><span class="hljs-comment">#返回的字符串也支持json数据。</span><br> <br> <br>  1 location /test &#123;<br>  2     <span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;<span class="hljs-variable">$host</span> <span class="hljs-variable">$request_uri</span>&quot;</span>;<br>  3 &#125;<br><span class="hljs-comment">#返回的字符串也支持变量</span><br> <br> <br>  1 server&#123;<br>  2     listen 80;<br>  3     server_name www.aaa.com;<br>  4     <span class="hljs-built_in">return</span> http://www.baidu.com;<br>  5     rewrite /(.*) /abc/<span class="hljs-variable">$1</span>;<span class="hljs-comment">#该行配置位于return后，则不会被执行。</span><br>  6 &#125;<br> <br><span class="hljs-comment"># 注意：return后面的url必须是以http://或者https://开头的。</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#常见的重定向</span><br>location = /tutorial/learning-nginx &#123;<br>     <span class="hljs-built_in">return</span> 301 <span class="hljs-variable">$scheme</span>://example.com/nginx/understanding-nginx<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Rewrite指令"><a href="#Rewrite指令" class="headerlink" title="Rewrite指令"></a>Rewrite指令</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">rewrite regex replacement-url [flag];<br><span class="hljs-section">regex: 正则表达式</span><br><span class="hljs-section">replacement-url: 替换的URL</span><br><span class="hljs-section">flag: 用于进行一些额外的处理</span><br><br></code></pre></td></tr></table></figure><p>不同flag的效果：</p><table><thead><tr><th align="left">flag</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">last</td><td align="left">停止解析，并开始搜索与更改后的<code>URI</code>相匹配的<code>location</code>;</td></tr><tr><td align="left">break</td><td align="left">中止 rewrite，不再继续匹配</td></tr><tr><td align="left">redirect</td><td align="left">返回临时重定向的 HTTP 状态 302</td></tr><tr><td align="left">permanent</td><td align="left">返回永久重定向的 HTTP 状态 301</td></tr></tbody></table><p>案例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = /nginx-tutorial <br>&#123; <br>    rewrite ^/nginx-tutorial?$ /somePage.html last; <br>&#125;<br><br><br><span class="hljs-comment">#把`https://example.com/nginx-tutorial`重写为#`https://example.com/somePage.html`</span><br><br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = /user.php <br>&#123; <br>    rewrite ^/user.php?<span class="hljs-built_in">id</span>=([0-9]+)$ /user/<span class="hljs-variable">$1</span> last; <br>&#125;<br><span class="hljs-comment">##### 动态替换案例</span><br><br><span class="hljs-comment">#把`https://www.example.com/user.php?id=11`重写为`https://exampleshop.com/user/11`</span><br><br><span class="hljs-comment"># 其中`$1`表示`regex`中第一个括号中的值，第二个括号中的值可通过`$2`获取</span><br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = /<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$http_user_agent</span> ~* (mobile|nokia|iphone|ipad|android|samsung|htc|blackberry)) &#123;<br>    rewrite ^(.*) https://m.example.com<span class="hljs-variable">$1</span> redirect;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">##### 手机访问重定向网址</span><br><br><span class="hljs-comment"># 把`https://www.example.com`重写为`https://m.exampleshop.com`</span><br></code></pre></td></tr></table></figure><h3 id="Proxy指令"><a href="#Proxy指令" class="headerlink" title="Proxy指令"></a>Proxy指令</h3><p>用于转发请求，常用于反向代理，注意以下细节</p><ul><li>  proxy_pass的链接无<code>/</code></li><li>  proxy_pass的链接有<code>/</code></li></ul><h4 id="第一种：proxy-pass的链接无"><a href="#第一种：proxy-pass的链接无" class="headerlink" title="第一种：proxy_pass的链接无/"></a><strong>第一种：proxy_pass的链接无<code>/</code></strong></h4><p><strong>proxy_pass中，不带『/』，则把『匹配字符串及后缀（/api/xxx）』均带给转发地址</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 效果为：http://xxx.xxx.com/api/xxx -&gt; http://127.0.0.1:7000/api/xxx. 转发的时候,包含了url前缀.</span><br>location ^~ /api/ &#123; <br>    proxy_pass  http://127.0.0.1:7000; <br>&#125;<br><br><span class="hljs-comment"># 效果与上面一致</span><br>location ^~ /api &#123;<br>    proxy_pass  http://127.0.0.1:7000; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二种：proxy-pass的链接有"><a href="#第二种：proxy-pass的链接有" class="headerlink" title="第二种：proxy_pass的链接有/"></a>第二种：proxy_pass的链接有<code>/</code></h4><p>proxy_pass中，带『/』，则把『请求地址排除匹配字符串（/api/）』后，再带给转发地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 效果为：http://xxx.xxx.com/api/xxx --&gt; http://127.0.0.1:7000/xxx</span><br>location ^~ /api/ &#123;<br>    proxy_pass  http://127.0.0.1:7000/; <span class="hljs-comment"># 端口后多了斜杠『/』</span><br>&#125;<br><br><span class="hljs-comment"># 注意：下面的代码会导致失败，原因为『/api/xxx排除了/api』后，会把『/xxx』带给转发地址，但转发地址中已有了斜杠，结果会多了一条斜杠，报错。</span><br><span class="hljs-comment"># 效果为：http://xxx.xxx.com/api/xxx --&gt; http://127.0.0.1:7000//xxx</span><br>location ^~ /api &#123;  <span class="hljs-comment"># 这里的匹配字符串最后少了斜杠『/』</span><br>    proxy_pass  http://127.0.0.1:7000/;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>location的修饰符为正则匹配时，proxy_pass的地址最后不要带斜杠</strong></p><p>一些简单的常用的 proxy_pass参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">location / &#123;<br>      proxy_pass http://game;<br>      <span class="hljs-comment"># 用户请求的时候HOST的值是game1.test.com, 那么代理服务会像后端传递请求的还是game1.test.com</span><br>      proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>      <span class="hljs-comment"># 将$remote_addr的值放进变量X-Real-IP中，$remote_addr的值为客户端的ip</span><br>      proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>      <span class="hljs-comment"># 客户端通过代理服务访问后端服务, 后端服务通过该变量会记录真实客户端地址</span><br>      proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>      <span class="hljs-comment"># nginx代理与后端服务器连接超时时间(代理连接超时)</span><br>      proxy_connect_timeout 10s;<br>     <span class="hljs-comment"># nginx代理等待后端服务器的响应时间 </span><br>     proxy_read_timeout 10s;<br>     <span class="hljs-comment"># 后端服务器数据回传给nginx代理超时时间</span><br>     proxy_send_timeout 10s;<br>     <span class="hljs-comment"># nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端，边收边传, 不是全部接收完再传给客户  </span><br>     proxy_buffering on;<br>     <span class="hljs-comment"># 设置nginx代理保存用户头信息的缓冲区大小</span><br>     proxy_buffer_size  8k;<br>     <span class="hljs-comment"># proxy_buffers 缓冲区 </span><br>     proxy_buffers 8 8k;<br>     <span class="hljs-comment"># 状态标记</span><br>     proxy_next_upstream http_404  http_500  http_502  http_503  http_504  http_403  http_429;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="try-files指令"><a href="#try-files指令" class="headerlink" title="try_files指令"></a>try_files指令</h3><p>　格式1：<strong>try_files</strong> <em><code>file</code></em> … <em><code>uri</code></em>;  格式2：<strong>try_files</strong> <em><code>file</code></em> … =<em><code>code</code></em>;</p><blockquote><p>**Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the *<code>file</code>*parameter according to the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#root">root</a> and <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#alias">alias</a> directives. It is possible to check directory’s existence by specifying a slash at the end of a name, e.g. “<code>$uri/</code>”. If none of the files were found, an internal redirect to the *****<code>uri</code>*** specified in the last parameter is made. </p></blockquote><ul><li>  　　关键点1：按指定的file顺序查找存在的文件，并使用第一个找到的文件进行请求处理</li></ul><ul><li>  　　关键点2：查找路径是按照给定的root或alias为根路径来查找的</li></ul><ul><li>  　　关键点3：如果给出的file都没有匹配到，则重新请求最后一个参数给定的uri，就是新的location匹配</li></ul><ul><li>  　　关键点4：如果是格式2，如果最后一个参数是 = 404 ，若给出的file都没有匹配到，则最后返回404的响应码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /images/ &#123;<br>    root /opt/html/;<br>    try_files <span class="hljs-variable">$uri</span>   <span class="hljs-variable">$uri</span>/  /images/default.gif; <br>&#125;<br><span class="hljs-comment"># 比如 请求 127.0.0.1/images/test.gif 会依次查找 1.文#件/opt/html/images/test.gif   2.文件夹 /opt/html/images/test.gif/下的index文件  3. 请求127.0.0.1/images/default.gif</span><br><br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/jedi1995/p/10900224.html">nginx配置选项try_files详解 - 陈一风 - 博客园 (cnblogs.com)</a></p><h3 id="Nginx内置绑定变量"><a href="#Nginx内置绑定变量" class="headerlink" title="Nginx内置绑定变量"></a>Nginx内置绑定变量</h3><p><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/openresty/inline_var.html">使用 Nginx 内置绑定变量 · OpenResty最佳实践 (gitbooks.io)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 入门 server块 书写之 location 规则 （一）</title>
    <link href="/2023/04/08/Nginx%20%E5%85%A5%E9%97%A8%20server%E5%9D%97%20%E4%B9%A6%E5%86%99%E4%B9%8B%20location%20%E8%A7%84%E5%88%99%20%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/04/08/Nginx%20%E5%85%A5%E9%97%A8%20server%E5%9D%97%20%E4%B9%A6%E5%86%99%E4%B9%8B%20location%20%E8%A7%84%E5%88%99%20%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx-入门-server块-书写之-location-规则-（一）"><a href="#Nginx-入门-server块-书写之-location-规则-（一）" class="headerlink" title="Nginx 入门 server块 书写之 location 规则 （一）"></a>Nginx 入门 server块 书写之 location 规则 （一）</h1><p>一个高性能的支持高并发的Web服务器，代理服务器</p><ol><li> 反向代理</li><li> 负载均衡</li><li> Web服务器</li><li> 安全校验，接口限流</li></ol><h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;            <span class="hljs-comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      <span class="hljs-comment"># 提供服务的端口，默认80</span><br>        server_name  localhost；       <span class="hljs-comment"># 提供服务的域名主机名</span><br>        location / &#123;            <span class="hljs-comment"># 第一个location区块开始</span><br>            root   html；       <span class="hljs-comment"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      <span class="hljs-comment"># 默认的首页文件，多个用空格分开</span><br>        &#125;          <span class="hljs-comment"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接受请求后会通过listen 以及 server_name 来匹配server模块，然后根据location匹配路径资源，一个典型的应用就是一个二级域名下的子域名全部代理到同一个端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;            <span class="hljs-comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      <span class="hljs-comment"># 提供服务的端口，默认80</span><br>        server_name  demo1.aaa.com；       <span class="hljs-comment"># 提供服务的域名主机名</span><br>        location / &#123;            <span class="hljs-comment"># 第一个location区块开始</span><br>            root   html1；       <span class="hljs-comment"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      <span class="hljs-comment"># 默认的首页文件，多个用空格分开</span><br>        &#125;          <span class="hljs-comment"># 第一个location区块结果</span><br>&#125;<br>server &#123;            <span class="hljs-comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      <span class="hljs-comment"># 提供服务的端口，默认80</span><br>        server_name  demo2.aaa.com；       <span class="hljs-comment"># 提供服务的域名主机名</span><br>        location / &#123;            <span class="hljs-comment"># 第一个location区块开始</span><br>            root   html2；       <span class="hljs-comment"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      <span class="hljs-comment"># 默认的首页文件，多个用空格分开</span><br>        &#125;          <span class="hljs-comment"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="location语法"><a href="#location语法" class="headerlink" title="location语法"></a>location语法</h4><h5 id="先说alias-和-root-的区别"><a href="#先说alias-和-root-的区别" class="headerlink" title="先说alias 和 root 的区别"></a>先说alias 和 root 的区别</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /img/ &#123;<br><span class="hljs-built_in">alias</span> /var/www/image/;<br>&#125;<br><span class="hljs-comment">#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件</span><br>location /img/ &#123;<br>root /var/www/image;<br>&#125;<br><span class="hljs-comment">#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件</span><br></code></pre></td></tr></table></figure><p>所以使用alias 最后一定是 以 / 结尾 .</p><h5 id="修饰符匹配"><a href="#修饰符匹配" class="headerlink" title="修饰符匹配"></a>修饰符匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    server_name website.com;<br>    location = /abcd &#123;<br>    […]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">#  `http://website.com/abcd`**匹配**</span><br><span class="hljs-comment">#  `http://website.com/ABCD`**可能会匹配** ，也可以不匹配，取决于操作系统的文件系统是否大小写敏感（case-sensitive）。ps: Mac 默认是大小写不敏感的</span><br><span class="hljs-comment">#  `http://website.com/abcd?param1&amp;param2`**匹配**，忽略 querystring</span><br><span class="hljs-comment">#  `http://website.com/abcd/`**不匹配**，带有结尾的`/`</span><br><span class="hljs-comment">#  `http://website.com/abcde`**不匹配**</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    server_name website.com;<br>    location ~ ^/abcd$ &#123;<br>    […]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># ^/abcd$这个正则表达式表示字符串必须以/开始，以$结束，中间必须是abcd</span><br><span class="hljs-comment">#区分大小写的正则匹配</span><br><span class="hljs-comment">#http://website.com/abcd匹配（完全匹配）</span><br><span class="hljs-comment">#http://website.com/ABCD不匹配，大小写敏感</span><br><span class="hljs-comment">#http://website.com/abcd?param1&amp;param2匹配</span><br><span class="hljs-comment">#http://website.com/abcd/不匹配，不能匹配正则表达式</span><br><span class="hljs-comment">#http://website.com/abcde不匹配，不能匹配正则表达式</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    server_name website.com;<br>    location ~* ^/abcd$ &#123;<br>    […]<br>    &#125;<br>&#125;<br><span class="hljs-comment">#不区分大小写的正则匹配</span><br><span class="hljs-comment">#http://website.com/abcd匹配 (完全匹配)</span><br><span class="hljs-comment">#http://website.com/ABCD匹配 (大小写不敏感)</span><br><span class="hljs-comment">#http://website.com/abcd?param1&amp;param2匹配</span><br><span class="hljs-comment">#http://website.com/abcd/ 不匹配，不能匹配正则表达式</span><br><span class="hljs-comment">#http://website.com/abcde 不匹配，不能匹配正则表达式</span><br></code></pre></td></tr></table></figure><p>&#x20;以下表格   ~ 代表自己输入的英文字母</p><table><thead><tr><th align="center">匹配符</th><th align="center">匹配规则</th><th align="center">优先级</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">精确匹配</td><td align="center">1</td></tr><tr><td align="center">^~</td><td align="center">以某个字符开头</td><td align="center">2</td></tr><tr><td align="center">~</td><td align="center">区分大小写的匹配正则</td><td align="center">3</td></tr><tr><td align="center">~*</td><td align="center">不区分大小写的匹配正则</td><td align="center">4</td></tr><tr><td align="center">!~</td><td align="center">区分大小写的不匹配正则</td><td align="center">5</td></tr><tr><td align="center">!~*</td><td align="center">不区分大小写的不匹配正则</td><td align="center">6</td></tr><tr><td align="center">/</td><td align="center">通用匹配,所有请求都匹配</td><td align="center">7</td></tr></tbody></table><p>**    前缀匹配下，返回最长匹配的 location，与 location 所在位置顺序无关**</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    server_name website.com;<br><span class="hljs-comment">#前缀匹配</span><br>    location /doc &#123;<br>        <span class="hljs-built_in">return</span> 702;<br>    &#125;<br>    location /docu &#123;<br>        <span class="hljs-built_in">return</span> 701;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># curl -I website.com:8080/document 依然返回 HTTP/1.1 701</span><br></code></pre></td></tr></table></figure><p>**    正则匹配使用文件中的顺序，找到返回**</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>listen 8080;<br>server_name website.com;<br><br>    location ~ ^/doc[a-z]+ &#123;<br>        <span class="hljs-built_in">return</span> 701;<br>    &#125;<br><br>    location ~ ^/docu[a-z]+ &#123;<br>        <span class="hljs-built_in">return</span> 702;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># curl -I website.com:8080/document 返回 HTTP/1.1 701</span><br><br>server &#123;<br>listen 8080;<br>server_name website.com;<br><br>    location ~ ^/docu[a-z]+ &#123;<br>        <span class="hljs-built_in">return</span> 702;<br>    &#125;<br>    <br>    location ~ ^/doc[a-z]+ &#123;<br>        <span class="hljs-built_in">return</span> 701;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># curl -I website.com:8080/document 返回 HTTP/1.1 702</span><br></code></pre></td></tr></table></figure><p>所以当有多个匹配时匹配优先级如下</p><p><strong>先精确匹配，没有则查找带有 <code>^~</code>的前缀匹配，没有则进行正则匹配，最后才返回前缀匹配的结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = / &#123;<br><span class="hljs-comment"># 仅仅匹配请求 /</span><br>[ configuration A ]<br>&#125;<br> <br>location / &#123;<br><span class="hljs-comment"># 匹配所有以 / 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。如果有正则表达式可以匹配，则</span><br><span class="hljs-comment"># 优先匹配正则表达式。</span><br>[ configuration B ]<br>&#125;<br> <br>location /documents/ &#123;<br><span class="hljs-comment"># 匹配所有以 /documents/ 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。</span><br><span class="hljs-comment">#如果有正则表达式可以匹配，则优先匹配正则表达式。</span><br>[ configuration C ]<br>&#125;<br> <br>location ^~ /images/ &#123;<br><span class="hljs-comment"># 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找。所以，即便有符合的正则表达式location，也</span><br><span class="hljs-comment"># 不会被使用</span><br>[ configuration D ]<br>&#125;<br> <br>location ~* \.(gif|jpg|jpeg)$ &#123;<br><span class="hljs-comment"># 匹配所有以 gif jpg jpeg结尾的请求。但是 以 /images/开头的请求，将使用 Configuration D</span><br>[ configuration E ]<br>&#125;<br><br><br><span class="hljs-comment">###########请求</span><br>/ -&gt; configuration A<br>/index.html -&gt; configuration B<br>/documents/document.html -&gt; configuration C<br>/images/1.gif -&gt; configuration D<br>/documents/1.jpg -&gt; configuration E<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket 实现聊天室</title>
    <link href="/2023/03/05/WebSocket%20%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/2023/03/05/WebSocket%20%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="WebSockect-实现聊天室"><a href="#WebSockect-实现聊天室" class="headerlink" title="WebSockect 实现聊天室"></a>WebSockect 实现聊天室</h2><p><strong>说明：最近二手交易课设有一个需求是实现 购买者和商品发布者有一个聊天对话的功能，类似于咸鱼的聊天对话功能吧。想到的就是 WebSocket 协议来实现，问了一个前端小伙伴，他一般使用 socketio(一个 websocket 框架)，我看了下也有 java 版的，但思考了下决定还是使用原生 websocket 来写前后端。</strong></p><h4 id="什么是-websocket？"><a href="#什么是-websocket？" class="headerlink" title="什么是 websocket？"></a>什么是 websocket？</h4><p>这里放一个知乎的高赞回答，看完很清楚。<a href="https://www.zhihu.com/question/20215561/answer/40316953">WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear 的回答 - 知乎</a></p><p>首先我们先说说大家都很了解的 Http 协议，在 B/S 开发中，我们常用这种协议来进行各种响应和处理。</p><p>他的特点就是一个 Request 和 一个 Response 而且是无状态的（想要保持状态需要间接通过 session 和 cookie）。虽然在一些不那么复杂的需求下，这样的机制已经足够了，但是一些复杂的应用场景如需要一直监听某个数据的变化就显得力不从心了。当然我们也可以使用 ajax 来轮询，但这样其实是非常低效率的，你把自己想成服务器，假设有个人（客户端）一直在你耳边叨叨（数据更新了没。。。）我想你也一定要疯掉了吧。</p><div align=center><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/inkun.jpg" alt="img" width="200"></div><p>其次 Http 协议的另一个特点，浏览器只能主动发送请求接收信息，不能被动接收服务器信息。这一点确实蛋疼，使得一旦数据有了变化我需要自己去请求，但是我又怎么知道数据什么时候更新了呢？</p><p>然鹅，websocket 的出现就可以巧妙的解决这些问题。</p><p>websocket 协由握手和数据传输构成</p><p>握手基于 HTTP 协议，然后客户端和服务端实现长连接，所以说 websocket 和 http 是有交集的。</p><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230316170428.png" alt="关系图"></p><p>那么数据如何传输呢？只需要在服务端设立转发的服务，那么数据就可以实现从 A 客户端到 B 客户端的发送，拿聊天举例，正是这种长连接机制以及允许客户端主动接收服务端消息的机制使得聊天消息能够看上去好像在两个客户端建立了连接。其实就是服务器做了一次转发。</p><h4 id="Java-怎么写服务端的-WebSocket（SpringBoot）"><a href="#Java-怎么写服务端的-WebSocket（SpringBoot）" class="headerlink" title="Java 怎么写服务端的 WebSocket（SpringBoot）"></a>Java 怎么写服务端的 WebSocket（SpringBoot）</h4><p>非常类似 Servlet，这里我们需要写<strong>ServerEndPoint</strong></p><p>这里我们主要重写三个方法</p><ol><li>onOpen(建立连接时自动调用)</li><li>onMessage(接收消息时自动调用)</li><li>onClose(关闭连接时自动调用)</li></ol><p>当然还有 onError 等方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//这个 注解类似http的map ，比如说这样你的 websocket url 就是 ws：localhost/chat</span><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatEndPoint</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  建立连接被调</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收数据被调用</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message,Session session)</span>&#123;<br><br><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(Session session)</span>&#123;<br><br><br><br>    &#125;<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里需要注意，上面 session 指的是 websocket 的 session，不是 http 的 session，也是用来标识每一个长连接的对象，看到这里聪明的小伙伴应该能想到实现消息转发可以用 session 来标识每一个用户。</p><p>所以我们想要实现聊天消息转发可以使用 map 来存储 websocket 的 session。这里我存储 EndPoint 实例类似，因为我们可以使用 endpoint 实例来获取 session 对象，记住每一个用户进行一次 websocket 长连接，就会创建一个 endpoint 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>说到这里有小伙伴想问了，项目的一些数据存储在 HttpSession 中既然 websocket 是基于 http 的，那么我能不能取出 Httpsession 在 Endpoint 里使用啊？答案是可以的，只需要在 springboot 配置中在注入对象前 ServerEndpointConfig 放入这个 httpsession 就可以了</p><p>配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title function_">serverEndpointExporter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerEndpointExporter</span>();<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetHttpSessionConfigurator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServerEndpointConfig</span>.Configurator &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyHandshake</span><span class="hljs-params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession)request.getHttpSession();<br><br>        <span class="hljs-comment">//将httpsession存到配置对象</span><br><br>        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br></code></pre></td></tr></table></figure><p>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@OnOpen</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br>       <span class="hljs-built_in">this</span>.session = session;<br><br>       <span class="hljs-comment">//获取Httpssion</span><br><br>      <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession) config.getUserProperties().get(HttpSession.class.getName());<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="前端怎么写-WebSocket"><a href="#前端怎么写-WebSocket" class="headerlink" title="前端怎么写 WebSocket"></a>前端怎么写 WebSocket</h4><p>前端其实也类似，写起来更简单，只需要 new 一个 websocket 对象就能够实现连接。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">ws</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-comment">//连接</span><br>  <span class="hljs-title function_">connect</span>(<span class="hljs-params"></span>) &#123;<br>    ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:8081/api/chat&#x27;</span>);<br>  &#125;,<br><span class="hljs-comment">//获取实例</span><br>  <span class="hljs-title function_">getWs</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ws;<br>  &#125;,<br>  <span class="hljs-comment">//关闭连接，删除实例</span><br><br>  <span class="hljs-title function_">removeWs</span>(<span class="hljs-params"></span>) &#123;<br>    ws.<span class="hljs-title function_">close</span>();<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Typescript"><span class="hljs-comment">//调用方法</span><br>ws.<span class="hljs-title function_">connect</span>();<br><br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>  &#125;;<br><br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) &#123;<br>  &#125;<br>  ws.<span class="hljs-title function_">getWs</span>().<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>  &#125;;<br></code></pre></td></tr></table></figure><h4 id="聊天怎么实现"><a href="#聊天怎么实现" class="headerlink" title="聊天怎么实现"></a>聊天怎么实现</h4><p>思路</p><ol><li> 每一个客户端与服务端建立连接就将 EndPoint 实例存入 userHashMap（这里使用静态的）中。</li><li> 客户端断开连接，就将此用户从 userHashMap 去除，所以 userHashMap 始终存储在线用户</li><li> 客户端发消息，消息内容需要有发消息人，收消息人，内容，时间，封装成一个对象。</li><li> 服务端 onmessage 接收到就检查用户里 userHashMap 有没有此人（有表示在线），有就找到 session 直接转发给他，没有需要暂时存储到 chatsHashMap，存消息列表 。</li><li> 那么我们还要修改 1 步骤，这里连接上就要检查 chatsHashMap 有没有自己的消息，有就转发给自己并去除 chatsHashMap 的消息，这样一来就实现了离线和在线用户的聊天功能。</li></ol><p>后端全部代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatEndPoint</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  用来存储每个客户端对象对应的聊天记录 key 是uid value 是json</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, ArrayList&lt;String&gt;&gt; chats = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * websocket session</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span>  Session session;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * httpsession</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> HttpSession httpSession;<br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  建立连接被调</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, EndpointConfig config)</span>&#123;<br><br>        <span class="hljs-built_in">this</span>.session = session;<br><br>        <span class="hljs-comment">//获取Httpssion</span><br><br>       <span class="hljs-type">HttpSession</span> <span class="hljs-variable">httpSession</span> <span class="hljs-operator">=</span> (HttpSession) config.getUserProperties().get(HttpSession.class.getName());<br><br>       <span class="hljs-built_in">this</span>.httpSession = httpSession;<br><br><br>       <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>        <span class="hljs-comment">// 将当前对象存储在 容器中 key为uid</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> String.valueOf(user.getUid());<br><br>       users.put(uid,<span class="hljs-built_in">this</span>);<br><br>       <span class="hljs-comment">// 判断并建立 暂存 聊天记录的数据结构</span><br><br>       <span class="hljs-keyword">if</span>(!chats.containsKey(uid)) &#123;<br><br>           ArrayList&lt;String&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           System.out.println(uid+<span class="hljs-string">&quot;调用了一次&quot;</span>);<br>           chats.put(uid,arr);<br><br>       &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageUtils.getMessage(<span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, getUsers());<br><br>        System.out.println(message);<br>        <span class="hljs-comment">//连接就一条广播</span><br>        broadcastAllUsers(MessageUtils.getMessage(<span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;当前在线用户人数：&quot;</span>+users.size()+<span class="hljs-string">&quot;人&quot;</span>));<br>        broadcastAllUsers(message);<br><br>        <span class="hljs-comment">//获取该用户暂存离线消息并推送</span><br><br>        ArrayList&lt;String&gt; chatCache = chats.get(uid);<br><br><br>        <span class="hljs-keyword">for</span>(String chat:chatCache)&#123;<br><span class="hljs-comment">//            ChatEndPoint chatEndPoint = users.get(uid);</span><br><span class="hljs-comment">//            System.out.println(chat);</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.session.getBasicRemote().sendText(chat);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        chats.remove(uid);<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取容器里的用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; <span class="hljs-title function_">getUsers</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-keyword">return</span> ChatEndPoint.users.keySet();<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 推送所有客户端</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">broadcastAllUsers</span><span class="hljs-params">(String message)</span>&#123;<br><br>        Set&lt;String&gt; usersSet = users.keySet();<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                <span class="hljs-keyword">for</span> (String user : usersSet) &#123;<br>                    <span class="hljs-type">ChatEndPoint</span> <span class="hljs-variable">chatEndPoint</span> <span class="hljs-operator">=</span> users.get(user);<br>                    chatEndPoint.session.getBasicRemote().sendText(message);<br>                &#125;&#125; <span class="hljs-keyword">catch</span>(IOException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br><br><br>            &#125;<br><br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收数据被调用</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message,Session session)</span>&#123;<br><br><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">mess</span> <span class="hljs-operator">=</span> mapper.readValue(message, Message.class);<br><br><span class="hljs-comment">//            System.out.println(mess);</span><br><span class="hljs-comment">// 消息的接收者</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">toUid</span> <span class="hljs-operator">=</span> mess.getToUid();<br><br>            <span class="hljs-type">ChatEndPoint</span> <span class="hljs-variable">chatEndPoint</span> <span class="hljs-operator">=</span> users.get(toUid);<br><br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>            <span class="hljs-keyword">if</span>(chatEndPoint!=<span class="hljs-literal">null</span>)&#123;<br><br>                <span class="hljs-comment">// 接收用户在线直接转发</span><br><br><br><br>                <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)&#123;<br><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ErrorCode.LOGIN_ERROR);<br>                &#125;<br><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message1</span> <span class="hljs-operator">=</span> MessageUtils.getMessage(<span class="hljs-literal">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess);<br><br>                chatEndPoint.session.getBasicRemote().sendText(message1);<br><br><br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">//接收用户不在线 先暂时存储消息</span><br><br>                ArrayList&lt;String&gt; messages = chats.get(toUid);<br><br>                <span class="hljs-keyword">if</span>(messages == <span class="hljs-literal">null</span>)&#123;<br>                    messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    chats.put(toUid,messages);<br><br>                &#125;<br><br>                <span class="hljs-comment">//存的就是json</span><br>                messages.add(MessageUtils.getMessage(<span class="hljs-literal">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess));<br><br><br><br>            &#125;<br><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭连接调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(Session session)</span>&#123;<br><br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br>        users.remove(user.getUid().toString());<br><br>        System.out.println(user.getUserName()+<span class="hljs-string">&quot;下线了，当前在线人数：&quot;</span>+users.size()+<span class="hljs-string">&quot;人&quot;</span>);<br><br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前时间戳，秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getUnix</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br><br>        time = time / <span class="hljs-number">1000</span>;<br><br>        <span class="hljs-keyword">return</span> String.valueOf(time);<br><br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>前端接收怎么存储呢？我暂时只想到存储在 sessionStorage 或者 localStorage 中，但这部分数据存储需要考虑去重和数据对应每个用户，不要疏忽了让别的用户看到了不属于自己的对话内容，那就出大问题了。整体思路挺简单的就是要细心。</p><h4 id="实现展示"><a href="#实现展示" class="headerlink" title="实现展示"></a>实现展示</h4><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171042690.png" alt="image-20221125171042690"></p><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171211620.png" alt="image-20221125171211620"></p><p><img src="https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171244569.png" alt="image-20221125171244569"></p><p>组件采用的是 react-jwchat 感觉挺好看的，各项功能都正常，就是有时候会 websocket 连接了就断开了，猜测是没写 error 处理吧。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>最后看我的二手交易系统的前后端源码（websocket 源码也在里面）</p><p><a href="https://gitee.com/wx_504ae56474/react-jwchat">react-jwchat 聊天组件</a></p><p><a href="https://gitee.com/yilinyo/lkd-javee-trade-frontend">二手交易系统前端</a></p><p><a href="https://gitee.com/yilinyo/lkd-javaee-trade-backend">二手交易系统后端</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Git</title>
    <link href="/2023/02/06/hello-git/"/>
    <url>/2023/02/06/hello-git/</url>
    
    <content type="html"><![CDATA[<p>Git 入门笔记，带你快速使用 Git Bash 命令</p><h1 id="Git-入门"><a href="#Git-入门" class="headerlink" title="Git 入门"></a>Git 入门</h1><p>git 分布式版本控制</p><p>记录版本号 ，每个版本都有（高效的压缩解压算法）</p><h2 id="本地库"><a href="#本地库" class="headerlink" title="本地库"></a>本地库</h2><p>本地结构</p><pre><code class="hljs">1. 本地库1. 暂存区1. 工作区</code></pre><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>初始化本地库</p><h4 id="git-add-git-commit"><a href="#git-add-git-commit" class="headerlink" title="git add git commit"></a>git add <strong>git commit</strong></h4><p>工作区 -》<strong>git add</strong> 【】暂存区 -》<strong>git commit</strong> 【】 本地库</p><p>工作区 下（.git 同级）未 git add</p><p>缓存区 已经 git add 未 git commit</p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>查看工作状态</p><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>提交日志（由近到远）</p><p>每一条内容 有一个 key 索引唯一对应</p><p>不同展示样式：</p><h5 id="git-log-–pretty-oneline"><a href="#git-log-–pretty-oneline" class="headerlink" title="git log –pretty=oneline"></a>git log –pretty=oneline</h5><h5 id="git-log-–oneline"><a href="#git-log-–oneline" class="headerlink" title="git log –oneline"></a>git log –oneline</h5><h5 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h5><h4 id="git-reset-–【】索引"><a href="#git-reset-–【】索引" class="headerlink" title="git reset –【】索引"></a>git reset –【】索引</h4><p>1.使用 hard（使用最多）</p><p>​ 本地库的指针移动的同时 同步工作区、暂存区、本地库</p><p>2.使用 mixed</p><p>​ 本地库的指针移动的同时 同步暂存区、本地库</p><p>2.使用 soft</p><p>​ 只会让本地移动</p><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><p>比较工作区和暂存区的差异 （带文件比文件 ，不带比所有）</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>新建分支会先将主分支的最新版本然后加到分支</p><p><em>各自分支相互独立</em></p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><h5 id="git-branch-v"><a href="#git-branch-v" class="headerlink" title="git branch -v"></a>git branch -v</h5><p>​ 查看当前所有分支</p><h5 id="git-branch-【】"><a href="#git-branch-【】" class="headerlink" title="git branch 【】"></a>git branch 【】</h5><p>创建分支</p><h5 id="git-checkout-【】"><a href="#git-checkout-【】" class="headerlink" title="git checkout 【】"></a>git checkout 【】</h5><p>切换分支</p><p>主分支合并 其他分支</p><ol><li>切换到主分支</li><li>使用 git merge 【分支】（当主分支和其他分支 都修改了同一文件的同一位置就会冲突）</li><li>解决冲突方法：直接文件选择性删除 （再添加 提交）</li></ol><h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><p><strong>github</strong></p><p><strong>gitee</strong></p><p><strong>gitlab</strong></p><h4 id="git-remote-add-【name】【https-…-】"><a href="#git-remote-add-【name】【https-…-】" class="headerlink" title="git remote add 【name】【https://…..】"></a>git remote add 【name】【https://…..】</h4><p>本地库起远程库别名</p><h4 id="git-remote-v"><a href="#git-remote-v" class="headerlink" title="git remote -v"></a>git remote -v</h4><p>查看别名</p><p><strong>git push 【name】【分支】</strong></p><p>向远程仓库（别名）推送 本地仓库 的指定分支</p><p><strong>git clone 【https://…..】</strong></p><p>初始化本地库 从远程库克隆到本地 起了别名 origin</p><p><strong>库的拥有者拉取</strong></p><ol><li>fetch +merge 操作</li></ol><h5 id="git-fetch-【name】-【分支】"><a href="#git-fetch-【name】-【分支】" class="headerlink" title="git fetch 【name】 【分支】"></a>git fetch 【name】 【分支】</h5><p>从远程库抓取到本地库，工作区不变 这时候本地有个分支是 <strong>name/分支</strong></p><p>切换到本地 master 分支 调用 git merge name/分支 就可以合并</p><ol start="2"><li>pull 操作</li></ol><h5 id="git-pull【name】-【分支】"><a href="#git-pull【name】-【分支】" class="headerlink" title="git pull【name】 【分支】"></a>git pull【name】 【分支】</h5><p>冲突产生 需要到本地 解决再 push 到 远程仓库</p><h2 id="免密操作"><a href="#免密操作" class="headerlink" title="免密操作"></a>免密操作</h2><p>$ ssh-keygen -t rsa -C【email】</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>idea 远程 pull 前提准备</p><p>git pull origin master –allow-unrelated-histories</p><p>推送到上游其它分支</p><p>git push –set-upstream origin myblog（分支）</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伙伴匹配系统收获</title>
    <link href="/2023/02/05/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E6%94%B6%E8%8E%B7/"/>
    <url>/2023/02/05/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="伙伴匹配系统收获"><a href="#伙伴匹配系统收获" class="headerlink" title="伙伴匹配系统收获"></a>伙伴匹配系统收获</h1><p>伙伴匹配系统前前后后花了40+小时，最后完成了这个基于Vue、Vant、Vite 以及SpringBoot的移动端 项目，有了用户中心的 基础架构，这个系统主要围绕功能如用户组队匹配以及性能优化进行开发，由于是轻量前端框架，开发上手较为容易。</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>本次项目 的 Swagger + Knife4j 接口文档的 引入 极大的提高了之前前后端联调的效率，可以自动根据Controller上的handler 方法的参数 生成对应的 前端数据格式。这个在日常开发还是很常用的.</p><p>在登录优化时引入了分布式Session, 以前的登录的Session 我们 是直接存在一台机器的服务上，但单个SpringBoot session 应用只能应用本服务。如果我们将项目拆分成微服务 或 集群部署，Session的状态就无法共享,引入spring-session-data-redis 就能够轻松的将Session 信息在redis维护，实现了分布式Session。</p><p>Redis 基于内存的 nosql 数据库 的引入让我体验到其性能的强大，除了这种分布式Session的应用，它还能广泛的应用于数据缓存，在此系统的用户表我插入了大量的模拟用户，导致查询性能大大下降，后端响应到前端的时间大概要花10来秒。这样一来用户的体验感会大大下降。利用redis 的 基于内存的存储 成功的将 第二次访问的 速度降低到了毫秒级别。</p><p>好像计算机的世界里 无论遇到什么问题加一层 缓存总能解决问题。然而引入 一个新的东西总会带来新的问题。从业务层面来说就是 我们需要维护 数据库和缓存的数据一致，但既然存在缓存我们就不可避免 两者的数据 会出现不一致，要做的就是将这种情况带来损失降低，比如设置合适的过期时间，既能带给用户良好的体验也不至于数据长时间不更新。其次就是就是只对变化不明显的数据使用缓存，这样用户感知体验会很少。从性能层面来说就是redis利用了内存，我们不能长时间占有，所以缓存的数据量一定要合适，而且一定要设置过期时间，一旦内存爆了，不然不但提升不了性能还会降低性能，同时redis 自我淘汰机制还会将重要数据淘汰掉。</p><p>还有一个细节就是使用了缓存可是我们每次第一次访问还是比较慢，这里想要第一次也读的是缓存数据就需要缓存预热，缓存预热可以是定时任务也可以是触发某个事件。然后这里引出了基于Redisson的分布式锁(感觉这里有点为了用这个技术而用了🙄) 解决分布式环境下多个应用服务只想执行一次 缓存预热的定时任务。有点类似线程里的lock锁，设置然后抢锁然后执行预热然后释放锁.多线程和分布式其实就好像一个微观下一个宏观下的竞争对手，都是为了抢夺资源，只不过前者是为了抢夺计算机资源，后者是为了提供用户的服务的资源。这里Redisson的Rlock还实现了看门狗机制，就是如果一个服务抢到锁后 在执行分布式锁住的内容时 如果过了设置最大时间还没完就会自动续期一段时间。</p><p>这个项目运用到的Redis 客户端有spring-boot-starter-data-redis、Redisson 后者比较高级支持线程安全同步。Rlock就是里面的。前者是SpringBoot推荐的。而且默认使用了jdk的序列化方法，就是最后到redis里都是一堆乱码其实是序列化号的，我们可以定制其的序列化方式增强可读性或者效率,只需要定制化配置redisTemplate的bean。</p><p>然后值得一提的就是数据库表的建立以前都是一堆数据放在一张表，查起来确实爽但是极大的浪费了性能，大量的数据冗余。维护一张关系表虽然操作起来麻烦但还是能减少IO，记得使用事物注解就行了。这次开发又熟悉了下mybatis plus。它确实强大。记得自己写的sql语句没有自动添加逻辑删除的条件。</p><p>最最最大收获就是这次的业务逻辑了，这次真的是经历了业务的完整流程，首先一定要想好需求分析再想好怎么实现，整个项目最多的地方就是在鉴权，因为队伍的创建者以及队伍的状态是有区别的。我们需要层层的判断是否有权限进行操作不然就会出现问题，有些鉴权可以直接判断，而有一些鉴权需要查数据库比如一个人最多加入5个队伍，我们要尽量让那些不要查数据库的鉴权在前面检查以减少数据库的访问。在开发过程尽量不要直接传递数据库的查询对象，多封装dto，vo来隔离原始数据，保证数据安全和数据格式统一。必要的时候对于相同的也逻辑要整体抽离。</p><p>算法这一块用的是dp实现的最小编辑距离方法，感觉这个算法还是有局限性的，可以实现更好的匹配或者推荐算法，后续有机会我再试一试。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端这次用的3V三剑客，总体来说比较轻量，这次基本学会了其使用方法，这次🐟带我们实现了之前用户中心他们实现的一些功能，比如如和自己封装axios 全局拦截器，比如自己实现用户缓存，比如vue router跳转等等，了解到了Vue开发项目的结构，比如设置模板设置组件设置路由页面，其实这个项目就是一个单页面项目，Vue-router确实方便。总体上Vue3和React还是很像的，甚至更简单，v-if，v-for太好用了，ref响应式变量也很好好用，就是要注意Vue的生命周期，这些在后面再后面细细学习把</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这个项目还可以构建小程序等等，由于赶着总结项目找实习先不弄了，这次项目后端知识点很零碎但还是不算太难，然后就是lambda表达式操作集合类是真的很爽！！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鱼皮用户中心收获</title>
    <link href="/2023/02/05/%E9%B1%BC%E7%9A%AE%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E6%94%B6%E8%8E%B7/"/>
    <url>/2023/02/05/%E9%B1%BC%E7%9A%AE%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="鱼皮用户中心收获"><a href="#鱼皮用户中心收获" class="headerlink" title="鱼皮用户中心收获"></a>鱼皮用户中心收获</h1><p>用户中心花了大概30+小时 看了🐟所有视频</p><p>借鉴了部分同学的 笔记 ，虽然这种项目以前也做过，很多东西之前也体验过，但还是一步一步地 跟着来了一边完整的，收获确实很多。同时这个过程还额外自己补了很多细节基础。</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>首先最大的收获应该 不是代码层面的 因为业务很简单就是普通的对用户表的crud，而应该是整个 后端Java 的开发流程和规范 ，比如一些工具类，请求类，错误类的封装，这里尤其有收获的是 business错误类的引入 和  GlobelExceptionHandel 引入来处理错误信息 来像前端提供规范以及安全接口数据。其次就是 一些逻辑上的细节，还有一些敏捷开发的插件。整个后端 构建的流程和过程是很有意义的。</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>然后就是前端方面的一些，这里之前只有简单三件套的基础，虽然能听懂，但还是促使我去稍微入门学习了 一下Vue、React 还有TS ，框架上手很简单但不熟练，所以看ant design pro 和 umi我看了好几遍，勉强能简单应用，在前端视频中 我觉得比较重要的收获是 前端这些主流框架的 项目结构 ，无论是Vue react还是umi 其实都差不多，所以听一遍理解其它很快捷，然后就是ts的细节了，ts确实对java程序员很友好，学了ts的一些语法理解ant design pro 非常的便捷，然后在前端的细节其实有很多，比如api的封装以及组件库的复用、路由的利用、生产模式对proxy代理的利用、以及异步axios请求（umi里的REQUEST）请求拦截器、响应拦截器、基础配置等等。总而言之，前端总是很细。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>哦，有一点就是登录保持登陆状态这个以前没系统学，利用这个antdesign 的框架大概熟悉了 整个流程 和 如何实现前后端 ，之前笔记有提到。</p><h3 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h3><p>多环境指的是在前端和后端要配置 多种环境的数据 （数据库、消息队列、redis、端口）在启动时可供选择</p><h3 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a>部署上线</h3><p>然后就是部署上线</p><p>这里 基础的几个方式我就不讲了，主要收获应该是Docker容器部署吧，因为很早就想学了但是一直没机会.Docker 其实就是 服务器里的清新小服务器（有自己的端口、目录啥） ，在里面下环境只需要几行代码 ，然后我们利用镜像来打包 代码和环境，这样形成一个又一个的小软件就能够 通过Docker 来运行，方便快捷且独立。</p><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>然后是跨域问题</p><p>之前解决过跨域问题，但没有带cookie这次带了cookie 由于做nginx之前没看鱼皮视频 自己搞了半天 踩了好多坑，这里的收获就是前端携带 cookie 就必须要在后端设置 返回头要带上 几个重要的头，尤其是cookie要设置path和当前请求url保持一致 ，这样setcookie才会生效。这里Nginx反向代理需要配置正常</p><p>然后还有不使用反向代理，直接后端也有几种解决方法。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>然后我也自己拓展了一些接口比如查询等等</p><p>这个项目应该会成为后面项目用户的数据中心吧，可以更单多的拓展。</p><p>最后也希望以后写自己项目时时刻要提醒自己这些规范，以后要多回来看看，感谢鱼皮。</p>]]></content>
    
    
    
    <tags>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
