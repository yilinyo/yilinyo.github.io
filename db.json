{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/backend.png","path":"img/backend.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/touxiang.png","path":"img/touxiang.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/wechatQR.png","path":"img/wechatQR.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/duration.js","path":"js/duration.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Docker 入门指南.md","hash":"98118fe39d00b1b8d3185852b17943c1cab6160d","modified":1706453300012},{"_id":"source/_posts/WebSocket 实现聊天室.md","hash":"8a65efc89c5be2c98d3ed7e0c829b7408d567fda","modified":1706453300016},{"_id":"source/_posts/Nginx 入门 server块 书写之 location 规则 （一）.md","hash":"9767b666533537c35db7dcf80faca3732e35d639","modified":1706453300013},{"_id":"source/_posts/Nginx 入门 server块 书写之 location 规则 （二）.md","hash":"8ec3304666c285d00cb42adeee1ebf13e9c0d3e2","modified":1706453300014},{"_id":"source/_posts/伙伴匹配系统收获.md","hash":"35be80087e84a8f7404902ddbf4dc87996fe2c42","modified":1706453300017},{"_id":"source/_posts/hello-git.md","hash":"057f28db6c9e5f722d25afc8ef6039d2b789cc4a","modified":1706453300017},{"_id":"source/_posts/鱼皮用户中心收获.md","hash":"f2a946f2c15be342c29d93cb2dc6435ead9a2a34","modified":1706453300019},{"_id":"source/_posts/记一次比赛开发心得.md","hash":"dcd713dc5a8d0f171051cdeb4e16e546bb32af6b","modified":1706453300018},{"_id":"source/_posts/NIO入门.md","hash":"b00b6d588f60c57cd7961079cbf2e769355362e1","modified":1706463614492},{"_id":"source/about/index.md","hash":"e56c642f4e40a8909c9031cfc65dae6a8ffa6635","modified":1669463386174},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1702719015000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1702719015000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1702719015000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1702719015000},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1702719015000},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1702719015000},{"_id":"themes/fluid/package.json","hash":"c640b57695b7b6002399711f1a7708b0f6c05b84","modified":1702719015000},{"_id":"themes/fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1702719015000},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1702719015000},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1702719015000},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1702719015000},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1702719015000},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1702719015000},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1702719015000},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1702719015000},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1702719015000},{"_id":"themes/fluid/README_en.md","hash":"365184a73af40e7365504c3077f3d80dfee1d80e","modified":1702719015000},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1702719015000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"a2f58121fb81d17b1b130bbcd78158548c122331","modified":1706469736202},{"_id":"themes/fluid/_config.yml","hash":"759d78d97cfe364a4bcf0b5cd2d3505967674276","modified":1702719015000},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1702719015000},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1702719015000},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1702719015000},{"_id":"themes/fluid/layout/layout.ejs","hash":"bd53be84511b8742c8b102dd0ad896449bd77c4f","modified":1706466146515},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1702719015000},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1702719015000},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1702719015000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"554c0d0e086a0784d83ee71c83f8bceeb60aecc8","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"c8b0d49c49e3c88872fd3b37909345ff5b2b6aa0","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"fff07ce0472afc368d388637cb9d438195da9b5b","modified":1702719015000},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1702719015000},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"6f02e6440d88629229556e3fd47d0280fe2240db","modified":1702719015000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1702719015000},{"_id":"themes/fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1702719015000},{"_id":"themes/fluid/layout/post.ejs","hash":"b49ea8e6fb1c7e1320cdfd08587e7459b4e93c31","modified":1706468954548},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1702719015000},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1702719015000},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1702719015000},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"19a8a00f5ba9607d82265572fe1202b64a8b0822","modified":1702719015000},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1702719015000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1702719015000},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1702719015000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1702719015000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"0857aa86db2a711ae5c77218a9e3fa686d0e87b1","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1702719015000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1702719015000},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1702719015000},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1702719015000},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1702719015000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1702719015000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1702719015000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1702719015000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1702719015000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1702719015000},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1702719015000},{"_id":"themes/fluid/source/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1702719015000},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1702719015000},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1702719015000},{"_id":"themes/fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1702719015000},{"_id":"themes/fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1702719015000},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1702719015000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1702719015000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1702719015000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"cd432a6411ccac7df47e6a300fb1a872cfc763e7","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1702719015000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1702719015000},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1702719015000},{"_id":"themes/fluid/source/img/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1663049159000},{"_id":"themes/fluid/source/img copy/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1702719015000},{"_id":"themes/fluid/source/img copy/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1702719015000},{"_id":"themes/fluid/source/img copy/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1702719015000},{"_id":"themes/fluid/source/img copy/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1702719015000},{"_id":"themes/fluid/source/img copy/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1702719015000},{"_id":"themes/fluid/source/img/wechatQR.png","hash":"cb75bd131daa32307c9929acfeb9ec1344afe21e","modified":1669461640770},{"_id":"themes/fluid/source/img/touxiang.png","hash":"4d0625bb6282c4068d51c618be74276c48bc885d","modified":1666803218535},{"_id":"themes/fluid/source/img/backend.png","hash":"f5b4ccc1e38053a7c74536e13bf0d34eeaa3b97a","modified":1666804123439},{"_id":"themes/fluid/source/js/duration.js","hash":"d026b571c4e3ff9856247a8a69b7464dbc213a36","modified":1706467367767}],"Category":[],"Data":[],"Page":[{"title":"Hello Hexo","layout":"about","date":"2022-10-26T15:12:48.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: Hello Hexo\nlayout: about\ndate: 2022-10-26 23:12:48\n---\n","updated":"2022-11-26T11:49:46.174Z","path":"about/index.html","comments":1,"_id":"clrxrizsj0000b4tndw405dyx","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Docker 入门指南","date":"2023-06-27T07:34:00.000Z","_content":"\n\n# Docker 入门指南\n（本文部分由ChatGpt完成--）\n欢迎来到Docker入门指南！本文将介绍Docker的基本概念、常用命令和使用方法，帮助你快速上手使用Docker容器化应用程序。\n\n## 什么是Docker？\n\nDocker是一个开源的容器化平台，可以将应用程序及其依赖打包成一个独立的容器，使其可以在任何环境中以相同的方式运行。每个Docker容器都是一个轻量级的、可移植的执行单元，具有自己的文件系统、网络和进程空间，与宿主机隔离。\n\n使用Docker，你可以快速构建、分发和运行应用程序，无需担心运行环境的差异和依赖问题。它提供了一种可靠、可重复、可扩展和安全的方式来打包应用程序。\n\n## Docker 常用命令\n\n以下是一些常用的Docker命令，让我们快速了解它们：\n\n- `docker run <image>`：从镜像创建一个新容器并启动。\n- `docker stop <container>`：停止一个运行中的容器。\n- `docker start <container>`：启动一个已停止的容器。\n- `docker restart <container>`：重启一个容器。\n- `docker rm <container>`：删除一个停止的容器。\n- `docker ps`：列出当前正在运行的容器。\n- `docker images`：列出本地存在的镜像。\n- `docker pull <image>`：从仓库下载一个镜像。\n- `docker push <image>`：将一个镜像推送到仓库。\n\n这只是一小部分常用命令，你可以使用`docker --help`命令或查阅Docker文档了解更多命令和选项。\n\n## 使用 Docker\n\n下面是使用Docker的基本步骤：\n\n1. 安装 Docker：根据你的操作系统选择合适的Docker安装包并进行安装。\n\n2. 获取镜像：从Docker Hub或其他镜像仓库中获取一个镜像，例如：\n\n   ```\n   docker pull ubuntu:latest\n   ```\n\n3. 运行容器：使用`docker run`命令从镜像创建并运行一个容器，例如：\n\n   ```\n   docker run -it ubuntu:latest /bin/bash\n   ```\n\n   这将创建一个以Ubuntu镜像为基础的容器，并进入容器的终端。\n\n4. 在容器中操作：在容器终端中进行你想要的操作，例如安装软件、配置环境、运行应用程序等。你可以像在正常的操作系统中一样使用命令行工具和编辑器进行操作。\n\n5. 保存容器状态：如果在容器中做出了更改，你可以选择将容器的状态保存为一个新的镜像，以便日后重用。首先退出容器终端，然后使用以下命令保存容器状态：\n\n   ```\n   docker commit <container> <image_name>\n   ```\n\n   这将创建一个新的镜像，其中包含容器的更改。\n\n6. 管理容器：使用`docker start`、`docker stop`、`docker restart`和`docker rm`等命令来管理容器的生命周期。你可以根据需要启动、停止、重启和删除容器。\n\n   \n\n## Docker Run的其它方法\n当使用`docker run`命令创建和运行容器时，除了镜像名称之外，还可以使用一些其他重要的参数来配置容器的行为和环境。下面是一些常用的`docker run`参数：\n\n- `-d`：在后台以守护进程模式运行容器。\n- `--name <container_name>`：为容器指定一个名称。\n- `-p <host_port>:<container_port>`：将容器的端口映射到主机的指定端口。\n- `-v <host_path>:<container_path>`：将主机的目录或文件挂载到容器中。\n- `-e <variable=value>`：设置环境变量。\n- `--network <network_name>`：指定容器所使用的网络。\n- `--restart <restart_policy>`：设置容器退出后的重启策略。\n- `--volume-driver <driver>`：指定要使用的卷驱动程序。\n\n这些参数可以根据你的需求进行组合和使用。下面是一个使用`docker run`的示例，演示了一些常用参数的用法：\n\n```\ndocker run -d --name my_container -p 8080:80 -v /path/on/host:/path/in/container -e ENV_VAR=value --network my_network --restart always my_image:latest\n```\n\n上述示例中，我们以守护进程模式运行名为`my_container`的容器，将主机的端口8080映射到容器的端口80，挂载主机上的`/path/on/host`目录到容器的`/path/in/container`路径，设置了一个名为`ENV_VAR`的环境变量，将容器连接到名为`my_network`的网络，并设置容器退出后始终重启。\n\n\n\n这只是一个简单的Docker入门指南，帮助你了解Docker的基本概念和使用方法。Docker拥有强大的功能和丰富的生态系统，你可以进一步探索Docker的高级特性和用法。\n","source":"_posts/Docker 入门指南.md","raw":"\n---\ntitle: Docker 入门指南\ntag: Docker\ndate: 2023-6-27 15:34:00\n---\n\n\n# Docker 入门指南\n（本文部分由ChatGpt完成--）\n欢迎来到Docker入门指南！本文将介绍Docker的基本概念、常用命令和使用方法，帮助你快速上手使用Docker容器化应用程序。\n\n## 什么是Docker？\n\nDocker是一个开源的容器化平台，可以将应用程序及其依赖打包成一个独立的容器，使其可以在任何环境中以相同的方式运行。每个Docker容器都是一个轻量级的、可移植的执行单元，具有自己的文件系统、网络和进程空间，与宿主机隔离。\n\n使用Docker，你可以快速构建、分发和运行应用程序，无需担心运行环境的差异和依赖问题。它提供了一种可靠、可重复、可扩展和安全的方式来打包应用程序。\n\n## Docker 常用命令\n\n以下是一些常用的Docker命令，让我们快速了解它们：\n\n- `docker run <image>`：从镜像创建一个新容器并启动。\n- `docker stop <container>`：停止一个运行中的容器。\n- `docker start <container>`：启动一个已停止的容器。\n- `docker restart <container>`：重启一个容器。\n- `docker rm <container>`：删除一个停止的容器。\n- `docker ps`：列出当前正在运行的容器。\n- `docker images`：列出本地存在的镜像。\n- `docker pull <image>`：从仓库下载一个镜像。\n- `docker push <image>`：将一个镜像推送到仓库。\n\n这只是一小部分常用命令，你可以使用`docker --help`命令或查阅Docker文档了解更多命令和选项。\n\n## 使用 Docker\n\n下面是使用Docker的基本步骤：\n\n1. 安装 Docker：根据你的操作系统选择合适的Docker安装包并进行安装。\n\n2. 获取镜像：从Docker Hub或其他镜像仓库中获取一个镜像，例如：\n\n   ```\n   docker pull ubuntu:latest\n   ```\n\n3. 运行容器：使用`docker run`命令从镜像创建并运行一个容器，例如：\n\n   ```\n   docker run -it ubuntu:latest /bin/bash\n   ```\n\n   这将创建一个以Ubuntu镜像为基础的容器，并进入容器的终端。\n\n4. 在容器中操作：在容器终端中进行你想要的操作，例如安装软件、配置环境、运行应用程序等。你可以像在正常的操作系统中一样使用命令行工具和编辑器进行操作。\n\n5. 保存容器状态：如果在容器中做出了更改，你可以选择将容器的状态保存为一个新的镜像，以便日后重用。首先退出容器终端，然后使用以下命令保存容器状态：\n\n   ```\n   docker commit <container> <image_name>\n   ```\n\n   这将创建一个新的镜像，其中包含容器的更改。\n\n6. 管理容器：使用`docker start`、`docker stop`、`docker restart`和`docker rm`等命令来管理容器的生命周期。你可以根据需要启动、停止、重启和删除容器。\n\n   \n\n## Docker Run的其它方法\n当使用`docker run`命令创建和运行容器时，除了镜像名称之外，还可以使用一些其他重要的参数来配置容器的行为和环境。下面是一些常用的`docker run`参数：\n\n- `-d`：在后台以守护进程模式运行容器。\n- `--name <container_name>`：为容器指定一个名称。\n- `-p <host_port>:<container_port>`：将容器的端口映射到主机的指定端口。\n- `-v <host_path>:<container_path>`：将主机的目录或文件挂载到容器中。\n- `-e <variable=value>`：设置环境变量。\n- `--network <network_name>`：指定容器所使用的网络。\n- `--restart <restart_policy>`：设置容器退出后的重启策略。\n- `--volume-driver <driver>`：指定要使用的卷驱动程序。\n\n这些参数可以根据你的需求进行组合和使用。下面是一个使用`docker run`的示例，演示了一些常用参数的用法：\n\n```\ndocker run -d --name my_container -p 8080:80 -v /path/on/host:/path/in/container -e ENV_VAR=value --network my_network --restart always my_image:latest\n```\n\n上述示例中，我们以守护进程模式运行名为`my_container`的容器，将主机的端口8080映射到容器的端口80，挂载主机上的`/path/on/host`目录到容器的`/path/in/container`路径，设置了一个名为`ENV_VAR`的环境变量，将容器连接到名为`my_network`的网络，并设置容器退出后始终重启。\n\n\n\n这只是一个简单的Docker入门指南，帮助你了解Docker的基本概念和使用方法。Docker拥有强大的功能和丰富的生态系统，你可以进一步探索Docker的高级特性和用法。\n","slug":"Docker 入门指南","published":1,"updated":"2024-01-28T14:48:20.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrxrizsq0001b4tn6uhk2150","content":"<h1 id=\"Docker-入门指南\"><a href=\"#Docker-入门指南\" class=\"headerlink\" title=\"Docker 入门指南\"></a>Docker 入门指南</h1><p>（本文部分由ChatGpt完成–）<br>欢迎来到Docker入门指南！本文将介绍Docker的基本概念、常用命令和使用方法，帮助你快速上手使用Docker容器化应用程序。</p>\n<h2 id=\"什么是Docker？\"><a href=\"#什么是Docker？\" class=\"headerlink\" title=\"什么是Docker？\"></a>什么是Docker？</h2><p>Docker是一个开源的容器化平台，可以将应用程序及其依赖打包成一个独立的容器，使其可以在任何环境中以相同的方式运行。每个Docker容器都是一个轻量级的、可移植的执行单元，具有自己的文件系统、网络和进程空间，与宿主机隔离。</p>\n<p>使用Docker，你可以快速构建、分发和运行应用程序，无需担心运行环境的差异和依赖问题。它提供了一种可靠、可重复、可扩展和安全的方式来打包应用程序。</p>\n<h2 id=\"Docker-常用命令\"><a href=\"#Docker-常用命令\" class=\"headerlink\" title=\"Docker 常用命令\"></a>Docker 常用命令</h2><p>以下是一些常用的Docker命令，让我们快速了解它们：</p>\n<ul>\n<li><code>docker run &lt;image&gt;</code>：从镜像创建一个新容器并启动。</li>\n<li><code>docker stop &lt;container&gt;</code>：停止一个运行中的容器。</li>\n<li><code>docker start &lt;container&gt;</code>：启动一个已停止的容器。</li>\n<li><code>docker restart &lt;container&gt;</code>：重启一个容器。</li>\n<li><code>docker rm &lt;container&gt;</code>：删除一个停止的容器。</li>\n<li><code>docker ps</code>：列出当前正在运行的容器。</li>\n<li><code>docker images</code>：列出本地存在的镜像。</li>\n<li><code>docker pull &lt;image&gt;</code>：从仓库下载一个镜像。</li>\n<li><code>docker push &lt;image&gt;</code>：将一个镜像推送到仓库。</li>\n</ul>\n<p>这只是一小部分常用命令，你可以使用<code>docker --help</code>命令或查阅Docker文档了解更多命令和选项。</p>\n<h2 id=\"使用-Docker\"><a href=\"#使用-Docker\" class=\"headerlink\" title=\"使用 Docker\"></a>使用 Docker</h2><p>下面是使用Docker的基本步骤：</p>\n<ol>\n<li><p>安装 Docker：根据你的操作系统选择合适的Docker安装包并进行安装。</p>\n</li>\n<li><p>获取镜像：从Docker Hub或其他镜像仓库中获取一个镜像，例如：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">docker</span> pull ubuntu:latest<br></code></pre></td></tr></table></figure></li>\n<li><p>运行容器：使用<code>docker run</code>命令从镜像创建并运行一个容器，例如：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">docker <span class=\"hljs-built_in\">run</span> -<span class=\"hljs-keyword\">it</span> ubuntu:latest /bin/bash<br></code></pre></td></tr></table></figure>\n\n<p>这将创建一个以Ubuntu镜像为基础的容器，并进入容器的终端。</p>\n</li>\n<li><p>在容器中操作：在容器终端中进行你想要的操作，例如安装软件、配置环境、运行应用程序等。你可以像在正常的操作系统中一样使用命令行工具和编辑器进行操作。</p>\n</li>\n<li><p>保存容器状态：如果在容器中做出了更改，你可以选择将容器的状态保存为一个新的镜像，以便日后重用。首先退出容器终端，然后使用以下命令保存容器状态：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">docker commit <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">container</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image_name</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这将创建一个新的镜像，其中包含容器的更改。</p>\n</li>\n<li><p>管理容器：使用<code>docker start</code>、<code>docker stop</code>、<code>docker restart</code>和<code>docker rm</code>等命令来管理容器的生命周期。你可以根据需要启动、停止、重启和删除容器。</p>\n</li>\n</ol>\n<h2 id=\"Docker-Run的其它方法\"><a href=\"#Docker-Run的其它方法\" class=\"headerlink\" title=\"Docker Run的其它方法\"></a>Docker Run的其它方法</h2><p>当使用<code>docker run</code>命令创建和运行容器时，除了镜像名称之外，还可以使用一些其他重要的参数来配置容器的行为和环境。下面是一些常用的<code>docker run</code>参数：</p>\n<ul>\n<li><code>-d</code>：在后台以守护进程模式运行容器。</li>\n<li><code>--name &lt;container_name&gt;</code>：为容器指定一个名称。</li>\n<li><code>-p &lt;host_port&gt;:&lt;container_port&gt;</code>：将容器的端口映射到主机的指定端口。</li>\n<li><code>-v &lt;host_path&gt;:&lt;container_path&gt;</code>：将主机的目录或文件挂载到容器中。</li>\n<li><code>-e &lt;variable=value&gt;</code>：设置环境变量。</li>\n<li><code>--network &lt;network_name&gt;</code>：指定容器所使用的网络。</li>\n<li><code>--restart &lt;restart_policy&gt;</code>：设置容器退出后的重启策略。</li>\n<li><code>--volume-driver &lt;driver&gt;</code>：指定要使用的卷驱动程序。</li>\n</ul>\n<p>这些参数可以根据你的需求进行组合和使用。下面是一个使用<code>docker run</code>的示例，演示了一些常用参数的用法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">docker run -d --name my_container -p <span class=\"hljs-number\">8080</span>:<span class=\"hljs-number\">80</span> -v <span class=\"hljs-regexp\">/path/</span>on<span class=\"hljs-regexp\">/host:/</span>path<span class=\"hljs-regexp\">/in/</span>container -e ENV_VAR=value --network my_network --restart always my_image:latest<br></code></pre></td></tr></table></figure>\n\n<p>上述示例中，我们以守护进程模式运行名为<code>my_container</code>的容器，将主机的端口8080映射到容器的端口80，挂载主机上的<code>/path/on/host</code>目录到容器的<code>/path/in/container</code>路径，设置了一个名为<code>ENV_VAR</code>的环境变量，将容器连接到名为<code>my_network</code>的网络，并设置容器退出后始终重启。</p>\n<p>这只是一个简单的Docker入门指南，帮助你了解Docker的基本概念和使用方法。Docker拥有强大的功能和丰富的生态系统，你可以进一步探索Docker的高级特性和用法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Docker-入门指南\"><a href=\"#Docker-入门指南\" class=\"headerlink\" title=\"Docker 入门指南\"></a>Docker 入门指南</h1><p>（本文部分由ChatGpt完成–）<br>欢迎来到Docker入门指南！本文将介绍Docker的基本概念、常用命令和使用方法，帮助你快速上手使用Docker容器化应用程序。</p>\n<h2 id=\"什么是Docker？\"><a href=\"#什么是Docker？\" class=\"headerlink\" title=\"什么是Docker？\"></a>什么是Docker？</h2><p>Docker是一个开源的容器化平台，可以将应用程序及其依赖打包成一个独立的容器，使其可以在任何环境中以相同的方式运行。每个Docker容器都是一个轻量级的、可移植的执行单元，具有自己的文件系统、网络和进程空间，与宿主机隔离。</p>\n<p>使用Docker，你可以快速构建、分发和运行应用程序，无需担心运行环境的差异和依赖问题。它提供了一种可靠、可重复、可扩展和安全的方式来打包应用程序。</p>\n<h2 id=\"Docker-常用命令\"><a href=\"#Docker-常用命令\" class=\"headerlink\" title=\"Docker 常用命令\"></a>Docker 常用命令</h2><p>以下是一些常用的Docker命令，让我们快速了解它们：</p>\n<ul>\n<li><code>docker run &lt;image&gt;</code>：从镜像创建一个新容器并启动。</li>\n<li><code>docker stop &lt;container&gt;</code>：停止一个运行中的容器。</li>\n<li><code>docker start &lt;container&gt;</code>：启动一个已停止的容器。</li>\n<li><code>docker restart &lt;container&gt;</code>：重启一个容器。</li>\n<li><code>docker rm &lt;container&gt;</code>：删除一个停止的容器。</li>\n<li><code>docker ps</code>：列出当前正在运行的容器。</li>\n<li><code>docker images</code>：列出本地存在的镜像。</li>\n<li><code>docker pull &lt;image&gt;</code>：从仓库下载一个镜像。</li>\n<li><code>docker push &lt;image&gt;</code>：将一个镜像推送到仓库。</li>\n</ul>\n<p>这只是一小部分常用命令，你可以使用<code>docker --help</code>命令或查阅Docker文档了解更多命令和选项。</p>\n<h2 id=\"使用-Docker\"><a href=\"#使用-Docker\" class=\"headerlink\" title=\"使用 Docker\"></a>使用 Docker</h2><p>下面是使用Docker的基本步骤：</p>\n<ol>\n<li><p>安装 Docker：根据你的操作系统选择合适的Docker安装包并进行安装。</p>\n</li>\n<li><p>获取镜像：从Docker Hub或其他镜像仓库中获取一个镜像，例如：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">docker</span> pull ubuntu:latest<br></code></pre></td></tr></table></figure></li>\n<li><p>运行容器：使用<code>docker run</code>命令从镜像创建并运行一个容器，例如：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">docker <span class=\"hljs-built_in\">run</span> -<span class=\"hljs-keyword\">it</span> ubuntu:latest /bin/bash<br></code></pre></td></tr></table></figure>\n\n<p>这将创建一个以Ubuntu镜像为基础的容器，并进入容器的终端。</p>\n</li>\n<li><p>在容器中操作：在容器终端中进行你想要的操作，例如安装软件、配置环境、运行应用程序等。你可以像在正常的操作系统中一样使用命令行工具和编辑器进行操作。</p>\n</li>\n<li><p>保存容器状态：如果在容器中做出了更改，你可以选择将容器的状态保存为一个新的镜像，以便日后重用。首先退出容器终端，然后使用以下命令保存容器状态：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">docker commit <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">container</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image_name</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这将创建一个新的镜像，其中包含容器的更改。</p>\n</li>\n<li><p>管理容器：使用<code>docker start</code>、<code>docker stop</code>、<code>docker restart</code>和<code>docker rm</code>等命令来管理容器的生命周期。你可以根据需要启动、停止、重启和删除容器。</p>\n</li>\n</ol>\n<h2 id=\"Docker-Run的其它方法\"><a href=\"#Docker-Run的其它方法\" class=\"headerlink\" title=\"Docker Run的其它方法\"></a>Docker Run的其它方法</h2><p>当使用<code>docker run</code>命令创建和运行容器时，除了镜像名称之外，还可以使用一些其他重要的参数来配置容器的行为和环境。下面是一些常用的<code>docker run</code>参数：</p>\n<ul>\n<li><code>-d</code>：在后台以守护进程模式运行容器。</li>\n<li><code>--name &lt;container_name&gt;</code>：为容器指定一个名称。</li>\n<li><code>-p &lt;host_port&gt;:&lt;container_port&gt;</code>：将容器的端口映射到主机的指定端口。</li>\n<li><code>-v &lt;host_path&gt;:&lt;container_path&gt;</code>：将主机的目录或文件挂载到容器中。</li>\n<li><code>-e &lt;variable=value&gt;</code>：设置环境变量。</li>\n<li><code>--network &lt;network_name&gt;</code>：指定容器所使用的网络。</li>\n<li><code>--restart &lt;restart_policy&gt;</code>：设置容器退出后的重启策略。</li>\n<li><code>--volume-driver &lt;driver&gt;</code>：指定要使用的卷驱动程序。</li>\n</ul>\n<p>这些参数可以根据你的需求进行组合和使用。下面是一个使用<code>docker run</code>的示例，演示了一些常用参数的用法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">docker run -d --name my_container -p <span class=\"hljs-number\">8080</span>:<span class=\"hljs-number\">80</span> -v <span class=\"hljs-regexp\">/path/</span>on<span class=\"hljs-regexp\">/host:/</span>path<span class=\"hljs-regexp\">/in/</span>container -e ENV_VAR=value --network my_network --restart always my_image:latest<br></code></pre></td></tr></table></figure>\n\n<p>上述示例中，我们以守护进程模式运行名为<code>my_container</code>的容器，将主机的端口8080映射到容器的端口80，挂载主机上的<code>/path/on/host</code>目录到容器的<code>/path/in/container</code>路径，设置了一个名为<code>ENV_VAR</code>的环境变量，将容器连接到名为<code>my_network</code>的网络，并设置容器退出后始终重启。</p>\n<p>这只是一个简单的Docker入门指南，帮助你了解Docker的基本概念和使用方法。Docker拥有强大的功能和丰富的生态系统，你可以进一步探索Docker的高级特性和用法。</p>\n"},{"title":"非阻塞IO NIO --入门","date":"2024-01-27T07:34:00.000Z","_content":"\n# NIO\n\n非阻塞 IO\n\n> 本笔记资料 来自[黑马程序 Netty 教程 ](https://www.bilibili.com/video/BV1py4y1E7oA/?p=6&share_source=copy_web&vd_source=5c53fad723f9304699742f8633214dd3)及 自己的一些总结\n\n## ByteBuffer\n\n**在内存开辟一个缓冲区，大小不宜过大**\n\n### ByteBuffer 的分配和状态\n\n```java\n    FileChannel channel = file.getChannel();\n     ByteBuffer buffer = ByteBuffer.allocate(10);\n```\n\n##### 一开始 的 状态是**写模式** 也就是分配完空间后\n\n![](https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png)\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\n![](https://s2.loli.net/2024/01/26/DzacF3P7rvwTKEy.png)\n\n##### flip 动作发生后，position 切换为读取位置，limit 切换为**读取限制**\n\n![](https://s2.loli.net/2024/01/26/ZEVTJ2I58Hekstn.png)\n\n读取 4 个字节后，状态\n\n![](https://s2.loli.net/2024/01/26/tF2nQoiPXZ6I8VY.png)\n\n##### clear 动作发生后，状态又变回**写**，注意这里面内容也清空，所以一般读取完才调用\n\n![](https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png)\n\ncompact 方法，是把**未读完的部分向前压缩**，然后切换至**写模式**\n\n![](https://s2.loli.net/2024/01/26/4LqTp86f1bEiGnz.png)\n\n不同类型的空间分配\n\n```java\n    ByteBuffer buf1 = ByteBuffer.allocate(16);  //分配堆内存 会GC调整 读写慢\n    ByteBuffer buf2 = ByteBuffer.allocateDirect(16); //分配直接内存 调用操作系统 分配慢\n```\n\n### ByteBuffer 常见方法\n\n#### 写数据\n\n```java\nint readBytes = channel.read(buf); //channel写\nbuf.put((byte)127); //put写\nbuf.put(byte[]); //写字符数组\n```\n\n#### 读数据\n\n```java\nint writeBytes = channel.write(buf); //channel读\nbyte b = buf.get(); //get读 且会让position后移\nbuf.get(int i) //方法获取索引 i 的内容，它不会移动读指针\n```\n\n#### 调指针\n\n```java\nbuf.rewind(); //rewind 方法将 position 重新置为 0\n// rewind 增强\nbuf.mark();//为当前postion 做一个标记\nbuf.reset(); //重置postion 为mark位置\nbuf.limit(); //获取limit\nbuf.limit(16); //设置limit16\n```\n\n#### 字节数组到 ByteBuffer 转换\n\n```java\n// string 到 buffer 完成后自动会变成读模式\nByteBuffer buffer1 = StandardCharsets.UTF_8.encode(\"你好\");\nByteBuffer buffer2 = Charset.forName(\"utf-8\").encode(\"你好\");\nByteBuffer buffer = ByteBuffer.wrap(\"hello\".getBytes());\n\n//转换 且需要在写模式\nCharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);\n\nSystem.out.println(buffer3.toString()); //你好\n```\n\n## ⚠️ FileChannel 工作模式\n\n> FileChannel 和传统的文件 I/O（例如 FileInputStream、FileOutputStream）之间有几个重要的区别：\n>\n> 非阻塞 I/O：\n>\n> FileChannel 支持非阻塞 I/O 操作，这意味着你可以使用 FileChannel 的某些方法进行异步 I/O 操作，而不必等待每个操作完成。\n> 传统的文件 I/O 是阻塞的，即在进行读或写操作时，程序会一直等待直到操作完成。\n> ByteBuffer 使用：\n>\n> FileChannel 与 ByteBuffer 配合使用，通过将数据存储在 ByteBuffer 中来进行读写操作。\n> 传统的文件 I/O 使用 InputStream 和 OutputStream，并且通常需要在读取或写入数据之前创建一个字节数组。\n> 文件锁定：\n>\n> FileChannel 具有支持文件锁定的能力，可以通过 FileLock 对象实现对文件的独占或共享锁定。\n> 传统文件 I/O 通常不提供直接的文件锁定机制。\n> 内存映射：\n>\n> FileChannel 允许将文件的一部分或整个文件映射到内存中，以便直接在内存中进行读写操作，提高性能。\n> 传统文件 I/O 没有内存映射的直接支持。\n> 性能优势：\n>\n> 由于 FileChannel 允许进行一些底层的优化，因此在某些情况下，它可以提供更好的性能，特别是对于大量数据的读写操作。\n> 传统文件 I/O 可能会在处理大量数据时变得相对较慢。\n\n> FileChannel 只能工作在阻塞模式下\n\n#### 获取\n\n不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\n\n- 通过 FileInputStream 获取的 channel 只能读\n- 通过 FileOutputStream 获取的 channel 只能写\n- 通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定，指定 rw\n\n#### 读取\n\n会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\n\n```java\nint readBytes = channel.read(buffer);\n```\n\n#### 写入\n\n写入的正确姿势如下， SocketChannel\n\n```java\nByteBuffer buffer = ...;\nbuffer.put(...); // 存入数据\nbuffer.flip();   // 切换读模式\n\nwhile(buffer.hasRemaining()) {\n    channel.write(buffer);\n}\n```\n\n在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\n\n#### 关闭\n\nchannel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\n\n#### 位置\n\n获取当前位置\n\n```java\nlong pos = channel.position();\n```\n\n设置当前位置\n\n```java\nlong newPos = ...;\nchannel.position(newPos);\n```\n\n设置当前位置时，如果设置为文件的末尾\n\n- 这时读取会返回 -1\n- 这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\n#### 大小\n\n使用 size 方法获取文件的大小\n\n#### 强制写入 ✨✨\n\n**_操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘_**\n\n#### 两个 channel 传递数据\n\n```java\nString FROM = \"helloword/data.txt\";\nString TO = \"helloword/to.txt\";\nlong start = System.nanoTime();\ntry (FileChannel from = new FileInputStream(FROM).getChannel();\n     FileChannel to = new FileOutputStream(TO).getChannel();\n    ) {\n    from.transferTo(0, from.size(), to);\n} catch (IOException e) {\n    e.printStackTrace();\n}\nlong end = System.nanoTime();\nSystem.out.println(\"transferTo 用时：\" + (end - start) / 1000_000.0);\n```\n\n### Selector 管理 Channel\n\n![image](https://s2.loli.net/2024/01/26/6jpHGOtM92TJQNS.png)\n\n```java\n   //建立Selector\n        Selector selector = Selector.open();\n\n        ByteBuffer buff = ByteBuffer.allocate(16);\n\n        //打开一个ServerSocketChannel\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n\n        //设置阻塞模式为非阻塞\n        ssc.configureBlocking(false);\n\n        // 建立Selector 和 Channel的联系\n        // （管理员）事件发生后，得到事件和哪个channel发生\n        SelectionKey sscKey = ssc.register(selector, 0, null);\n\n        sscKey.interestOps(SelectionKey.OP_ACCEPT);\n        //bind 一个端口\n        ssc.bind(new InetSocketAddress(8888));\n\n        while (true) {\n\n            //没有事件就阻塞，有就继续\n            //事件未处理就不会阻塞\n            selector.select();\n\n            //拿到所有事件集合\n            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n\n\n            while(iterator.hasNext()){\n\n                SelectionKey key = iterator.next();\n\n                //事件用掉要从集合删除\n                iterator.remove();\n\n                log.debug(\"key {}\",key);\n\n                if(key.isAcceptable()) {\n\n                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n\n                    SocketChannel sc = channel.accept();\n                    //设置非阻塞\n                    sc.configureBlocking(false);\n                    //注册到selecor\n                    SelectionKey sk = sc.register(selector, 0, null);\n\n                    sk.interestOps(SelectionKey.OP_READ);\n                } else if (key.isReadable()) {\n\n                    try {\n                        SocketChannel channel = (SocketChannel) key.channel();\n                        int read = channel.read(buff);\n                        if(read==-1)   key.cancel(); //正常断开\n                        else {\n                            buff.flip();             ByteBufferUtil.debugRead(buff);\n                            buff.clear();\n                        }\n                    } catch (IOException e) {\n                        //反注册 移除selector的 key ，因为断开会发生一个读事件\n                        key.cancel();\n                        throw new RuntimeException(e);\n\n                    }\n\n                }\n\n            }\n```\n","source":"_posts/NIO入门.md","raw":"---\ntitle: 非阻塞IO NIO --入门\ntag: NIO\ndate: 2024-1-27 15:34:00\n---\n\n# NIO\n\n非阻塞 IO\n\n> 本笔记资料 来自[黑马程序 Netty 教程 ](https://www.bilibili.com/video/BV1py4y1E7oA/?p=6&share_source=copy_web&vd_source=5c53fad723f9304699742f8633214dd3)及 自己的一些总结\n\n## ByteBuffer\n\n**在内存开辟一个缓冲区，大小不宜过大**\n\n### ByteBuffer 的分配和状态\n\n```java\n    FileChannel channel = file.getChannel();\n     ByteBuffer buffer = ByteBuffer.allocate(10);\n```\n\n##### 一开始 的 状态是**写模式** 也就是分配完空间后\n\n![](https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png)\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\n![](https://s2.loli.net/2024/01/26/DzacF3P7rvwTKEy.png)\n\n##### flip 动作发生后，position 切换为读取位置，limit 切换为**读取限制**\n\n![](https://s2.loli.net/2024/01/26/ZEVTJ2I58Hekstn.png)\n\n读取 4 个字节后，状态\n\n![](https://s2.loli.net/2024/01/26/tF2nQoiPXZ6I8VY.png)\n\n##### clear 动作发生后，状态又变回**写**，注意这里面内容也清空，所以一般读取完才调用\n\n![](https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png)\n\ncompact 方法，是把**未读完的部分向前压缩**，然后切换至**写模式**\n\n![](https://s2.loli.net/2024/01/26/4LqTp86f1bEiGnz.png)\n\n不同类型的空间分配\n\n```java\n    ByteBuffer buf1 = ByteBuffer.allocate(16);  //分配堆内存 会GC调整 读写慢\n    ByteBuffer buf2 = ByteBuffer.allocateDirect(16); //分配直接内存 调用操作系统 分配慢\n```\n\n### ByteBuffer 常见方法\n\n#### 写数据\n\n```java\nint readBytes = channel.read(buf); //channel写\nbuf.put((byte)127); //put写\nbuf.put(byte[]); //写字符数组\n```\n\n#### 读数据\n\n```java\nint writeBytes = channel.write(buf); //channel读\nbyte b = buf.get(); //get读 且会让position后移\nbuf.get(int i) //方法获取索引 i 的内容，它不会移动读指针\n```\n\n#### 调指针\n\n```java\nbuf.rewind(); //rewind 方法将 position 重新置为 0\n// rewind 增强\nbuf.mark();//为当前postion 做一个标记\nbuf.reset(); //重置postion 为mark位置\nbuf.limit(); //获取limit\nbuf.limit(16); //设置limit16\n```\n\n#### 字节数组到 ByteBuffer 转换\n\n```java\n// string 到 buffer 完成后自动会变成读模式\nByteBuffer buffer1 = StandardCharsets.UTF_8.encode(\"你好\");\nByteBuffer buffer2 = Charset.forName(\"utf-8\").encode(\"你好\");\nByteBuffer buffer = ByteBuffer.wrap(\"hello\".getBytes());\n\n//转换 且需要在写模式\nCharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);\n\nSystem.out.println(buffer3.toString()); //你好\n```\n\n## ⚠️ FileChannel 工作模式\n\n> FileChannel 和传统的文件 I/O（例如 FileInputStream、FileOutputStream）之间有几个重要的区别：\n>\n> 非阻塞 I/O：\n>\n> FileChannel 支持非阻塞 I/O 操作，这意味着你可以使用 FileChannel 的某些方法进行异步 I/O 操作，而不必等待每个操作完成。\n> 传统的文件 I/O 是阻塞的，即在进行读或写操作时，程序会一直等待直到操作完成。\n> ByteBuffer 使用：\n>\n> FileChannel 与 ByteBuffer 配合使用，通过将数据存储在 ByteBuffer 中来进行读写操作。\n> 传统的文件 I/O 使用 InputStream 和 OutputStream，并且通常需要在读取或写入数据之前创建一个字节数组。\n> 文件锁定：\n>\n> FileChannel 具有支持文件锁定的能力，可以通过 FileLock 对象实现对文件的独占或共享锁定。\n> 传统文件 I/O 通常不提供直接的文件锁定机制。\n> 内存映射：\n>\n> FileChannel 允许将文件的一部分或整个文件映射到内存中，以便直接在内存中进行读写操作，提高性能。\n> 传统文件 I/O 没有内存映射的直接支持。\n> 性能优势：\n>\n> 由于 FileChannel 允许进行一些底层的优化，因此在某些情况下，它可以提供更好的性能，特别是对于大量数据的读写操作。\n> 传统文件 I/O 可能会在处理大量数据时变得相对较慢。\n\n> FileChannel 只能工作在阻塞模式下\n\n#### 获取\n\n不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\n\n- 通过 FileInputStream 获取的 channel 只能读\n- 通过 FileOutputStream 获取的 channel 只能写\n- 通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定，指定 rw\n\n#### 读取\n\n会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\n\n```java\nint readBytes = channel.read(buffer);\n```\n\n#### 写入\n\n写入的正确姿势如下， SocketChannel\n\n```java\nByteBuffer buffer = ...;\nbuffer.put(...); // 存入数据\nbuffer.flip();   // 切换读模式\n\nwhile(buffer.hasRemaining()) {\n    channel.write(buffer);\n}\n```\n\n在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\n\n#### 关闭\n\nchannel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\n\n#### 位置\n\n获取当前位置\n\n```java\nlong pos = channel.position();\n```\n\n设置当前位置\n\n```java\nlong newPos = ...;\nchannel.position(newPos);\n```\n\n设置当前位置时，如果设置为文件的末尾\n\n- 这时读取会返回 -1\n- 这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\n#### 大小\n\n使用 size 方法获取文件的大小\n\n#### 强制写入 ✨✨\n\n**_操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘_**\n\n#### 两个 channel 传递数据\n\n```java\nString FROM = \"helloword/data.txt\";\nString TO = \"helloword/to.txt\";\nlong start = System.nanoTime();\ntry (FileChannel from = new FileInputStream(FROM).getChannel();\n     FileChannel to = new FileOutputStream(TO).getChannel();\n    ) {\n    from.transferTo(0, from.size(), to);\n} catch (IOException e) {\n    e.printStackTrace();\n}\nlong end = System.nanoTime();\nSystem.out.println(\"transferTo 用时：\" + (end - start) / 1000_000.0);\n```\n\n### Selector 管理 Channel\n\n![image](https://s2.loli.net/2024/01/26/6jpHGOtM92TJQNS.png)\n\n```java\n   //建立Selector\n        Selector selector = Selector.open();\n\n        ByteBuffer buff = ByteBuffer.allocate(16);\n\n        //打开一个ServerSocketChannel\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n\n        //设置阻塞模式为非阻塞\n        ssc.configureBlocking(false);\n\n        // 建立Selector 和 Channel的联系\n        // （管理员）事件发生后，得到事件和哪个channel发生\n        SelectionKey sscKey = ssc.register(selector, 0, null);\n\n        sscKey.interestOps(SelectionKey.OP_ACCEPT);\n        //bind 一个端口\n        ssc.bind(new InetSocketAddress(8888));\n\n        while (true) {\n\n            //没有事件就阻塞，有就继续\n            //事件未处理就不会阻塞\n            selector.select();\n\n            //拿到所有事件集合\n            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n\n\n            while(iterator.hasNext()){\n\n                SelectionKey key = iterator.next();\n\n                //事件用掉要从集合删除\n                iterator.remove();\n\n                log.debug(\"key {}\",key);\n\n                if(key.isAcceptable()) {\n\n                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n\n                    SocketChannel sc = channel.accept();\n                    //设置非阻塞\n                    sc.configureBlocking(false);\n                    //注册到selecor\n                    SelectionKey sk = sc.register(selector, 0, null);\n\n                    sk.interestOps(SelectionKey.OP_READ);\n                } else if (key.isReadable()) {\n\n                    try {\n                        SocketChannel channel = (SocketChannel) key.channel();\n                        int read = channel.read(buff);\n                        if(read==-1)   key.cancel(); //正常断开\n                        else {\n                            buff.flip();             ByteBufferUtil.debugRead(buff);\n                            buff.clear();\n                        }\n                    } catch (IOException e) {\n                        //反注册 移除selector的 key ，因为断开会发生一个读事件\n                        key.cancel();\n                        throw new RuntimeException(e);\n\n                    }\n\n                }\n\n            }\n```\n","slug":"NIO入门","published":1,"updated":"2024-01-28T17:40:14.492Z","_id":"clrxrizsx0002b4tnef478zd9","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h1><p>非阻塞 IO</p>\n<blockquote>\n<p>本笔记资料 来自<a href=\"https://www.bilibili.com/video/BV1py4y1E7oA/?p=6&share_source=copy_web&vd_source=5c53fad723f9304699742f8633214dd3\">黑马程序 Netty 教程 </a>及 自己的一些总结</p>\n</blockquote>\n<h2 id=\"ByteBuffer\"><a href=\"#ByteBuffer\" class=\"headerlink\" title=\"ByteBuffer\"></a>ByteBuffer</h2><p><strong>在内存开辟一个缓冲区，大小不宜过大</strong></p>\n<h3 id=\"ByteBuffer-的分配和状态\"><a href=\"#ByteBuffer-的分配和状态\" class=\"headerlink\" title=\"ByteBuffer 的分配和状态\"></a>ByteBuffer 的分配和状态</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> file.getChannel();<br> <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"一开始-的-状态是写模式-也就是分配完空间后\"><a href=\"#一开始-的-状态是写模式-也就是分配完空间后\" class=\"headerlink\" title=\"一开始 的 状态是写模式 也就是分配完空间后\"></a>一开始 的 状态是<strong>写模式</strong> 也就是分配完空间后</h5><p><img src=\"https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png\"></p>\n<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>\n<p><img src=\"https://s2.loli.net/2024/01/26/DzacF3P7rvwTKEy.png\"></p>\n<h5 id=\"flip-动作发生后，position-切换为读取位置，limit-切换为读取限制\"><a href=\"#flip-动作发生后，position-切换为读取位置，limit-切换为读取限制\" class=\"headerlink\" title=\"flip 动作发生后，position 切换为读取位置，limit 切换为读取限制\"></a>flip 动作发生后，position 切换为读取位置，limit 切换为<strong>读取限制</strong></h5><p><img src=\"https://s2.loli.net/2024/01/26/ZEVTJ2I58Hekstn.png\"></p>\n<p>读取 4 个字节后，状态</p>\n<p><img src=\"https://s2.loli.net/2024/01/26/tF2nQoiPXZ6I8VY.png\"></p>\n<h5 id=\"clear-动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用\"><a href=\"#clear-动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用\" class=\"headerlink\" title=\"clear 动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用\"></a>clear 动作发生后，状态又变回<strong>写</strong>，注意这里面内容也清空，所以一般读取完才调用</h5><p><img src=\"https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png\"></p>\n<p>compact 方法，是把<strong>未读完的部分向前压缩</strong>，然后切换至<strong>写模式</strong></p>\n<p><img src=\"https://s2.loli.net/2024/01/26/4LqTp86f1bEiGnz.png\"></p>\n<p>不同类型的空间分配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buf1</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">16</span>);  <span class=\"hljs-comment\">//分配堆内存 会GC调整 读写慢</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buf2</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocateDirect(<span class=\"hljs-number\">16</span>); <span class=\"hljs-comment\">//分配直接内存 调用操作系统 分配慢</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"ByteBuffer-常见方法\"><a href=\"#ByteBuffer-常见方法\" class=\"headerlink\" title=\"ByteBuffer 常见方法\"></a>ByteBuffer 常见方法</h3><h4 id=\"写数据\"><a href=\"#写数据\" class=\"headerlink\" title=\"写数据\"></a>写数据</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">readBytes</span> <span class=\"hljs-operator\">=</span> channel.read(buf); <span class=\"hljs-comment\">//channel写</span><br>buf.put((<span class=\"hljs-type\">byte</span>)<span class=\"hljs-number\">127</span>); <span class=\"hljs-comment\">//put写</span><br>buf.put(<span class=\"hljs-type\">byte</span>[]); <span class=\"hljs-comment\">//写字符数组</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"读数据\"><a href=\"#读数据\" class=\"headerlink\" title=\"读数据\"></a>读数据</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">writeBytes</span> <span class=\"hljs-operator\">=</span> channel.write(buf); <span class=\"hljs-comment\">//channel读</span><br><span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> buf.get(); <span class=\"hljs-comment\">//get读 且会让position后移</span><br>buf.get(<span class=\"hljs-type\">int</span> i) <span class=\"hljs-comment\">//方法获取索引 i 的内容，它不会移动读指针</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"调指针\"><a href=\"#调指针\" class=\"headerlink\" title=\"调指针\"></a>调指针</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">buf.rewind(); <span class=\"hljs-comment\">//rewind 方法将 position 重新置为 0</span><br><span class=\"hljs-comment\">// rewind 增强</span><br>buf.mark();<span class=\"hljs-comment\">//为当前postion 做一个标记</span><br>buf.reset(); <span class=\"hljs-comment\">//重置postion 为mark位置</span><br>buf.limit(); <span class=\"hljs-comment\">//获取limit</span><br>buf.limit(<span class=\"hljs-number\">16</span>); <span class=\"hljs-comment\">//设置limit16</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"字节数组到-ByteBuffer-转换\"><a href=\"#字节数组到-ByteBuffer-转换\" class=\"headerlink\" title=\"字节数组到 ByteBuffer 转换\"></a>字节数组到 ByteBuffer 转换</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// string 到 buffer 完成后自动会变成读模式</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer1</span> <span class=\"hljs-operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"hljs-string\">&quot;你好&quot;</span>);<br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer2</span> <span class=\"hljs-operator\">=</span> Charset.forName(<span class=\"hljs-string\">&quot;utf-8&quot;</span>).encode(<span class=\"hljs-string\">&quot;你好&quot;</span>);<br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(<span class=\"hljs-string\">&quot;hello&quot;</span>.getBytes());<br><br><span class=\"hljs-comment\">//转换 且需要在写模式</span><br><span class=\"hljs-type\">CharBuffer</span> <span class=\"hljs-variable\">buffer3</span> <span class=\"hljs-operator\">=</span> StandardCharsets.UTF_8.decode(buffer1);<br><br>System.out.println(buffer3.toString()); <span class=\"hljs-comment\">//你好</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"⚠️-FileChannel-工作模式\"><a href=\"#⚠️-FileChannel-工作模式\" class=\"headerlink\" title=\"⚠️ FileChannel 工作模式\"></a>⚠️ FileChannel 工作模式</h2><blockquote>\n<p>FileChannel 和传统的文件 I/O（例如 FileInputStream、FileOutputStream）之间有几个重要的区别：</p>\n<p>非阻塞 I/O：</p>\n<p>FileChannel 支持非阻塞 I/O 操作，这意味着你可以使用 FileChannel 的某些方法进行异步 I/O 操作，而不必等待每个操作完成。<br>传统的文件 I/O 是阻塞的，即在进行读或写操作时，程序会一直等待直到操作完成。<br>ByteBuffer 使用：</p>\n<p>FileChannel 与 ByteBuffer 配合使用，通过将数据存储在 ByteBuffer 中来进行读写操作。<br>传统的文件 I/O 使用 InputStream 和 OutputStream，并且通常需要在读取或写入数据之前创建一个字节数组。<br>文件锁定：</p>\n<p>FileChannel 具有支持文件锁定的能力，可以通过 FileLock 对象实现对文件的独占或共享锁定。<br>传统文件 I/O 通常不提供直接的文件锁定机制。<br>内存映射：</p>\n<p>FileChannel 允许将文件的一部分或整个文件映射到内存中，以便直接在内存中进行读写操作，提高性能。<br>传统文件 I/O 没有内存映射的直接支持。<br>性能优势：</p>\n<p>由于 FileChannel 允许进行一些底层的优化，因此在某些情况下，它可以提供更好的性能，特别是对于大量数据的读写操作。<br>传统文件 I/O 可能会在处理大量数据时变得相对较慢。</p>\n</blockquote>\n<blockquote>\n<p>FileChannel 只能工作在阻塞模式下</p>\n</blockquote>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>\n<ul>\n<li>通过 FileInputStream 获取的 channel 只能读</li>\n<li>通过 FileOutputStream 获取的 channel 只能写</li>\n<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定，指定 rw</li>\n</ul>\n<h4 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">readBytes</span> <span class=\"hljs-operator\">=</span> channel.read(buffer);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ...;<br>buffer.put(...); <span class=\"hljs-comment\">// 存入数据</span><br>buffer.flip();   <span class=\"hljs-comment\">// 切换读模式</span><br><br><span class=\"hljs-keyword\">while</span>(buffer.hasRemaining()) &#123;<br>    channel.write(buffer);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p>\n<h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>获取当前位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">pos</span> <span class=\"hljs-operator\">=</span> channel.position();<br></code></pre></td></tr></table></figure>\n\n<p>设置当前位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">newPos</span> <span class=\"hljs-operator\">=</span> ...;<br>channel.position(newPos);<br></code></pre></td></tr></table></figure>\n\n<p>设置当前位置时，如果设置为文件的末尾</p>\n<ul>\n<li>这时读取会返回 -1</li>\n<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>\n</ul>\n<h4 id=\"大小\"><a href=\"#大小\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>使用 size 方法获取文件的大小</p>\n<h4 id=\"强制写入-✨✨\"><a href=\"#强制写入-✨✨\" class=\"headerlink\" title=\"强制写入 ✨✨\"></a>强制写入 ✨✨</h4><p><strong><em>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</em></strong></p>\n<h4 id=\"两个-channel-传递数据\"><a href=\"#两个-channel-传递数据\" class=\"headerlink\" title=\"两个 channel 传递数据\"></a>两个 channel 传递数据</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">FROM</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;helloword/data.txt&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">TO</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;helloword/to.txt&quot;</span>;<br><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> System.nanoTime();<br><span class=\"hljs-keyword\">try</span> (<span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">from</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(FROM).getChannel();<br>     <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">to</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileOutputStream</span>(TO).getChannel();<br>    ) &#123;<br>    from.transferTo(<span class=\"hljs-number\">0</span>, from.size(), to);<br>&#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">end</span> <span class=\"hljs-operator\">=</span> System.nanoTime();<br>System.out.println(<span class=\"hljs-string\">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class=\"hljs-number\">1000_000.0</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Selector-管理-Channel\"><a href=\"#Selector-管理-Channel\" class=\"headerlink\" title=\"Selector 管理 Channel\"></a>Selector 管理 Channel</h3><p><img src=\"https://s2.loli.net/2024/01/26/6jpHGOtM92TJQNS.png\" alt=\"image\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//建立Selector</span><br>     <span class=\"hljs-type\">Selector</span> <span class=\"hljs-variable\">selector</span> <span class=\"hljs-operator\">=</span> Selector.open();<br><br>     <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buff</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">16</span>);<br><br>     <span class=\"hljs-comment\">//打开一个ServerSocketChannel</span><br>     <span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">ssc</span> <span class=\"hljs-operator\">=</span> ServerSocketChannel.open();<br><br>     <span class=\"hljs-comment\">//设置阻塞模式为非阻塞</span><br>     ssc.configureBlocking(<span class=\"hljs-literal\">false</span>);<br><br>     <span class=\"hljs-comment\">// 建立Selector 和 Channel的联系</span><br>     <span class=\"hljs-comment\">// （管理员）事件发生后，得到事件和哪个channel发生</span><br>     <span class=\"hljs-type\">SelectionKey</span> <span class=\"hljs-variable\">sscKey</span> <span class=\"hljs-operator\">=</span> ssc.register(selector, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">null</span>);<br><br>     sscKey.interestOps(SelectionKey.OP_ACCEPT);<br>     <span class=\"hljs-comment\">//bind 一个端口</span><br>     ssc.bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">8888</span>));<br><br>     <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br><br>         <span class=\"hljs-comment\">//没有事件就阻塞，有就继续</span><br>         <span class=\"hljs-comment\">//事件未处理就不会阻塞</span><br>         selector.select();<br><br>         <span class=\"hljs-comment\">//拿到所有事件集合</span><br>         Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br><br>         <span class=\"hljs-keyword\">while</span>(iterator.hasNext())&#123;<br><br>             <span class=\"hljs-type\">SelectionKey</span> <span class=\"hljs-variable\">key</span> <span class=\"hljs-operator\">=</span> iterator.next();<br><br>             <span class=\"hljs-comment\">//事件用掉要从集合删除</span><br>             iterator.remove();<br><br>             log.debug(<span class=\"hljs-string\">&quot;key &#123;&#125;&quot;</span>,key);<br><br>             <span class=\"hljs-keyword\">if</span>(key.isAcceptable()) &#123;<br><br>                 <span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> (ServerSocketChannel) key.channel();<br><br>                 <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> channel.accept();<br>                 <span class=\"hljs-comment\">//设置非阻塞</span><br>                 sc.configureBlocking(<span class=\"hljs-literal\">false</span>);<br>                 <span class=\"hljs-comment\">//注册到selecor</span><br>                 <span class=\"hljs-type\">SelectionKey</span> <span class=\"hljs-variable\">sk</span> <span class=\"hljs-operator\">=</span> sc.register(selector, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">null</span>);<br><br>                 sk.interestOps(SelectionKey.OP_READ);<br>             &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key.isReadable()) &#123;<br><br>                 <span class=\"hljs-keyword\">try</span> &#123;<br>                     <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> (SocketChannel) key.channel();<br>                     <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">read</span> <span class=\"hljs-operator\">=</span> channel.read(buff);<br>                     <span class=\"hljs-keyword\">if</span>(read==-<span class=\"hljs-number\">1</span>)   key.cancel(); <span class=\"hljs-comment\">//正常断开</span><br>                     <span class=\"hljs-keyword\">else</span> &#123;<br>                         buff.flip();             ByteBufferUtil.debugRead(buff);<br>                         buff.clear();<br>                     &#125;<br>                 &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>                     <span class=\"hljs-comment\">//反注册 移除selector的 key ，因为断开会发生一个读事件</span><br>                     key.cancel();<br>                     <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);<br><br>                 &#125;<br><br>             &#125;<br><br>         &#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h1><p>非阻塞 IO</p>\n<blockquote>\n<p>本笔记资料 来自<a href=\"https://www.bilibili.com/video/BV1py4y1E7oA/?p=6&share_source=copy_web&vd_source=5c53fad723f9304699742f8633214dd3\">黑马程序 Netty 教程 </a>及 自己的一些总结</p>\n</blockquote>\n<h2 id=\"ByteBuffer\"><a href=\"#ByteBuffer\" class=\"headerlink\" title=\"ByteBuffer\"></a>ByteBuffer</h2><p><strong>在内存开辟一个缓冲区，大小不宜过大</strong></p>\n<h3 id=\"ByteBuffer-的分配和状态\"><a href=\"#ByteBuffer-的分配和状态\" class=\"headerlink\" title=\"ByteBuffer 的分配和状态\"></a>ByteBuffer 的分配和状态</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> file.getChannel();<br> <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">10</span>);<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"一开始-的-状态是写模式-也就是分配完空间后\"><a href=\"#一开始-的-状态是写模式-也就是分配完空间后\" class=\"headerlink\" title=\"一开始 的 状态是写模式 也就是分配完空间后\"></a>一开始 的 状态是<strong>写模式</strong> 也就是分配完空间后</h5><p><img src=\"https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png\"></p>\n<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>\n<p><img src=\"https://s2.loli.net/2024/01/26/DzacF3P7rvwTKEy.png\"></p>\n<h5 id=\"flip-动作发生后，position-切换为读取位置，limit-切换为读取限制\"><a href=\"#flip-动作发生后，position-切换为读取位置，limit-切换为读取限制\" class=\"headerlink\" title=\"flip 动作发生后，position 切换为读取位置，limit 切换为读取限制\"></a>flip 动作发生后，position 切换为读取位置，limit 切换为<strong>读取限制</strong></h5><p><img src=\"https://s2.loli.net/2024/01/26/ZEVTJ2I58Hekstn.png\"></p>\n<p>读取 4 个字节后，状态</p>\n<p><img src=\"https://s2.loli.net/2024/01/26/tF2nQoiPXZ6I8VY.png\"></p>\n<h5 id=\"clear-动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用\"><a href=\"#clear-动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用\" class=\"headerlink\" title=\"clear 动作发生后，状态又变回写，注意这里面内容也清空，所以一般读取完才调用\"></a>clear 动作发生后，状态又变回<strong>写</strong>，注意这里面内容也清空，所以一般读取完才调用</h5><p><img src=\"https://s2.loli.net/2024/01/26/8WIijoOlae1JFGk.png\"></p>\n<p>compact 方法，是把<strong>未读完的部分向前压缩</strong>，然后切换至<strong>写模式</strong></p>\n<p><img src=\"https://s2.loli.net/2024/01/26/4LqTp86f1bEiGnz.png\"></p>\n<p>不同类型的空间分配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buf1</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">16</span>);  <span class=\"hljs-comment\">//分配堆内存 会GC调整 读写慢</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buf2</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocateDirect(<span class=\"hljs-number\">16</span>); <span class=\"hljs-comment\">//分配直接内存 调用操作系统 分配慢</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"ByteBuffer-常见方法\"><a href=\"#ByteBuffer-常见方法\" class=\"headerlink\" title=\"ByteBuffer 常见方法\"></a>ByteBuffer 常见方法</h3><h4 id=\"写数据\"><a href=\"#写数据\" class=\"headerlink\" title=\"写数据\"></a>写数据</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">readBytes</span> <span class=\"hljs-operator\">=</span> channel.read(buf); <span class=\"hljs-comment\">//channel写</span><br>buf.put((<span class=\"hljs-type\">byte</span>)<span class=\"hljs-number\">127</span>); <span class=\"hljs-comment\">//put写</span><br>buf.put(<span class=\"hljs-type\">byte</span>[]); <span class=\"hljs-comment\">//写字符数组</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"读数据\"><a href=\"#读数据\" class=\"headerlink\" title=\"读数据\"></a>读数据</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">writeBytes</span> <span class=\"hljs-operator\">=</span> channel.write(buf); <span class=\"hljs-comment\">//channel读</span><br><span class=\"hljs-type\">byte</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> buf.get(); <span class=\"hljs-comment\">//get读 且会让position后移</span><br>buf.get(<span class=\"hljs-type\">int</span> i) <span class=\"hljs-comment\">//方法获取索引 i 的内容，它不会移动读指针</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"调指针\"><a href=\"#调指针\" class=\"headerlink\" title=\"调指针\"></a>调指针</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">buf.rewind(); <span class=\"hljs-comment\">//rewind 方法将 position 重新置为 0</span><br><span class=\"hljs-comment\">// rewind 增强</span><br>buf.mark();<span class=\"hljs-comment\">//为当前postion 做一个标记</span><br>buf.reset(); <span class=\"hljs-comment\">//重置postion 为mark位置</span><br>buf.limit(); <span class=\"hljs-comment\">//获取limit</span><br>buf.limit(<span class=\"hljs-number\">16</span>); <span class=\"hljs-comment\">//设置limit16</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"字节数组到-ByteBuffer-转换\"><a href=\"#字节数组到-ByteBuffer-转换\" class=\"headerlink\" title=\"字节数组到 ByteBuffer 转换\"></a>字节数组到 ByteBuffer 转换</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// string 到 buffer 完成后自动会变成读模式</span><br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer1</span> <span class=\"hljs-operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"hljs-string\">&quot;你好&quot;</span>);<br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer2</span> <span class=\"hljs-operator\">=</span> Charset.forName(<span class=\"hljs-string\">&quot;utf-8&quot;</span>).encode(<span class=\"hljs-string\">&quot;你好&quot;</span>);<br><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ByteBuffer.wrap(<span class=\"hljs-string\">&quot;hello&quot;</span>.getBytes());<br><br><span class=\"hljs-comment\">//转换 且需要在写模式</span><br><span class=\"hljs-type\">CharBuffer</span> <span class=\"hljs-variable\">buffer3</span> <span class=\"hljs-operator\">=</span> StandardCharsets.UTF_8.decode(buffer1);<br><br>System.out.println(buffer3.toString()); <span class=\"hljs-comment\">//你好</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"⚠️-FileChannel-工作模式\"><a href=\"#⚠️-FileChannel-工作模式\" class=\"headerlink\" title=\"⚠️ FileChannel 工作模式\"></a>⚠️ FileChannel 工作模式</h2><blockquote>\n<p>FileChannel 和传统的文件 I/O（例如 FileInputStream、FileOutputStream）之间有几个重要的区别：</p>\n<p>非阻塞 I/O：</p>\n<p>FileChannel 支持非阻塞 I/O 操作，这意味着你可以使用 FileChannel 的某些方法进行异步 I/O 操作，而不必等待每个操作完成。<br>传统的文件 I/O 是阻塞的，即在进行读或写操作时，程序会一直等待直到操作完成。<br>ByteBuffer 使用：</p>\n<p>FileChannel 与 ByteBuffer 配合使用，通过将数据存储在 ByteBuffer 中来进行读写操作。<br>传统的文件 I/O 使用 InputStream 和 OutputStream，并且通常需要在读取或写入数据之前创建一个字节数组。<br>文件锁定：</p>\n<p>FileChannel 具有支持文件锁定的能力，可以通过 FileLock 对象实现对文件的独占或共享锁定。<br>传统文件 I/O 通常不提供直接的文件锁定机制。<br>内存映射：</p>\n<p>FileChannel 允许将文件的一部分或整个文件映射到内存中，以便直接在内存中进行读写操作，提高性能。<br>传统文件 I/O 没有内存映射的直接支持。<br>性能优势：</p>\n<p>由于 FileChannel 允许进行一些底层的优化，因此在某些情况下，它可以提供更好的性能，特别是对于大量数据的读写操作。<br>传统文件 I/O 可能会在处理大量数据时变得相对较慢。</p>\n</blockquote>\n<blockquote>\n<p>FileChannel 只能工作在阻塞模式下</p>\n</blockquote>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>\n<ul>\n<li>通过 FileInputStream 获取的 channel 只能读</li>\n<li>通过 FileOutputStream 获取的 channel 只能写</li>\n<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定，指定 rw</li>\n</ul>\n<h4 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">readBytes</span> <span class=\"hljs-operator\">=</span> channel.read(buffer);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buffer</span> <span class=\"hljs-operator\">=</span> ...;<br>buffer.put(...); <span class=\"hljs-comment\">// 存入数据</span><br>buffer.flip();   <span class=\"hljs-comment\">// 切换读模式</span><br><br><span class=\"hljs-keyword\">while</span>(buffer.hasRemaining()) &#123;<br>    channel.write(buffer);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p>\n<h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>获取当前位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">pos</span> <span class=\"hljs-operator\">=</span> channel.position();<br></code></pre></td></tr></table></figure>\n\n<p>设置当前位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">newPos</span> <span class=\"hljs-operator\">=</span> ...;<br>channel.position(newPos);<br></code></pre></td></tr></table></figure>\n\n<p>设置当前位置时，如果设置为文件的末尾</p>\n<ul>\n<li>这时读取会返回 -1</li>\n<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>\n</ul>\n<h4 id=\"大小\"><a href=\"#大小\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>使用 size 方法获取文件的大小</p>\n<h4 id=\"强制写入-✨✨\"><a href=\"#强制写入-✨✨\" class=\"headerlink\" title=\"强制写入 ✨✨\"></a>强制写入 ✨✨</h4><p><strong><em>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</em></strong></p>\n<h4 id=\"两个-channel-传递数据\"><a href=\"#两个-channel-传递数据\" class=\"headerlink\" title=\"两个 channel 传递数据\"></a>两个 channel 传递数据</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">FROM</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;helloword/data.txt&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">TO</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;helloword/to.txt&quot;</span>;<br><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> System.nanoTime();<br><span class=\"hljs-keyword\">try</span> (<span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">from</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(FROM).getChannel();<br>     <span class=\"hljs-type\">FileChannel</span> <span class=\"hljs-variable\">to</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileOutputStream</span>(TO).getChannel();<br>    ) &#123;<br>    from.transferTo(<span class=\"hljs-number\">0</span>, from.size(), to);<br>&#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">end</span> <span class=\"hljs-operator\">=</span> System.nanoTime();<br>System.out.println(<span class=\"hljs-string\">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class=\"hljs-number\">1000_000.0</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Selector-管理-Channel\"><a href=\"#Selector-管理-Channel\" class=\"headerlink\" title=\"Selector 管理 Channel\"></a>Selector 管理 Channel</h3><p><img src=\"https://s2.loli.net/2024/01/26/6jpHGOtM92TJQNS.png\" alt=\"image\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//建立Selector</span><br>     <span class=\"hljs-type\">Selector</span> <span class=\"hljs-variable\">selector</span> <span class=\"hljs-operator\">=</span> Selector.open();<br><br>     <span class=\"hljs-type\">ByteBuffer</span> <span class=\"hljs-variable\">buff</span> <span class=\"hljs-operator\">=</span> ByteBuffer.allocate(<span class=\"hljs-number\">16</span>);<br><br>     <span class=\"hljs-comment\">//打开一个ServerSocketChannel</span><br>     <span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">ssc</span> <span class=\"hljs-operator\">=</span> ServerSocketChannel.open();<br><br>     <span class=\"hljs-comment\">//设置阻塞模式为非阻塞</span><br>     ssc.configureBlocking(<span class=\"hljs-literal\">false</span>);<br><br>     <span class=\"hljs-comment\">// 建立Selector 和 Channel的联系</span><br>     <span class=\"hljs-comment\">// （管理员）事件发生后，得到事件和哪个channel发生</span><br>     <span class=\"hljs-type\">SelectionKey</span> <span class=\"hljs-variable\">sscKey</span> <span class=\"hljs-operator\">=</span> ssc.register(selector, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">null</span>);<br><br>     sscKey.interestOps(SelectionKey.OP_ACCEPT);<br>     <span class=\"hljs-comment\">//bind 一个端口</span><br>     ssc.bind(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InetSocketAddress</span>(<span class=\"hljs-number\">8888</span>));<br><br>     <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br><br>         <span class=\"hljs-comment\">//没有事件就阻塞，有就继续</span><br>         <span class=\"hljs-comment\">//事件未处理就不会阻塞</span><br>         selector.select();<br><br>         <span class=\"hljs-comment\">//拿到所有事件集合</span><br>         Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br><br>         <span class=\"hljs-keyword\">while</span>(iterator.hasNext())&#123;<br><br>             <span class=\"hljs-type\">SelectionKey</span> <span class=\"hljs-variable\">key</span> <span class=\"hljs-operator\">=</span> iterator.next();<br><br>             <span class=\"hljs-comment\">//事件用掉要从集合删除</span><br>             iterator.remove();<br><br>             log.debug(<span class=\"hljs-string\">&quot;key &#123;&#125;&quot;</span>,key);<br><br>             <span class=\"hljs-keyword\">if</span>(key.isAcceptable()) &#123;<br><br>                 <span class=\"hljs-type\">ServerSocketChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> (ServerSocketChannel) key.channel();<br><br>                 <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> channel.accept();<br>                 <span class=\"hljs-comment\">//设置非阻塞</span><br>                 sc.configureBlocking(<span class=\"hljs-literal\">false</span>);<br>                 <span class=\"hljs-comment\">//注册到selecor</span><br>                 <span class=\"hljs-type\">SelectionKey</span> <span class=\"hljs-variable\">sk</span> <span class=\"hljs-operator\">=</span> sc.register(selector, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">null</span>);<br><br>                 sk.interestOps(SelectionKey.OP_READ);<br>             &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key.isReadable()) &#123;<br><br>                 <span class=\"hljs-keyword\">try</span> &#123;<br>                     <span class=\"hljs-type\">SocketChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> (SocketChannel) key.channel();<br>                     <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">read</span> <span class=\"hljs-operator\">=</span> channel.read(buff);<br>                     <span class=\"hljs-keyword\">if</span>(read==-<span class=\"hljs-number\">1</span>)   key.cancel(); <span class=\"hljs-comment\">//正常断开</span><br>                     <span class=\"hljs-keyword\">else</span> &#123;<br>                         buff.flip();             ByteBufferUtil.debugRead(buff);<br>                         buff.clear();<br>                     &#125;<br>                 &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>                     <span class=\"hljs-comment\">//反注册 移除selector的 key ，因为断开会发生一个读事件</span><br>                     key.cancel();<br>                     <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);<br><br>                 &#125;<br><br>             &#125;<br><br>         &#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"Nginx 入门 server块 书写之 location 规则 （一）","date":"2023-04-08T18:17:00.000Z","_content":"\n\n\n#  Nginx 入门 server块 书写之 location 规则 （一）\n\n一个高性能的支持高并发的Web服务器，代理服务器\n\n1.  反向代理\n2.  负载均衡\n3.  Web服务器\n4.  安全校验，接口限流\n\n#### 处理请求\n\n```bash\nserver {            \t\t\t\t\t\t# 第一个Server区块开始，表示一个独立的虚拟主机站点\n        listen       80；      \t\t\t\t\t# 提供服务的端口，默认80\n        server_name  localhost；       \t\t\t# 提供服务的域名主机名\n        location / {            \t\t\t\t# 第一个location区块开始\n            root   html；       \t\t\t\t# 站点的根目录，相当于Nginx的安装目录\n            index  index.html index.htm；      \t# 默认的首页文件，多个用空格分开\n        }          \t\t\t\t\t\t\t\t# 第一个location区块结果\n}\n```\n\n接受请求后会通过listen 以及 server\\_name 来匹配server模块，然后根据location匹配路径资源，一个典型的应用就是一个二级域名下的子域名全部代理到同一个端口\n\n```bash\nserver {            \t\t\t\t\t\t# 第一个Server区块开始，表示一个独立的虚拟主机站点\n        listen       80；      \t\t\t\t\t# 提供服务的端口，默认80\n        server_name  demo1.aaa.com；       \t\t\t# 提供服务的域名主机名\n        location / {            \t\t\t\t# 第一个location区块开始\n            root   html1；       \t\t\t\t# 站点的根目录，相当于Nginx的安装目录\n            index  index.html index.htm；      \t# 默认的首页文件，多个用空格分开\n        }          \t\t\t\t\t\t\t\t# 第一个location区块结果\n}\nserver {            \t\t\t\t\t\t# 第一个Server区块开始，表示一个独立的虚拟主机站点\n        listen       80；      \t\t\t\t\t# 提供服务的端口，默认80\n        server_name  demo2.aaa.com；       \t\t\t# 提供服务的域名主机名\n        location / {            \t\t\t\t# 第一个location区块开始\n            root   html2；       \t\t\t\t# 站点的根目录，相当于Nginx的安装目录\n            index  index.html index.htm；      \t# 默认的首页文件，多个用空格分开\n        }          \t\t\t\t\t\t\t\t# 第一个location区块结果\n}\n```\n\n#### location语法\n\n##### 先说alias 和 root 的区别\n\n```bash\nlocation /img/ {\n\talias /var/www/image/;\n}\n#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件\nlocation /img/ {\n\troot /var/www/image;\n}\n#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件\n```\n\n所以使用alias 最后一定是 以 / 结尾 .\n\n##### 修饰符匹配\n\n```bash\nserver {\n    server_name website.com;\n    location = /abcd {\n    […]\n    }\n}\n\n#  `http://website.com/abcd`**匹配**\n#  `http://website.com/ABCD`**可能会匹配** ，也可以不匹配，取决于操作系统的文件系统是否大小写敏感（case-sensitive）。ps: Mac 默认是大小写不敏感的\n#  `http://website.com/abcd?param1&param2`**匹配**，忽略 querystring\n#  `http://website.com/abcd/`**不匹配**，带有结尾的`/`\n#  `http://website.com/abcde`**不匹配**\n```\n\n```bash\nserver {\n    server_name website.com;\n    location ~ ^/abcd$ {\n    […]\n    }\n}\n\n# ^/abcd$这个正则表达式表示字符串必须以/开始，以$结束，中间必须是abcd\n#区分大小写的正则匹配\n#http://website.com/abcd匹配（完全匹配）\n#http://website.com/ABCD不匹配，大小写敏感\n#http://website.com/abcd?param1&param2匹配\n#http://website.com/abcd/不匹配，不能匹配正则表达式\n#http://website.com/abcde不匹配，不能匹配正则表达式\n```\n\n```bash\nserver {\n    server_name website.com;\n    location ~* ^/abcd$ {\n    […]\n    }\n}\n#不区分大小写的正则匹配\n#http://website.com/abcd匹配 (完全匹配)\n#http://website.com/ABCD匹配 (大小写不敏感)\n#http://website.com/abcd?param1&param2匹配\n#http://website.com/abcd/ 不匹配，不能匹配正则表达式\n#http://website.com/abcde 不匹配，不能匹配正则表达式\n```\n\n&#x20;以下表格   \\~ 代表自己输入的英文字母\n\n|  匹配符  |     匹配规则     | 优先级 |\n| :---: | :----------: | :-: |\n|   =   |     精确匹配     |  1  |\n|  ^\\~  |    以某个字符开头   |  2  |\n|   \\~  |  区分大小写的匹配正则  |  3  |\n|  \\~\\* |  不区分大小写的匹配正则 |  4  |\n|  !\\~  |  区分大小写的不匹配正则 |  5  |\n| !\\~\\* | 不区分大小写的不匹配正则 |  6  |\n|   /   | 通用匹配,所有请求都匹配 |  7  |\n\n**\t前缀匹配下，返回最长匹配的 location，与 location 所在位置顺序无关**\n\n\n\n```bash\n\tserver {\n    server_name website.com;\n\t#前缀匹配\n    location /doc {\n        return 702;\n    }\n    location /docu {\n        return 701;\n    }\n}\n\n# curl -I website.com:8080/document 依然返回 HTTP/1.1 701\n```\n\n\n\n**\t正则匹配使用文件中的顺序，找到返回**\n\n```bash\nserver {\n\tlisten 8080;\n\tserver_name website.com;\n\n    location ~ ^/doc[a-z]+ {\n        return 701;\n    }\n\n    location ~ ^/docu[a-z]+ {\n        return 702;\n    }\n}\n\n# curl -I website.com:8080/document 返回 HTTP/1.1 701\n\nserver {\n\tlisten 8080;\n\tserver_name website.com;\n\n    location ~ ^/docu[a-z]+ {\n        return 702;\n    }\n    \n    location ~ ^/doc[a-z]+ {\n        return 701;\n    }\n}\n\n# curl -I website.com:8080/document 返回 HTTP/1.1 702\n```\n\n所以当有多个匹配时匹配优先级如下\n\n**先精确匹配，没有则查找带有 `^~`的前缀匹配，没有则进行正则匹配，最后才返回前缀匹配的结果**\n\n```bash\nlocation = / {\n# 仅仅匹配请求 /\n[ configuration A ]\n}\n \nlocation / {\n# 匹配所有以 / 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。如果有正则表达式可以匹配，则\n# 优先匹配正则表达式。\n[ configuration B ]\n}\n \nlocation /documents/ {\n# 匹配所有以 /documents/ 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。\n#如果有正则表达式可以匹配，则优先匹配正则表达式。\n[ configuration C ]\n}\n \nlocation ^~ /images/ {\n# 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找。所以，即便有符合的正则表达式location，也\n# 不会被使用\n[ configuration D ]\n}\n \nlocation ~* \\.(gif|jpg|jpeg)$ {\n# 匹配所有以 gif jpg jpeg结尾的请求。但是 以 /images/开头的请求，将使用 Configuration D\n[ configuration E ]\n}\n\n\n###########请求\n/ -> configuration A\n/index.html -> configuration B\n/documents/document.html -> configuration C\n/images/1.gif -> configuration D\n/documents/1.jpg -> configuration E\n\n```\n\n","source":"_posts/Nginx 入门 server块 书写之 location 规则 （一）.md","raw":"\n---\ntitle: Nginx 入门 server块 书写之 location 规则 （一）\ntag: Nginx\ndate: 2023-4-9 02:17:00\n---\n\n\n\n#  Nginx 入门 server块 书写之 location 规则 （一）\n\n一个高性能的支持高并发的Web服务器，代理服务器\n\n1.  反向代理\n2.  负载均衡\n3.  Web服务器\n4.  安全校验，接口限流\n\n#### 处理请求\n\n```bash\nserver {            \t\t\t\t\t\t# 第一个Server区块开始，表示一个独立的虚拟主机站点\n        listen       80；      \t\t\t\t\t# 提供服务的端口，默认80\n        server_name  localhost；       \t\t\t# 提供服务的域名主机名\n        location / {            \t\t\t\t# 第一个location区块开始\n            root   html；       \t\t\t\t# 站点的根目录，相当于Nginx的安装目录\n            index  index.html index.htm；      \t# 默认的首页文件，多个用空格分开\n        }          \t\t\t\t\t\t\t\t# 第一个location区块结果\n}\n```\n\n接受请求后会通过listen 以及 server\\_name 来匹配server模块，然后根据location匹配路径资源，一个典型的应用就是一个二级域名下的子域名全部代理到同一个端口\n\n```bash\nserver {            \t\t\t\t\t\t# 第一个Server区块开始，表示一个独立的虚拟主机站点\n        listen       80；      \t\t\t\t\t# 提供服务的端口，默认80\n        server_name  demo1.aaa.com；       \t\t\t# 提供服务的域名主机名\n        location / {            \t\t\t\t# 第一个location区块开始\n            root   html1；       \t\t\t\t# 站点的根目录，相当于Nginx的安装目录\n            index  index.html index.htm；      \t# 默认的首页文件，多个用空格分开\n        }          \t\t\t\t\t\t\t\t# 第一个location区块结果\n}\nserver {            \t\t\t\t\t\t# 第一个Server区块开始，表示一个独立的虚拟主机站点\n        listen       80；      \t\t\t\t\t# 提供服务的端口，默认80\n        server_name  demo2.aaa.com；       \t\t\t# 提供服务的域名主机名\n        location / {            \t\t\t\t# 第一个location区块开始\n            root   html2；       \t\t\t\t# 站点的根目录，相当于Nginx的安装目录\n            index  index.html index.htm；      \t# 默认的首页文件，多个用空格分开\n        }          \t\t\t\t\t\t\t\t# 第一个location区块结果\n}\n```\n\n#### location语法\n\n##### 先说alias 和 root 的区别\n\n```bash\nlocation /img/ {\n\talias /var/www/image/;\n}\n#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件\nlocation /img/ {\n\troot /var/www/image;\n}\n#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件\n```\n\n所以使用alias 最后一定是 以 / 结尾 .\n\n##### 修饰符匹配\n\n```bash\nserver {\n    server_name website.com;\n    location = /abcd {\n    […]\n    }\n}\n\n#  `http://website.com/abcd`**匹配**\n#  `http://website.com/ABCD`**可能会匹配** ，也可以不匹配，取决于操作系统的文件系统是否大小写敏感（case-sensitive）。ps: Mac 默认是大小写不敏感的\n#  `http://website.com/abcd?param1&param2`**匹配**，忽略 querystring\n#  `http://website.com/abcd/`**不匹配**，带有结尾的`/`\n#  `http://website.com/abcde`**不匹配**\n```\n\n```bash\nserver {\n    server_name website.com;\n    location ~ ^/abcd$ {\n    […]\n    }\n}\n\n# ^/abcd$这个正则表达式表示字符串必须以/开始，以$结束，中间必须是abcd\n#区分大小写的正则匹配\n#http://website.com/abcd匹配（完全匹配）\n#http://website.com/ABCD不匹配，大小写敏感\n#http://website.com/abcd?param1&param2匹配\n#http://website.com/abcd/不匹配，不能匹配正则表达式\n#http://website.com/abcde不匹配，不能匹配正则表达式\n```\n\n```bash\nserver {\n    server_name website.com;\n    location ~* ^/abcd$ {\n    […]\n    }\n}\n#不区分大小写的正则匹配\n#http://website.com/abcd匹配 (完全匹配)\n#http://website.com/ABCD匹配 (大小写不敏感)\n#http://website.com/abcd?param1&param2匹配\n#http://website.com/abcd/ 不匹配，不能匹配正则表达式\n#http://website.com/abcde 不匹配，不能匹配正则表达式\n```\n\n&#x20;以下表格   \\~ 代表自己输入的英文字母\n\n|  匹配符  |     匹配规则     | 优先级 |\n| :---: | :----------: | :-: |\n|   =   |     精确匹配     |  1  |\n|  ^\\~  |    以某个字符开头   |  2  |\n|   \\~  |  区分大小写的匹配正则  |  3  |\n|  \\~\\* |  不区分大小写的匹配正则 |  4  |\n|  !\\~  |  区分大小写的不匹配正则 |  5  |\n| !\\~\\* | 不区分大小写的不匹配正则 |  6  |\n|   /   | 通用匹配,所有请求都匹配 |  7  |\n\n**\t前缀匹配下，返回最长匹配的 location，与 location 所在位置顺序无关**\n\n\n\n```bash\n\tserver {\n    server_name website.com;\n\t#前缀匹配\n    location /doc {\n        return 702;\n    }\n    location /docu {\n        return 701;\n    }\n}\n\n# curl -I website.com:8080/document 依然返回 HTTP/1.1 701\n```\n\n\n\n**\t正则匹配使用文件中的顺序，找到返回**\n\n```bash\nserver {\n\tlisten 8080;\n\tserver_name website.com;\n\n    location ~ ^/doc[a-z]+ {\n        return 701;\n    }\n\n    location ~ ^/docu[a-z]+ {\n        return 702;\n    }\n}\n\n# curl -I website.com:8080/document 返回 HTTP/1.1 701\n\nserver {\n\tlisten 8080;\n\tserver_name website.com;\n\n    location ~ ^/docu[a-z]+ {\n        return 702;\n    }\n    \n    location ~ ^/doc[a-z]+ {\n        return 701;\n    }\n}\n\n# curl -I website.com:8080/document 返回 HTTP/1.1 702\n```\n\n所以当有多个匹配时匹配优先级如下\n\n**先精确匹配，没有则查找带有 `^~`的前缀匹配，没有则进行正则匹配，最后才返回前缀匹配的结果**\n\n```bash\nlocation = / {\n# 仅仅匹配请求 /\n[ configuration A ]\n}\n \nlocation / {\n# 匹配所有以 / 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。如果有正则表达式可以匹配，则\n# 优先匹配正则表达式。\n[ configuration B ]\n}\n \nlocation /documents/ {\n# 匹配所有以 /documents/ 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。\n#如果有正则表达式可以匹配，则优先匹配正则表达式。\n[ configuration C ]\n}\n \nlocation ^~ /images/ {\n# 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找。所以，即便有符合的正则表达式location，也\n# 不会被使用\n[ configuration D ]\n}\n \nlocation ~* \\.(gif|jpg|jpeg)$ {\n# 匹配所有以 gif jpg jpeg结尾的请求。但是 以 /images/开头的请求，将使用 Configuration D\n[ configuration E ]\n}\n\n\n###########请求\n/ -> configuration A\n/index.html -> configuration B\n/documents/document.html -> configuration C\n/images/1.gif -> configuration D\n/documents/1.jpg -> configuration E\n\n```\n\n","slug":"Nginx 入门 server块 书写之 location 规则 （一）","published":1,"updated":"2024-01-28T14:48:20.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrxrizt10004b4tn0q06bk9q","content":"<h1 id=\"Nginx-入门-server块-书写之-location-规则-（一）\"><a href=\"#Nginx-入门-server块-书写之-location-规则-（一）\" class=\"headerlink\" title=\"Nginx 入门 server块 书写之 location 规则 （一）\"></a>Nginx 入门 server块 书写之 location 规则 （一）</h1><p>一个高性能的支持高并发的Web服务器，代理服务器</p>\n<ol>\n<li> 反向代理</li>\n<li> 负载均衡</li>\n<li> Web服务器</li>\n<li> 安全校验，接口限流</li>\n</ol>\n<h4 id=\"处理请求\"><a href=\"#处理请求\" class=\"headerlink\" title=\"处理请求\"></a>处理请求</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;            \t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      \t\t\t\t\t<span class=\"hljs-comment\"># 提供服务的端口，默认80</span><br>        server_name  localhost；       \t\t\t<span class=\"hljs-comment\"># 提供服务的域名主机名</span><br>        location / &#123;            \t\t\t\t<span class=\"hljs-comment\"># 第一个location区块开始</span><br>            root   html；       \t\t\t\t<span class=\"hljs-comment\"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      \t<span class=\"hljs-comment\"># 默认的首页文件，多个用空格分开</span><br>        &#125;          \t\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>接受请求后会通过listen 以及 server_name 来匹配server模块，然后根据location匹配路径资源，一个典型的应用就是一个二级域名下的子域名全部代理到同一个端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;            \t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      \t\t\t\t\t<span class=\"hljs-comment\"># 提供服务的端口，默认80</span><br>        server_name  demo1.aaa.com；       \t\t\t<span class=\"hljs-comment\"># 提供服务的域名主机名</span><br>        location / &#123;            \t\t\t\t<span class=\"hljs-comment\"># 第一个location区块开始</span><br>            root   html1；       \t\t\t\t<span class=\"hljs-comment\"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      \t<span class=\"hljs-comment\"># 默认的首页文件，多个用空格分开</span><br>        &#125;          \t\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个location区块结果</span><br>&#125;<br>server &#123;            \t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      \t\t\t\t\t<span class=\"hljs-comment\"># 提供服务的端口，默认80</span><br>        server_name  demo2.aaa.com；       \t\t\t<span class=\"hljs-comment\"># 提供服务的域名主机名</span><br>        location / &#123;            \t\t\t\t<span class=\"hljs-comment\"># 第一个location区块开始</span><br>            root   html2；       \t\t\t\t<span class=\"hljs-comment\"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      \t<span class=\"hljs-comment\"># 默认的首页文件，多个用空格分开</span><br>        &#125;          \t\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"location语法\"><a href=\"#location语法\" class=\"headerlink\" title=\"location语法\"></a>location语法</h4><h5 id=\"先说alias-和-root-的区别\"><a href=\"#先说alias-和-root-的区别\" class=\"headerlink\" title=\"先说alias 和 root 的区别\"></a>先说alias 和 root 的区别</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location /img/ &#123;<br>\t<span class=\"hljs-built_in\">alias</span> /var/www/image/;<br>&#125;<br><span class=\"hljs-comment\">#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件</span><br>location /img/ &#123;<br>\troot /var/www/image;<br>&#125;<br><span class=\"hljs-comment\">#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件</span><br></code></pre></td></tr></table></figure>\n\n<p>所以使用alias 最后一定是 以 / 结尾 .</p>\n<h5 id=\"修饰符匹配\"><a href=\"#修饰符匹配\" class=\"headerlink\" title=\"修饰符匹配\"></a>修饰符匹配</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>    server_name website.com;<br>    location = /abcd &#123;<br>    […]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">#  `http://website.com/abcd`**匹配**</span><br><span class=\"hljs-comment\">#  `http://website.com/ABCD`**可能会匹配** ，也可以不匹配，取决于操作系统的文件系统是否大小写敏感（case-sensitive）。ps: Mac 默认是大小写不敏感的</span><br><span class=\"hljs-comment\">#  `http://website.com/abcd?param1&amp;param2`**匹配**，忽略 querystring</span><br><span class=\"hljs-comment\">#  `http://website.com/abcd/`**不匹配**，带有结尾的`/`</span><br><span class=\"hljs-comment\">#  `http://website.com/abcde`**不匹配**</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>    server_name website.com;<br>    location ~ ^/abcd$ &#123;<br>    […]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># ^/abcd$这个正则表达式表示字符串必须以/开始，以$结束，中间必须是abcd</span><br><span class=\"hljs-comment\">#区分大小写的正则匹配</span><br><span class=\"hljs-comment\">#http://website.com/abcd匹配（完全匹配）</span><br><span class=\"hljs-comment\">#http://website.com/ABCD不匹配，大小写敏感</span><br><span class=\"hljs-comment\">#http://website.com/abcd?param1&amp;param2匹配</span><br><span class=\"hljs-comment\">#http://website.com/abcd/不匹配，不能匹配正则表达式</span><br><span class=\"hljs-comment\">#http://website.com/abcde不匹配，不能匹配正则表达式</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>    server_name website.com;<br>    location ~* ^/abcd$ &#123;<br>    […]<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">#不区分大小写的正则匹配</span><br><span class=\"hljs-comment\">#http://website.com/abcd匹配 (完全匹配)</span><br><span class=\"hljs-comment\">#http://website.com/ABCD匹配 (大小写不敏感)</span><br><span class=\"hljs-comment\">#http://website.com/abcd?param1&amp;param2匹配</span><br><span class=\"hljs-comment\">#http://website.com/abcd/ 不匹配，不能匹配正则表达式</span><br><span class=\"hljs-comment\">#http://website.com/abcde 不匹配，不能匹配正则表达式</span><br></code></pre></td></tr></table></figure>\n\n<p>&#x20;以下表格   ~ 代表自己输入的英文字母</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">匹配符</th>\n<th align=\"center\">匹配规则</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">=</td>\n<td align=\"center\">精确匹配</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">^~</td>\n<td align=\"center\">以某个字符开头</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">~</td>\n<td align=\"center\">区分大小写的匹配正则</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">~*</td>\n<td align=\"center\">不区分大小写的匹配正则</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">!~</td>\n<td align=\"center\">区分大小写的不匹配正则</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"center\">!~*</td>\n<td align=\"center\">不区分大小写的不匹配正则</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td align=\"center\">/</td>\n<td align=\"center\">通用匹配,所有请求都匹配</td>\n<td align=\"center\">7</td>\n</tr>\n</tbody></table>\n<p>**    前缀匹配下，返回最长匹配的 location，与 location 所在位置顺序无关**</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">\tserver &#123;<br>    server_name website.com;<br>\t<span class=\"hljs-comment\">#前缀匹配</span><br>    location /doc &#123;<br>        <span class=\"hljs-built_in\">return</span> 702;<br>    &#125;<br>    location /docu &#123;<br>        <span class=\"hljs-built_in\">return</span> 701;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># curl -I website.com:8080/document 依然返回 HTTP/1.1 701</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>**    正则匹配使用文件中的顺序，找到返回**</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>\tlisten 8080;<br>\tserver_name website.com;<br><br>    location ~ ^/doc[a-z]+ &#123;<br>        <span class=\"hljs-built_in\">return</span> 701;<br>    &#125;<br><br>    location ~ ^/docu[a-z]+ &#123;<br>        <span class=\"hljs-built_in\">return</span> 702;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># curl -I website.com:8080/document 返回 HTTP/1.1 701</span><br><br>server &#123;<br>\tlisten 8080;<br>\tserver_name website.com;<br><br>    location ~ ^/docu[a-z]+ &#123;<br>        <span class=\"hljs-built_in\">return</span> 702;<br>    &#125;<br>    <br>    location ~ ^/doc[a-z]+ &#123;<br>        <span class=\"hljs-built_in\">return</span> 701;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># curl -I website.com:8080/document 返回 HTTP/1.1 702</span><br></code></pre></td></tr></table></figure>\n\n<p>所以当有多个匹配时匹配优先级如下</p>\n<p><strong>先精确匹配，没有则查找带有 <code>^~</code>的前缀匹配，没有则进行正则匹配，最后才返回前缀匹配的结果</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location = / &#123;<br><span class=\"hljs-comment\"># 仅仅匹配请求 /</span><br>[ configuration A ]<br>&#125;<br> <br>location / &#123;<br><span class=\"hljs-comment\"># 匹配所有以 / 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。如果有正则表达式可以匹配，则</span><br><span class=\"hljs-comment\"># 优先匹配正则表达式。</span><br>[ configuration B ]<br>&#125;<br> <br>location /documents/ &#123;<br><span class=\"hljs-comment\"># 匹配所有以 /documents/ 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。</span><br><span class=\"hljs-comment\">#如果有正则表达式可以匹配，则优先匹配正则表达式。</span><br>[ configuration C ]<br>&#125;<br> <br>location ^~ /images/ &#123;<br><span class=\"hljs-comment\"># 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找。所以，即便有符合的正则表达式location，也</span><br><span class=\"hljs-comment\"># 不会被使用</span><br>[ configuration D ]<br>&#125;<br> <br>location ~* \\.(gif|jpg|jpeg)$ &#123;<br><span class=\"hljs-comment\"># 匹配所有以 gif jpg jpeg结尾的请求。但是 以 /images/开头的请求，将使用 Configuration D</span><br>[ configuration E ]<br>&#125;<br><br><br><span class=\"hljs-comment\">###########请求</span><br>/ -&gt; configuration A<br>/index.html -&gt; configuration B<br>/documents/document.html -&gt; configuration C<br>/images/1.gif -&gt; configuration D<br>/documents/1.jpg -&gt; configuration E<br><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Nginx-入门-server块-书写之-location-规则-（一）\"><a href=\"#Nginx-入门-server块-书写之-location-规则-（一）\" class=\"headerlink\" title=\"Nginx 入门 server块 书写之 location 规则 （一）\"></a>Nginx 入门 server块 书写之 location 规则 （一）</h1><p>一个高性能的支持高并发的Web服务器，代理服务器</p>\n<ol>\n<li> 反向代理</li>\n<li> 负载均衡</li>\n<li> Web服务器</li>\n<li> 安全校验，接口限流</li>\n</ol>\n<h4 id=\"处理请求\"><a href=\"#处理请求\" class=\"headerlink\" title=\"处理请求\"></a>处理请求</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;            \t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      \t\t\t\t\t<span class=\"hljs-comment\"># 提供服务的端口，默认80</span><br>        server_name  localhost；       \t\t\t<span class=\"hljs-comment\"># 提供服务的域名主机名</span><br>        location / &#123;            \t\t\t\t<span class=\"hljs-comment\"># 第一个location区块开始</span><br>            root   html；       \t\t\t\t<span class=\"hljs-comment\"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      \t<span class=\"hljs-comment\"># 默认的首页文件，多个用空格分开</span><br>        &#125;          \t\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>接受请求后会通过listen 以及 server_name 来匹配server模块，然后根据location匹配路径资源，一个典型的应用就是一个二级域名下的子域名全部代理到同一个端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;            \t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      \t\t\t\t\t<span class=\"hljs-comment\"># 提供服务的端口，默认80</span><br>        server_name  demo1.aaa.com；       \t\t\t<span class=\"hljs-comment\"># 提供服务的域名主机名</span><br>        location / &#123;            \t\t\t\t<span class=\"hljs-comment\"># 第一个location区块开始</span><br>            root   html1；       \t\t\t\t<span class=\"hljs-comment\"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      \t<span class=\"hljs-comment\"># 默认的首页文件，多个用空格分开</span><br>        &#125;          \t\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个location区块结果</span><br>&#125;<br>server &#123;            \t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br>        listen       80；      \t\t\t\t\t<span class=\"hljs-comment\"># 提供服务的端口，默认80</span><br>        server_name  demo2.aaa.com；       \t\t\t<span class=\"hljs-comment\"># 提供服务的域名主机名</span><br>        location / &#123;            \t\t\t\t<span class=\"hljs-comment\"># 第一个location区块开始</span><br>            root   html2；       \t\t\t\t<span class=\"hljs-comment\"># 站点的根目录，相当于Nginx的安装目录</span><br>            index  index.html index.htm；      \t<span class=\"hljs-comment\"># 默认的首页文件，多个用空格分开</span><br>        &#125;          \t\t\t\t\t\t\t\t<span class=\"hljs-comment\"># 第一个location区块结果</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"location语法\"><a href=\"#location语法\" class=\"headerlink\" title=\"location语法\"></a>location语法</h4><h5 id=\"先说alias-和-root-的区别\"><a href=\"#先说alias-和-root-的区别\" class=\"headerlink\" title=\"先说alias 和 root 的区别\"></a>先说alias 和 root 的区别</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location /img/ &#123;<br>\t<span class=\"hljs-built_in\">alias</span> /var/www/image/;<br>&#125;<br><span class=\"hljs-comment\">#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件</span><br>location /img/ &#123;<br>\troot /var/www/image;<br>&#125;<br><span class=\"hljs-comment\">#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件</span><br></code></pre></td></tr></table></figure>\n\n<p>所以使用alias 最后一定是 以 / 结尾 .</p>\n<h5 id=\"修饰符匹配\"><a href=\"#修饰符匹配\" class=\"headerlink\" title=\"修饰符匹配\"></a>修饰符匹配</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>    server_name website.com;<br>    location = /abcd &#123;<br>    […]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">#  `http://website.com/abcd`**匹配**</span><br><span class=\"hljs-comment\">#  `http://website.com/ABCD`**可能会匹配** ，也可以不匹配，取决于操作系统的文件系统是否大小写敏感（case-sensitive）。ps: Mac 默认是大小写不敏感的</span><br><span class=\"hljs-comment\">#  `http://website.com/abcd?param1&amp;param2`**匹配**，忽略 querystring</span><br><span class=\"hljs-comment\">#  `http://website.com/abcd/`**不匹配**，带有结尾的`/`</span><br><span class=\"hljs-comment\">#  `http://website.com/abcde`**不匹配**</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>    server_name website.com;<br>    location ~ ^/abcd$ &#123;<br>    […]<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># ^/abcd$这个正则表达式表示字符串必须以/开始，以$结束，中间必须是abcd</span><br><span class=\"hljs-comment\">#区分大小写的正则匹配</span><br><span class=\"hljs-comment\">#http://website.com/abcd匹配（完全匹配）</span><br><span class=\"hljs-comment\">#http://website.com/ABCD不匹配，大小写敏感</span><br><span class=\"hljs-comment\">#http://website.com/abcd?param1&amp;param2匹配</span><br><span class=\"hljs-comment\">#http://website.com/abcd/不匹配，不能匹配正则表达式</span><br><span class=\"hljs-comment\">#http://website.com/abcde不匹配，不能匹配正则表达式</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>    server_name website.com;<br>    location ~* ^/abcd$ &#123;<br>    […]<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">#不区分大小写的正则匹配</span><br><span class=\"hljs-comment\">#http://website.com/abcd匹配 (完全匹配)</span><br><span class=\"hljs-comment\">#http://website.com/ABCD匹配 (大小写不敏感)</span><br><span class=\"hljs-comment\">#http://website.com/abcd?param1&amp;param2匹配</span><br><span class=\"hljs-comment\">#http://website.com/abcd/ 不匹配，不能匹配正则表达式</span><br><span class=\"hljs-comment\">#http://website.com/abcde 不匹配，不能匹配正则表达式</span><br></code></pre></td></tr></table></figure>\n\n<p>&#x20;以下表格   ~ 代表自己输入的英文字母</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">匹配符</th>\n<th align=\"center\">匹配规则</th>\n<th align=\"center\">优先级</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">=</td>\n<td align=\"center\">精确匹配</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">^~</td>\n<td align=\"center\">以某个字符开头</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">~</td>\n<td align=\"center\">区分大小写的匹配正则</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">~*</td>\n<td align=\"center\">不区分大小写的匹配正则</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">!~</td>\n<td align=\"center\">区分大小写的不匹配正则</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"center\">!~*</td>\n<td align=\"center\">不区分大小写的不匹配正则</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td align=\"center\">/</td>\n<td align=\"center\">通用匹配,所有请求都匹配</td>\n<td align=\"center\">7</td>\n</tr>\n</tbody></table>\n<p>**    前缀匹配下，返回最长匹配的 location，与 location 所在位置顺序无关**</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">\tserver &#123;<br>    server_name website.com;<br>\t<span class=\"hljs-comment\">#前缀匹配</span><br>    location /doc &#123;<br>        <span class=\"hljs-built_in\">return</span> 702;<br>    &#125;<br>    location /docu &#123;<br>        <span class=\"hljs-built_in\">return</span> 701;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># curl -I website.com:8080/document 依然返回 HTTP/1.1 701</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>**    正则匹配使用文件中的顺序，找到返回**</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">server &#123;<br>\tlisten 8080;<br>\tserver_name website.com;<br><br>    location ~ ^/doc[a-z]+ &#123;<br>        <span class=\"hljs-built_in\">return</span> 701;<br>    &#125;<br><br>    location ~ ^/docu[a-z]+ &#123;<br>        <span class=\"hljs-built_in\">return</span> 702;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># curl -I website.com:8080/document 返回 HTTP/1.1 701</span><br><br>server &#123;<br>\tlisten 8080;<br>\tserver_name website.com;<br><br>    location ~ ^/docu[a-z]+ &#123;<br>        <span class=\"hljs-built_in\">return</span> 702;<br>    &#125;<br>    <br>    location ~ ^/doc[a-z]+ &#123;<br>        <span class=\"hljs-built_in\">return</span> 701;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\"># curl -I website.com:8080/document 返回 HTTP/1.1 702</span><br></code></pre></td></tr></table></figure>\n\n<p>所以当有多个匹配时匹配优先级如下</p>\n<p><strong>先精确匹配，没有则查找带有 <code>^~</code>的前缀匹配，没有则进行正则匹配，最后才返回前缀匹配的结果</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location = / &#123;<br><span class=\"hljs-comment\"># 仅仅匹配请求 /</span><br>[ configuration A ]<br>&#125;<br> <br>location / &#123;<br><span class=\"hljs-comment\"># 匹配所有以 / 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。如果有正则表达式可以匹配，则</span><br><span class=\"hljs-comment\"># 优先匹配正则表达式。</span><br>[ configuration B ]<br>&#125;<br> <br>location /documents/ &#123;<br><span class=\"hljs-comment\"># 匹配所有以 /documents/ 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。</span><br><span class=\"hljs-comment\">#如果有正则表达式可以匹配，则优先匹配正则表达式。</span><br>[ configuration C ]<br>&#125;<br> <br>location ^~ /images/ &#123;<br><span class=\"hljs-comment\"># 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找。所以，即便有符合的正则表达式location，也</span><br><span class=\"hljs-comment\"># 不会被使用</span><br>[ configuration D ]<br>&#125;<br> <br>location ~* \\.(gif|jpg|jpeg)$ &#123;<br><span class=\"hljs-comment\"># 匹配所有以 gif jpg jpeg结尾的请求。但是 以 /images/开头的请求，将使用 Configuration D</span><br>[ configuration E ]<br>&#125;<br><br><br><span class=\"hljs-comment\">###########请求</span><br>/ -&gt; configuration A<br>/index.html -&gt; configuration B<br>/documents/document.html -&gt; configuration C<br>/images/1.gif -&gt; configuration D<br>/documents/1.jpg -&gt; configuration E<br><br></code></pre></td></tr></table></figure>\n\n"},{"title":"WebSocket 实现聊天室","date":"2023-03-05T15:37:00.000Z","_content":"\n## WebSockect 实现聊天室\n\n**说明：最近二手交易课设有一个需求是实现 购买者和商品发布者有一个聊天对话的功能，类似于咸鱼的聊天对话功能吧。想到的就是 WebSocket 协议来实现，问了一个前端小伙伴，他一般使用 socketio(一个 websocket 框架)，我看了下也有 java 版的，但思考了下决定还是使用原生 websocket 来写前后端。**\n\n#### 什么是 websocket？\n\n这里放一个知乎的高赞回答，看完很清楚。[WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear 的回答 - 知乎](https://www.zhihu.com/question/20215561/answer/40316953)\n\n首先我们先说说大家都很了解的 Http 协议，在 B/S 开发中，我们常用这种协议来进行各种响应和处理。\n\n他的特点就是一个 Request 和 一个 Response 而且是无状态的（想要保持状态需要间接通过 session 和 cookie）。虽然在一些不那么复杂的需求下，这样的机制已经足够了，但是一些复杂的应用场景如需要一直监听某个数据的变化就显得力不从心了。当然我们也可以使用 ajax 来轮询，但这样其实是非常低效率的，你把自己想成服务器，假设有个人（客户端）一直在你耳边叨叨（数据更新了没。。。）我想你也一定要疯掉了吧。\n\n<div align=center><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/inkun.jpg\" alt=\"img\" width=\"200\"></div>\n\n其次 Http 协议的另一个特点，浏览器只能主动发送请求接收信息，不能被动接收服务器信息。这一点确实蛋疼，使得一旦数据有了变化我需要自己去请求，但是我又怎么知道数据什么时候更新了呢？\n\n然鹅，websocket 的出现就可以巧妙的解决这些问题。\n\nwebsocket 协由握手和数据传输构成\n\n握手基于 HTTP 协议，然后客户端和服务端实现长连接，所以说 websocket 和 http 是有交集的。\n\n![关系图](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230316170428.png)\n\n那么数据如何传输呢？只需要在服务端设立转发的服务，那么数据就可以实现从 A 客户端到 B 客户端的发送，拿聊天举例，正是这种长连接机制以及允许客户端主动接收服务端消息的机制使得聊天消息能够看上去好像在两个客户端建立了连接。其实就是服务器做了一次转发。\n\n#### Java 怎么写服务端的 WebSocket（SpringBoot）\n\n非常类似 Servlet，这里我们需要写**ServerEndPoint**\n\n这里我们主要重写三个方法\n\n1. onOpen(建立连接时自动调用)\n2. onMessage(接收消息时自动调用)\n3. onClose(关闭连接时自动调用)\n\n当然还有 onError 等方法\n\n```Java\n//这个 注解类似http的map ，比如说这样你的 websocket url 就是 ws：localhost/chat\n@ServerEndpoint(value = \"/chat\",configurator = GetHttpSessionConfigurator.class)\n\npublic class ChatEndPoint {\n\n\n    /**\n     *  建立连接被调\n     */\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config){\n\n\n\n    }\n\n    /**\n     * 接收数据被调用\n     */\n\n    @OnMessage\n    public void onMessage(String message,Session session){\n\n\n\n\n    }\n\n    /**\n     * 关闭连接调用\n     */\n    @OnClose\n    public void onClose(Session session){\n\n\n\n    }\n\n\n\n}\n\n```\n\n这里需要注意，上面 session 指的是 websocket 的 session，不是 http 的 session，也是用来标识每一个长连接的对象，看到这里聪明的小伙伴应该能想到实现消息转发可以用 session 来标识每一个用户。\n\n所以我们想要实现聊天消息转发可以使用 map 来存储 websocket 的 session。这里我存储 EndPoint 实例类似，因为我们可以使用 endpoint 实例来获取 session 对象，记住每一个用户进行一次 websocket 长连接，就会创建一个 endpoint 对象。\n\n```Java\n /**\n     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid\n     */\n    private static Map<String,ChatEndPoint> users = new ConcurrentHashMap<>();\n```\n\n说到这里有小伙伴想问了，项目的一些数据存储在 HttpSession 中既然 websocket 是基于 http 的，那么我能不能取出 Httpsession 在 Endpoint 里使用啊？答案是可以的，只需要在 springboot 配置中在注入对象前 ServerEndpointConfig 放入这个 httpsession 就可以了\n\n配置：\n\n```Java\n@Configuration\n\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter(){\n        return new ServerEndpointExporter();\n    }\n}\n\n\n\npublic class GetHttpSessionConfigurator extends ServerEndpointConfig.Configurator {\n    @Override\n    public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {\n        HttpSession httpSession = (HttpSession)request.getHttpSession();\n\n        //将httpsession存到配置对象\n\n        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);\n    }\n}\n\n@ServerEndpoint(value = \"/chat\",configurator = GetHttpSessionConfigurator.class)\n\n```\n\n获取：\n\n```Java\n @OnOpen\n    public void onOpen(Session session, EndpointConfig config){\n\n        this.session = session;\n\n        //获取Httpssion\n\n       HttpSession httpSession = (HttpSession) \tconfig.getUserProperties().get(HttpSession.class.getName());\n       }\n```\n\n#### 前端怎么写 WebSocket\n\n前端其实也类似，写起来更简单，只需要 new 一个 websocket 对象就能够实现连接。\n\n```Typescript\nlet ws: any = null;\n\nexport default {\n\t//连接\n  connect() {\n    ws = new WebSocket('ws://localhost:8081/api/chat');\n  },\n\t//获取实例\n  getWs() {\n    return ws;\n  },\n  //关闭连接，删除实例\n\n  removeWs() {\n    ws.close();\n  },\n};\n\n```\n\n```Typescript\n \t//调用方法\n \tws.connect();\n\n    ws.getWs().onopen = function () {\n\n    };\n\n    ws.getWs().onmessage = function (evt) {\n    }\n    ws.getWs().onclose = function () {\n\n    };\n```\n\n#### 聊天怎么实现\n\n思路\n\n1.  每一个客户端与服务端建立连接就将 EndPoint 实例存入 userHashMap（这里使用静态的）中。\n2.  客户端断开连接，就将此用户从 userHashMap 去除，所以 userHashMap 始终存储在线用户\n3.  客户端发消息，消息内容需要有发消息人，收消息人，内容，时间，封装成一个对象。\n4.  服务端 onmessage 接收到就检查用户里 userHashMap 有没有此人（有表示在线），有就找到 session 直接转发给他，没有需要暂时存储到 chatsHashMap，存消息列表 。\n5.  那么我们还要修改 1 步骤，这里连接上就要检查 chatsHashMap 有没有自己的消息，有就转发给自己并去除 chatsHashMap 的消息，这样一来就实现了离线和在线用户的聊天功能。\n\n后端全部代码：\n\n```java\n\n@Component\n@ServerEndpoint(value = \"/chat\",configurator = GetHttpSessionConfigurator.class)\n\npublic class ChatEndPoint {\n\n\n    /**\n     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid\n     */\n    private static Map<String,ChatEndPoint> users = new ConcurrentHashMap<>();\n\n    /**\n     *  用来存储每个客户端对象对应的聊天记录 key 是uid value 是json\n     */\n\n    private static Map<String, ArrayList<String>> chats = new ConcurrentHashMap<>();\n\n    /**\n     * websocket session\n     */\n\n    private  Session session;\n\n\n    /**\n     * httpsession\n     */\n    private HttpSession httpSession;\n\n\n\n    /**\n     *  建立连接被调\n     */\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config){\n\n        this.session = session;\n\n        //获取Httpssion\n\n       HttpSession httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n\n       this.httpSession = httpSession;\n\n\n       User user = (User)httpSession.getAttribute(USER_LOGIN_STATE);\n\n\n\n        // 将当前对象存储在 容器中 key为uid\n\n        String uid = String.valueOf(user.getUid());\n\n       users.put(uid,this);\n\n       // 判断并建立 暂存 聊天记录的数据结构\n\n       if(!chats.containsKey(uid)) {\n\n           ArrayList<String> arr = new ArrayList<>();\n           System.out.println(uid+\"调用了一次\");\n           chats.put(uid,arr);\n\n       }\n        String message = MessageUtils.getMessage(true, null,null,null, getUsers());\n\n        System.out.println(message);\n        //连接就一条广播\n        broadcastAllUsers(MessageUtils.getMessage(true, null, null,null,\"当前在线用户人数：\"+users.size()+\"人\"));\n        broadcastAllUsers(message);\n\n        //获取该用户暂存离线消息并推送\n\n        ArrayList<String> chatCache = chats.get(uid);\n\n\n        for(String chat:chatCache){\n//            ChatEndPoint chatEndPoint = users.get(uid);\n//            System.out.println(chat);\n            try {\n                this.session.getBasicRemote().sendText(chat);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        chats.remove(uid);\n\n\n    }\n\n    /**\n     * 获取容器里的用户\n     * @return\n     */\n    private Set<String> getUsers(){\n\n        return ChatEndPoint.users.keySet();\n\n    }\n\n    /**\n     * 推送所有客户端\n     */\n\n    private void broadcastAllUsers(String message){\n\n        Set<String> usersSet = users.keySet();\n            try {\n\n                for (String user : usersSet) {\n                    ChatEndPoint chatEndPoint = users.get(user);\n                    chatEndPoint.session.getBasicRemote().sendText(message);\n                }} catch(IOException e){\n                    e.printStackTrace();\n                }\n\n\n            }\n\n\n\n\n    /**\n     * 接收数据被调用\n     */\n\n    @OnMessage\n    public void onMessage(String message,Session session){\n\n\n        ObjectMapper mapper = new ObjectMapper();\n        try {\n            Message mess = mapper.readValue(message, Message.class);\n\n//            System.out.println(mess);\n// 消息的接收者\n            String toUid = mess.getToUid();\n\n            ChatEndPoint chatEndPoint = users.get(toUid);\n\n            User user = (User)httpSession.getAttribute(USER_LOGIN_STATE);\n\n\n\n            if(chatEndPoint!=null){\n\n                // 接收用户在线直接转发\n\n\n\n                if(user==null){\n\n                    throw new BusinessException(ErrorCode.LOGIN_ERROR);\n                }\n\n                String message1 = MessageUtils.getMessage(false, user.getUserName(), user.getUid(),user.getPhone(), mess);\n\n                chatEndPoint.session.getBasicRemote().sendText(message1);\n\n\n\n            }else{\n\n                //接收用户不在线 先暂时存储消息\n\n                ArrayList<String> messages = chats.get(toUid);\n\n                if(messages == null){\n                    messages = new ArrayList<>();\n                    chats.put(toUid,messages);\n\n                }\n\n                //存的就是json\n                messages.add(MessageUtils.getMessage(false, user.getUserName(), user.getUid(),user.getPhone(), mess));\n\n\n\n            }\n\n\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n    /**\n     * 关闭连接调用\n     */\n    @OnClose\n    public void onClose(Session session){\n\n\n        User user = (User)httpSession.getAttribute(USER_LOGIN_STATE);\n\n        users.remove(user.getUid().toString());\n\n        System.out.println(user.getUserName()+\"下线了，当前在线人数：\"+users.size()+\"人\");\n\n\n\n    }\n\n    /**\n     * 获取当前时间戳，秒\n     */\n    private String getUnix(){\n\n        long time = System.currentTimeMillis();\n\n\n        time = time / 1000;\n\n        return String.valueOf(time);\n\n    }\n\n\n}\n\n```\n\n前端接收怎么存储呢？我暂时只想到存储在 sessionStorage 或者 localStorage 中，但这部分数据存储需要考虑去重和数据对应每个用户，不要疏忽了让别的用户看到了不属于自己的对话内容，那就出大问题了。整体思路挺简单的就是要细心。\n\n#### 实现展示\n\n![image-20221125171042690](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171042690.png)\n\n![image-20221125171211620](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171211620.png)\n\n![image-20221125171244569](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171244569.png)\n\n组件采用的是 react-jwchat 感觉挺好看的，各项功能都正常，就是有时候会 websocket 连接了就断开了，猜测是没写 error 处理吧。\n\n#### 写在最后\n\n最后看我的二手交易系统的前后端源码（websocket 源码也在里面）\n\n[react-jwchat 聊天组件](https://gitee.com/wx_504ae56474/react-jwchat)\n\n[二手交易系统前端](https://gitee.com/yilinyo/lkd-javee-trade-frontend)\n\n[二手交易系统后端](https://gitee.com/yilinyo/lkd-javaee-trade-backend)\n","source":"_posts/WebSocket 实现聊天室.md","raw":"---\ntitle: WebSocket 实现聊天室\ntag: 项目\ndate: 2023-3-5 23:37:00\n---\n\n## WebSockect 实现聊天室\n\n**说明：最近二手交易课设有一个需求是实现 购买者和商品发布者有一个聊天对话的功能，类似于咸鱼的聊天对话功能吧。想到的就是 WebSocket 协议来实现，问了一个前端小伙伴，他一般使用 socketio(一个 websocket 框架)，我看了下也有 java 版的，但思考了下决定还是使用原生 websocket 来写前后端。**\n\n#### 什么是 websocket？\n\n这里放一个知乎的高赞回答，看完很清楚。[WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear 的回答 - 知乎](https://www.zhihu.com/question/20215561/answer/40316953)\n\n首先我们先说说大家都很了解的 Http 协议，在 B/S 开发中，我们常用这种协议来进行各种响应和处理。\n\n他的特点就是一个 Request 和 一个 Response 而且是无状态的（想要保持状态需要间接通过 session 和 cookie）。虽然在一些不那么复杂的需求下，这样的机制已经足够了，但是一些复杂的应用场景如需要一直监听某个数据的变化就显得力不从心了。当然我们也可以使用 ajax 来轮询，但这样其实是非常低效率的，你把自己想成服务器，假设有个人（客户端）一直在你耳边叨叨（数据更新了没。。。）我想你也一定要疯掉了吧。\n\n<div align=center><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/inkun.jpg\" alt=\"img\" width=\"200\"></div>\n\n其次 Http 协议的另一个特点，浏览器只能主动发送请求接收信息，不能被动接收服务器信息。这一点确实蛋疼，使得一旦数据有了变化我需要自己去请求，但是我又怎么知道数据什么时候更新了呢？\n\n然鹅，websocket 的出现就可以巧妙的解决这些问题。\n\nwebsocket 协由握手和数据传输构成\n\n握手基于 HTTP 协议，然后客户端和服务端实现长连接，所以说 websocket 和 http 是有交集的。\n\n![关系图](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230316170428.png)\n\n那么数据如何传输呢？只需要在服务端设立转发的服务，那么数据就可以实现从 A 客户端到 B 客户端的发送，拿聊天举例，正是这种长连接机制以及允许客户端主动接收服务端消息的机制使得聊天消息能够看上去好像在两个客户端建立了连接。其实就是服务器做了一次转发。\n\n#### Java 怎么写服务端的 WebSocket（SpringBoot）\n\n非常类似 Servlet，这里我们需要写**ServerEndPoint**\n\n这里我们主要重写三个方法\n\n1. onOpen(建立连接时自动调用)\n2. onMessage(接收消息时自动调用)\n3. onClose(关闭连接时自动调用)\n\n当然还有 onError 等方法\n\n```Java\n//这个 注解类似http的map ，比如说这样你的 websocket url 就是 ws：localhost/chat\n@ServerEndpoint(value = \"/chat\",configurator = GetHttpSessionConfigurator.class)\n\npublic class ChatEndPoint {\n\n\n    /**\n     *  建立连接被调\n     */\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config){\n\n\n\n    }\n\n    /**\n     * 接收数据被调用\n     */\n\n    @OnMessage\n    public void onMessage(String message,Session session){\n\n\n\n\n    }\n\n    /**\n     * 关闭连接调用\n     */\n    @OnClose\n    public void onClose(Session session){\n\n\n\n    }\n\n\n\n}\n\n```\n\n这里需要注意，上面 session 指的是 websocket 的 session，不是 http 的 session，也是用来标识每一个长连接的对象，看到这里聪明的小伙伴应该能想到实现消息转发可以用 session 来标识每一个用户。\n\n所以我们想要实现聊天消息转发可以使用 map 来存储 websocket 的 session。这里我存储 EndPoint 实例类似，因为我们可以使用 endpoint 实例来获取 session 对象，记住每一个用户进行一次 websocket 长连接，就会创建一个 endpoint 对象。\n\n```Java\n /**\n     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid\n     */\n    private static Map<String,ChatEndPoint> users = new ConcurrentHashMap<>();\n```\n\n说到这里有小伙伴想问了，项目的一些数据存储在 HttpSession 中既然 websocket 是基于 http 的，那么我能不能取出 Httpsession 在 Endpoint 里使用啊？答案是可以的，只需要在 springboot 配置中在注入对象前 ServerEndpointConfig 放入这个 httpsession 就可以了\n\n配置：\n\n```Java\n@Configuration\n\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter(){\n        return new ServerEndpointExporter();\n    }\n}\n\n\n\npublic class GetHttpSessionConfigurator extends ServerEndpointConfig.Configurator {\n    @Override\n    public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {\n        HttpSession httpSession = (HttpSession)request.getHttpSession();\n\n        //将httpsession存到配置对象\n\n        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);\n    }\n}\n\n@ServerEndpoint(value = \"/chat\",configurator = GetHttpSessionConfigurator.class)\n\n```\n\n获取：\n\n```Java\n @OnOpen\n    public void onOpen(Session session, EndpointConfig config){\n\n        this.session = session;\n\n        //获取Httpssion\n\n       HttpSession httpSession = (HttpSession) \tconfig.getUserProperties().get(HttpSession.class.getName());\n       }\n```\n\n#### 前端怎么写 WebSocket\n\n前端其实也类似，写起来更简单，只需要 new 一个 websocket 对象就能够实现连接。\n\n```Typescript\nlet ws: any = null;\n\nexport default {\n\t//连接\n  connect() {\n    ws = new WebSocket('ws://localhost:8081/api/chat');\n  },\n\t//获取实例\n  getWs() {\n    return ws;\n  },\n  //关闭连接，删除实例\n\n  removeWs() {\n    ws.close();\n  },\n};\n\n```\n\n```Typescript\n \t//调用方法\n \tws.connect();\n\n    ws.getWs().onopen = function () {\n\n    };\n\n    ws.getWs().onmessage = function (evt) {\n    }\n    ws.getWs().onclose = function () {\n\n    };\n```\n\n#### 聊天怎么实现\n\n思路\n\n1.  每一个客户端与服务端建立连接就将 EndPoint 实例存入 userHashMap（这里使用静态的）中。\n2.  客户端断开连接，就将此用户从 userHashMap 去除，所以 userHashMap 始终存储在线用户\n3.  客户端发消息，消息内容需要有发消息人，收消息人，内容，时间，封装成一个对象。\n4.  服务端 onmessage 接收到就检查用户里 userHashMap 有没有此人（有表示在线），有就找到 session 直接转发给他，没有需要暂时存储到 chatsHashMap，存消息列表 。\n5.  那么我们还要修改 1 步骤，这里连接上就要检查 chatsHashMap 有没有自己的消息，有就转发给自己并去除 chatsHashMap 的消息，这样一来就实现了离线和在线用户的聊天功能。\n\n后端全部代码：\n\n```java\n\n@Component\n@ServerEndpoint(value = \"/chat\",configurator = GetHttpSessionConfigurator.class)\n\npublic class ChatEndPoint {\n\n\n    /**\n     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid\n     */\n    private static Map<String,ChatEndPoint> users = new ConcurrentHashMap<>();\n\n    /**\n     *  用来存储每个客户端对象对应的聊天记录 key 是uid value 是json\n     */\n\n    private static Map<String, ArrayList<String>> chats = new ConcurrentHashMap<>();\n\n    /**\n     * websocket session\n     */\n\n    private  Session session;\n\n\n    /**\n     * httpsession\n     */\n    private HttpSession httpSession;\n\n\n\n    /**\n     *  建立连接被调\n     */\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config){\n\n        this.session = session;\n\n        //获取Httpssion\n\n       HttpSession httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n\n       this.httpSession = httpSession;\n\n\n       User user = (User)httpSession.getAttribute(USER_LOGIN_STATE);\n\n\n\n        // 将当前对象存储在 容器中 key为uid\n\n        String uid = String.valueOf(user.getUid());\n\n       users.put(uid,this);\n\n       // 判断并建立 暂存 聊天记录的数据结构\n\n       if(!chats.containsKey(uid)) {\n\n           ArrayList<String> arr = new ArrayList<>();\n           System.out.println(uid+\"调用了一次\");\n           chats.put(uid,arr);\n\n       }\n        String message = MessageUtils.getMessage(true, null,null,null, getUsers());\n\n        System.out.println(message);\n        //连接就一条广播\n        broadcastAllUsers(MessageUtils.getMessage(true, null, null,null,\"当前在线用户人数：\"+users.size()+\"人\"));\n        broadcastAllUsers(message);\n\n        //获取该用户暂存离线消息并推送\n\n        ArrayList<String> chatCache = chats.get(uid);\n\n\n        for(String chat:chatCache){\n//            ChatEndPoint chatEndPoint = users.get(uid);\n//            System.out.println(chat);\n            try {\n                this.session.getBasicRemote().sendText(chat);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        chats.remove(uid);\n\n\n    }\n\n    /**\n     * 获取容器里的用户\n     * @return\n     */\n    private Set<String> getUsers(){\n\n        return ChatEndPoint.users.keySet();\n\n    }\n\n    /**\n     * 推送所有客户端\n     */\n\n    private void broadcastAllUsers(String message){\n\n        Set<String> usersSet = users.keySet();\n            try {\n\n                for (String user : usersSet) {\n                    ChatEndPoint chatEndPoint = users.get(user);\n                    chatEndPoint.session.getBasicRemote().sendText(message);\n                }} catch(IOException e){\n                    e.printStackTrace();\n                }\n\n\n            }\n\n\n\n\n    /**\n     * 接收数据被调用\n     */\n\n    @OnMessage\n    public void onMessage(String message,Session session){\n\n\n        ObjectMapper mapper = new ObjectMapper();\n        try {\n            Message mess = mapper.readValue(message, Message.class);\n\n//            System.out.println(mess);\n// 消息的接收者\n            String toUid = mess.getToUid();\n\n            ChatEndPoint chatEndPoint = users.get(toUid);\n\n            User user = (User)httpSession.getAttribute(USER_LOGIN_STATE);\n\n\n\n            if(chatEndPoint!=null){\n\n                // 接收用户在线直接转发\n\n\n\n                if(user==null){\n\n                    throw new BusinessException(ErrorCode.LOGIN_ERROR);\n                }\n\n                String message1 = MessageUtils.getMessage(false, user.getUserName(), user.getUid(),user.getPhone(), mess);\n\n                chatEndPoint.session.getBasicRemote().sendText(message1);\n\n\n\n            }else{\n\n                //接收用户不在线 先暂时存储消息\n\n                ArrayList<String> messages = chats.get(toUid);\n\n                if(messages == null){\n                    messages = new ArrayList<>();\n                    chats.put(toUid,messages);\n\n                }\n\n                //存的就是json\n                messages.add(MessageUtils.getMessage(false, user.getUserName(), user.getUid(),user.getPhone(), mess));\n\n\n\n            }\n\n\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n    /**\n     * 关闭连接调用\n     */\n    @OnClose\n    public void onClose(Session session){\n\n\n        User user = (User)httpSession.getAttribute(USER_LOGIN_STATE);\n\n        users.remove(user.getUid().toString());\n\n        System.out.println(user.getUserName()+\"下线了，当前在线人数：\"+users.size()+\"人\");\n\n\n\n    }\n\n    /**\n     * 获取当前时间戳，秒\n     */\n    private String getUnix(){\n\n        long time = System.currentTimeMillis();\n\n\n        time = time / 1000;\n\n        return String.valueOf(time);\n\n    }\n\n\n}\n\n```\n\n前端接收怎么存储呢？我暂时只想到存储在 sessionStorage 或者 localStorage 中，但这部分数据存储需要考虑去重和数据对应每个用户，不要疏忽了让别的用户看到了不属于自己的对话内容，那就出大问题了。整体思路挺简单的就是要细心。\n\n#### 实现展示\n\n![image-20221125171042690](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171042690.png)\n\n![image-20221125171211620](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171211620.png)\n\n![image-20221125171244569](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171244569.png)\n\n组件采用的是 react-jwchat 感觉挺好看的，各项功能都正常，就是有时候会 websocket 连接了就断开了，猜测是没写 error 处理吧。\n\n#### 写在最后\n\n最后看我的二手交易系统的前后端源码（websocket 源码也在里面）\n\n[react-jwchat 聊天组件](https://gitee.com/wx_504ae56474/react-jwchat)\n\n[二手交易系统前端](https://gitee.com/yilinyo/lkd-javee-trade-frontend)\n\n[二手交易系统后端](https://gitee.com/yilinyo/lkd-javaee-trade-backend)\n","slug":"WebSocket 实现聊天室","published":1,"updated":"2024-01-28T14:48:20.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrxrizt30005b4tnhiil3r2o","content":"<h2 id=\"WebSockect-实现聊天室\"><a href=\"#WebSockect-实现聊天室\" class=\"headerlink\" title=\"WebSockect 实现聊天室\"></a>WebSockect 实现聊天室</h2><p><strong>说明：最近二手交易课设有一个需求是实现 购买者和商品发布者有一个聊天对话的功能，类似于咸鱼的聊天对话功能吧。想到的就是 WebSocket 协议来实现，问了一个前端小伙伴，他一般使用 socketio(一个 websocket 框架)，我看了下也有 java 版的，但思考了下决定还是使用原生 websocket 来写前后端。</strong></p>\n<h4 id=\"什么是-websocket？\"><a href=\"#什么是-websocket？\" class=\"headerlink\" title=\"什么是 websocket？\"></a>什么是 websocket？</h4><p>这里放一个知乎的高赞回答，看完很清楚。<a href=\"https://www.zhihu.com/question/20215561/answer/40316953\">WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear 的回答 - 知乎</a></p>\n<p>首先我们先说说大家都很了解的 Http 协议，在 B/S 开发中，我们常用这种协议来进行各种响应和处理。</p>\n<p>他的特点就是一个 Request 和 一个 Response 而且是无状态的（想要保持状态需要间接通过 session 和 cookie）。虽然在一些不那么复杂的需求下，这样的机制已经足够了，但是一些复杂的应用场景如需要一直监听某个数据的变化就显得力不从心了。当然我们也可以使用 ajax 来轮询，但这样其实是非常低效率的，你把自己想成服务器，假设有个人（客户端）一直在你耳边叨叨（数据更新了没。。。）我想你也一定要疯掉了吧。</p>\n<div align=center><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/inkun.jpg\" alt=\"img\" width=\"200\"></div>\n\n<p>其次 Http 协议的另一个特点，浏览器只能主动发送请求接收信息，不能被动接收服务器信息。这一点确实蛋疼，使得一旦数据有了变化我需要自己去请求，但是我又怎么知道数据什么时候更新了呢？</p>\n<p>然鹅，websocket 的出现就可以巧妙的解决这些问题。</p>\n<p>websocket 协由握手和数据传输构成</p>\n<p>握手基于 HTTP 协议，然后客户端和服务端实现长连接，所以说 websocket 和 http 是有交集的。</p>\n<p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230316170428.png\" alt=\"关系图\"></p>\n<p>那么数据如何传输呢？只需要在服务端设立转发的服务，那么数据就可以实现从 A 客户端到 B 客户端的发送，拿聊天举例，正是这种长连接机制以及允许客户端主动接收服务端消息的机制使得聊天消息能够看上去好像在两个客户端建立了连接。其实就是服务器做了一次转发。</p>\n<h4 id=\"Java-怎么写服务端的-WebSocket（SpringBoot）\"><a href=\"#Java-怎么写服务端的-WebSocket（SpringBoot）\" class=\"headerlink\" title=\"Java 怎么写服务端的 WebSocket（SpringBoot）\"></a>Java 怎么写服务端的 WebSocket（SpringBoot）</h4><p>非常类似 Servlet，这里我们需要写<strong>ServerEndPoint</strong></p>\n<p>这里我们主要重写三个方法</p>\n<ol>\n<li>onOpen(建立连接时自动调用)</li>\n<li>onMessage(接收消息时自动调用)</li>\n<li>onClose(关闭连接时自动调用)</li>\n</ol>\n<p>当然还有 onError 等方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">//这个 注解类似http的map ，比如说这样你的 websocket url 就是 ws：localhost/chat</span><br><span class=\"hljs-meta\">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChatEndPoint</span> &#123;<br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     *  建立连接被调</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-meta\">@OnOpen</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onOpen</span><span class=\"hljs-params\">(Session session, EndpointConfig config)</span>&#123;<br><br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 接收数据被调用</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-meta\">@OnMessage</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onMessage</span><span class=\"hljs-params\">(String message,Session session)</span>&#123;<br><br><br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 关闭连接调用</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-meta\">@OnClose</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onClose</span><span class=\"hljs-params\">(Session session)</span>&#123;<br><br><br><br>    &#125;<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>这里需要注意，上面 session 指的是 websocket 的 session，不是 http 的 session，也是用来标识每一个长连接的对象，看到这里聪明的小伙伴应该能想到实现消息转发可以用 session 来标识每一个用户。</p>\n<p>所以我们想要实现聊天消息转发可以使用 map 来存储 websocket 的 session。这里我存储 EndPoint 实例类似，因为我们可以使用 endpoint 实例来获取 session 对象，记住每一个用户进行一次 websocket 长连接，就会创建一个 endpoint 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class=\"hljs-comment\">    */</span><br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>\n\n<p>说到这里有小伙伴想问了，项目的一些数据存储在 HttpSession 中既然 websocket 是基于 http 的，那么我能不能取出 Httpsession 在 Endpoint 里使用啊？答案是可以的，只需要在 springboot 配置中在注入对象前 ServerEndpointConfig 放入这个 httpsession 就可以了</p>\n<p>配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-meta\">@Configuration</span><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WebSocketConfig</span> &#123;<br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-keyword\">public</span> ServerEndpointExporter <span class=\"hljs-title function_\">serverEndpointExporter</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerEndpointExporter</span>();<br>    &#125;<br>&#125;<br><br><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GetHttpSessionConfigurator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">ServerEndpointConfig</span>.Configurator &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">modifyHandshake</span><span class=\"hljs-params\">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> &#123;<br>        <span class=\"hljs-type\">HttpSession</span> <span class=\"hljs-variable\">httpSession</span> <span class=\"hljs-operator\">=</span> (HttpSession)request.getHttpSession();<br><br>        <span class=\"hljs-comment\">//将httpsession存到配置对象</span><br><br>        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-meta\">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br></code></pre></td></tr></table></figure>\n\n<p>获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-meta\">@OnOpen</span><br>   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onOpen</span><span class=\"hljs-params\">(Session session, EndpointConfig config)</span>&#123;<br><br>       <span class=\"hljs-built_in\">this</span>.session = session;<br><br>       <span class=\"hljs-comment\">//获取Httpssion</span><br><br>      <span class=\"hljs-type\">HttpSession</span> <span class=\"hljs-variable\">httpSession</span> <span class=\"hljs-operator\">=</span> (HttpSession) \tconfig.getUserProperties().get(HttpSession.class.getName());<br>      &#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"前端怎么写-WebSocket\"><a href=\"#前端怎么写-WebSocket\" class=\"headerlink\" title=\"前端怎么写 WebSocket\"></a>前端怎么写 WebSocket</h4><p>前端其实也类似，写起来更简单，只需要 new 一个 websocket 对象就能够实现连接。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Typescript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">ws</span>: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-literal\">null</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>\t<span class=\"hljs-comment\">//连接</span><br>  <span class=\"hljs-title function_\">connect</span>(<span class=\"hljs-params\"></span>) &#123;<br>    ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&#x27;ws://localhost:8081/api/chat&#x27;</span>);<br>  &#125;,<br>\t<span class=\"hljs-comment\">//获取实例</span><br>  <span class=\"hljs-title function_\">getWs</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> ws;<br>  &#125;,<br>  <span class=\"hljs-comment\">//关闭连接，删除实例</span><br><br>  <span class=\"hljs-title function_\">removeWs</span>(<span class=\"hljs-params\"></span>) &#123;<br>    ws.<span class=\"hljs-title function_\">close</span>();<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Typescript\"><span class=\"hljs-comment\">//调用方法</span><br>ws.<span class=\"hljs-title function_\">connect</span>();<br><br>  ws.<span class=\"hljs-title function_\">getWs</span>().<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br><br>  &#125;;<br><br>  ws.<span class=\"hljs-title function_\">getWs</span>().<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt</span>) &#123;<br>  &#125;<br>  ws.<span class=\"hljs-title function_\">getWs</span>().<span class=\"hljs-property\">onclose</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br><br>  &#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"聊天怎么实现\"><a href=\"#聊天怎么实现\" class=\"headerlink\" title=\"聊天怎么实现\"></a>聊天怎么实现</h4><p>思路</p>\n<ol>\n<li> 每一个客户端与服务端建立连接就将 EndPoint 实例存入 userHashMap（这里使用静态的）中。</li>\n<li> 客户端断开连接，就将此用户从 userHashMap 去除，所以 userHashMap 始终存储在线用户</li>\n<li> 客户端发消息，消息内容需要有发消息人，收消息人，内容，时间，封装成一个对象。</li>\n<li> 服务端 onmessage 接收到就检查用户里 userHashMap 有没有此人（有表示在线），有就找到 session 直接转发给他，没有需要暂时存储到 chatsHashMap，存消息列表 。</li>\n<li> 那么我们还要修改 1 步骤，这里连接上就要检查 chatsHashMap 有没有自己的消息，有就转发给自己并去除 chatsHashMap 的消息，这样一来就实现了离线和在线用户的聊天功能。</li>\n</ol>\n<p>后端全部代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-meta\">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChatEndPoint</span> &#123;<br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     *  用来存储每个客户端对象对应的聊天记录 key 是uid value 是json</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String, ArrayList&lt;String&gt;&gt; chats = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * websocket session</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-keyword\">private</span>  Session session;<br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * httpsession</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> HttpSession httpSession;<br><br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     *  建立连接被调</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-meta\">@OnOpen</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onOpen</span><span class=\"hljs-params\">(Session session, EndpointConfig config)</span>&#123;<br><br>        <span class=\"hljs-built_in\">this</span>.session = session;<br><br>        <span class=\"hljs-comment\">//获取Httpssion</span><br><br>       <span class=\"hljs-type\">HttpSession</span> <span class=\"hljs-variable\">httpSession</span> <span class=\"hljs-operator\">=</span> (HttpSession) config.getUserProperties().get(HttpSession.class.getName());<br><br>       <span class=\"hljs-built_in\">this</span>.httpSession = httpSession;<br><br><br>       <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>        <span class=\"hljs-comment\">// 将当前对象存储在 容器中 key为uid</span><br><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">uid</span> <span class=\"hljs-operator\">=</span> String.valueOf(user.getUid());<br><br>       users.put(uid,<span class=\"hljs-built_in\">this</span>);<br><br>       <span class=\"hljs-comment\">// 判断并建立 暂存 聊天记录的数据结构</span><br><br>       <span class=\"hljs-keyword\">if</span>(!chats.containsKey(uid)) &#123;<br><br>           ArrayList&lt;String&gt; arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>           System.out.println(uid+<span class=\"hljs-string\">&quot;调用了一次&quot;</span>);<br>           chats.put(uid,arr);<br><br>       &#125;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> MessageUtils.getMessage(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">null</span>, getUsers());<br><br>        System.out.println(message);<br>        <span class=\"hljs-comment\">//连接就一条广播</span><br>        broadcastAllUsers(MessageUtils.getMessage(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">null</span>,<span class=\"hljs-string\">&quot;当前在线用户人数：&quot;</span>+users.size()+<span class=\"hljs-string\">&quot;人&quot;</span>));<br>        broadcastAllUsers(message);<br><br>        <span class=\"hljs-comment\">//获取该用户暂存离线消息并推送</span><br><br>        ArrayList&lt;String&gt; chatCache = chats.get(uid);<br><br><br>        <span class=\"hljs-keyword\">for</span>(String chat:chatCache)&#123;<br><span class=\"hljs-comment\">//            ChatEndPoint chatEndPoint = users.get(uid);</span><br><span class=\"hljs-comment\">//            System.out.println(chat);</span><br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-built_in\">this</span>.session.getBasicRemote().sendText(chat);<br>            &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        chats.remove(uid);<br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 获取容器里的用户</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span></span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> Set&lt;String&gt; <span class=\"hljs-title function_\">getUsers</span><span class=\"hljs-params\">()</span>&#123;<br><br>        <span class=\"hljs-keyword\">return</span> ChatEndPoint.users.keySet();<br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 推送所有客户端</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">broadcastAllUsers</span><span class=\"hljs-params\">(String message)</span>&#123;<br><br>        Set&lt;String&gt; usersSet = users.keySet();<br>            <span class=\"hljs-keyword\">try</span> &#123;<br><br>                <span class=\"hljs-keyword\">for</span> (String user : usersSet) &#123;<br>                    <span class=\"hljs-type\">ChatEndPoint</span> <span class=\"hljs-variable\">chatEndPoint</span> <span class=\"hljs-operator\">=</span> users.get(user);<br>                    chatEndPoint.session.getBasicRemote().sendText(message);<br>                &#125;&#125; <span class=\"hljs-keyword\">catch</span>(IOException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br><br><br>            &#125;<br><br><br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 接收数据被调用</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-meta\">@OnMessage</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onMessage</span><span class=\"hljs-params\">(String message,Session session)</span>&#123;<br><br><br>        <span class=\"hljs-type\">ObjectMapper</span> <span class=\"hljs-variable\">mapper</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectMapper</span>();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-type\">Message</span> <span class=\"hljs-variable\">mess</span> <span class=\"hljs-operator\">=</span> mapper.readValue(message, Message.class);<br><br><span class=\"hljs-comment\">//            System.out.println(mess);</span><br><span class=\"hljs-comment\">// 消息的接收者</span><br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">toUid</span> <span class=\"hljs-operator\">=</span> mess.getToUid();<br><br>            <span class=\"hljs-type\">ChatEndPoint</span> <span class=\"hljs-variable\">chatEndPoint</span> <span class=\"hljs-operator\">=</span> users.get(toUid);<br><br>            <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>            <span class=\"hljs-keyword\">if</span>(chatEndPoint!=<span class=\"hljs-literal\">null</span>)&#123;<br><br>                <span class=\"hljs-comment\">// 接收用户在线直接转发</span><br><br><br><br>                <span class=\"hljs-keyword\">if</span>(user==<span class=\"hljs-literal\">null</span>)&#123;<br><br>                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.LOGIN_ERROR);<br>                &#125;<br><br>                <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message1</span> <span class=\"hljs-operator\">=</span> MessageUtils.getMessage(<span class=\"hljs-literal\">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess);<br><br>                chatEndPoint.session.getBasicRemote().sendText(message1);<br><br><br><br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br><br>                <span class=\"hljs-comment\">//接收用户不在线 先暂时存储消息</span><br><br>                ArrayList&lt;String&gt; messages = chats.get(toUid);<br><br>                <span class=\"hljs-keyword\">if</span>(messages == <span class=\"hljs-literal\">null</span>)&#123;<br>                    messages = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>                    chats.put(toUid,messages);<br><br>                &#125;<br><br>                <span class=\"hljs-comment\">//存的就是json</span><br>                messages.add(MessageUtils.getMessage(<span class=\"hljs-literal\">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess));<br><br><br><br>            &#125;<br><br><br><br>        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 关闭连接调用</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-meta\">@OnClose</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onClose</span><span class=\"hljs-params\">(Session session)</span>&#123;<br><br><br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br>        users.remove(user.getUid().toString());<br><br>        System.out.println(user.getUserName()+<span class=\"hljs-string\">&quot;下线了，当前在线人数：&quot;</span>+users.size()+<span class=\"hljs-string\">&quot;人&quot;</span>);<br><br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 获取当前时间戳，秒</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title function_\">getUnix</span><span class=\"hljs-params\">()</span>&#123;<br><br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">time</span> <span class=\"hljs-operator\">=</span> System.currentTimeMillis();<br><br><br>        time = time / <span class=\"hljs-number\">1000</span>;<br><br>        <span class=\"hljs-keyword\">return</span> String.valueOf(time);<br><br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>前端接收怎么存储呢？我暂时只想到存储在 sessionStorage 或者 localStorage 中，但这部分数据存储需要考虑去重和数据对应每个用户，不要疏忽了让别的用户看到了不属于自己的对话内容，那就出大问题了。整体思路挺简单的就是要细心。</p>\n<h4 id=\"实现展示\"><a href=\"#实现展示\" class=\"headerlink\" title=\"实现展示\"></a>实现展示</h4><p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171042690.png\" alt=\"image-20221125171042690\"></p>\n<p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171211620.png\" alt=\"image-20221125171211620\"></p>\n<p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171244569.png\" alt=\"image-20221125171244569\"></p>\n<p>组件采用的是 react-jwchat 感觉挺好看的，各项功能都正常，就是有时候会 websocket 连接了就断开了，猜测是没写 error 处理吧。</p>\n<h4 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h4><p>最后看我的二手交易系统的前后端源码（websocket 源码也在里面）</p>\n<p><a href=\"https://gitee.com/wx_504ae56474/react-jwchat\">react-jwchat 聊天组件</a></p>\n<p><a href=\"https://gitee.com/yilinyo/lkd-javee-trade-frontend\">二手交易系统前端</a></p>\n<p><a href=\"https://gitee.com/yilinyo/lkd-javaee-trade-backend\">二手交易系统后端</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"WebSockect-实现聊天室\"><a href=\"#WebSockect-实现聊天室\" class=\"headerlink\" title=\"WebSockect 实现聊天室\"></a>WebSockect 实现聊天室</h2><p><strong>说明：最近二手交易课设有一个需求是实现 购买者和商品发布者有一个聊天对话的功能，类似于咸鱼的聊天对话功能吧。想到的就是 WebSocket 协议来实现，问了一个前端小伙伴，他一般使用 socketio(一个 websocket 框架)，我看了下也有 java 版的，但思考了下决定还是使用原生 websocket 来写前后端。</strong></p>\n<h4 id=\"什么是-websocket？\"><a href=\"#什么是-websocket？\" class=\"headerlink\" title=\"什么是 websocket？\"></a>什么是 websocket？</h4><p>这里放一个知乎的高赞回答，看完很清楚。<a href=\"https://www.zhihu.com/question/20215561/answer/40316953\">WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear 的回答 - 知乎</a></p>\n<p>首先我们先说说大家都很了解的 Http 协议，在 B/S 开发中，我们常用这种协议来进行各种响应和处理。</p>\n<p>他的特点就是一个 Request 和 一个 Response 而且是无状态的（想要保持状态需要间接通过 session 和 cookie）。虽然在一些不那么复杂的需求下，这样的机制已经足够了，但是一些复杂的应用场景如需要一直监听某个数据的变化就显得力不从心了。当然我们也可以使用 ajax 来轮询，但这样其实是非常低效率的，你把自己想成服务器，假设有个人（客户端）一直在你耳边叨叨（数据更新了没。。。）我想你也一定要疯掉了吧。</p>\n<div align=center><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/inkun.jpg\" alt=\"img\" width=\"200\"></div>\n\n<p>其次 Http 协议的另一个特点，浏览器只能主动发送请求接收信息，不能被动接收服务器信息。这一点确实蛋疼，使得一旦数据有了变化我需要自己去请求，但是我又怎么知道数据什么时候更新了呢？</p>\n<p>然鹅，websocket 的出现就可以巧妙的解决这些问题。</p>\n<p>websocket 协由握手和数据传输构成</p>\n<p>握手基于 HTTP 协议，然后客户端和服务端实现长连接，所以说 websocket 和 http 是有交集的。</p>\n<p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230316170428.png\" alt=\"关系图\"></p>\n<p>那么数据如何传输呢？只需要在服务端设立转发的服务，那么数据就可以实现从 A 客户端到 B 客户端的发送，拿聊天举例，正是这种长连接机制以及允许客户端主动接收服务端消息的机制使得聊天消息能够看上去好像在两个客户端建立了连接。其实就是服务器做了一次转发。</p>\n<h4 id=\"Java-怎么写服务端的-WebSocket（SpringBoot）\"><a href=\"#Java-怎么写服务端的-WebSocket（SpringBoot）\" class=\"headerlink\" title=\"Java 怎么写服务端的 WebSocket（SpringBoot）\"></a>Java 怎么写服务端的 WebSocket（SpringBoot）</h4><p>非常类似 Servlet，这里我们需要写<strong>ServerEndPoint</strong></p>\n<p>这里我们主要重写三个方法</p>\n<ol>\n<li>onOpen(建立连接时自动调用)</li>\n<li>onMessage(接收消息时自动调用)</li>\n<li>onClose(关闭连接时自动调用)</li>\n</ol>\n<p>当然还有 onError 等方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">//这个 注解类似http的map ，比如说这样你的 websocket url 就是 ws：localhost/chat</span><br><span class=\"hljs-meta\">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChatEndPoint</span> &#123;<br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     *  建立连接被调</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-meta\">@OnOpen</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onOpen</span><span class=\"hljs-params\">(Session session, EndpointConfig config)</span>&#123;<br><br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 接收数据被调用</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-meta\">@OnMessage</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onMessage</span><span class=\"hljs-params\">(String message,Session session)</span>&#123;<br><br><br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 关闭连接调用</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-meta\">@OnClose</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onClose</span><span class=\"hljs-params\">(Session session)</span>&#123;<br><br><br><br>    &#125;<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>这里需要注意，上面 session 指的是 websocket 的 session，不是 http 的 session，也是用来标识每一个长连接的对象，看到这里聪明的小伙伴应该能想到实现消息转发可以用 session 来标识每一个用户。</p>\n<p>所以我们想要实现聊天消息转发可以使用 map 来存储 websocket 的 session。这里我存储 EndPoint 实例类似，因为我们可以使用 endpoint 实例来获取 session 对象，记住每一个用户进行一次 websocket 长连接，就会创建一个 endpoint 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class=\"hljs-comment\">    */</span><br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>\n\n<p>说到这里有小伙伴想问了，项目的一些数据存储在 HttpSession 中既然 websocket 是基于 http 的，那么我能不能取出 Httpsession 在 Endpoint 里使用啊？答案是可以的，只需要在 springboot 配置中在注入对象前 ServerEndpointConfig 放入这个 httpsession 就可以了</p>\n<p>配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-meta\">@Configuration</span><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WebSocketConfig</span> &#123;<br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-keyword\">public</span> ServerEndpointExporter <span class=\"hljs-title function_\">serverEndpointExporter</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerEndpointExporter</span>();<br>    &#125;<br>&#125;<br><br><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GetHttpSessionConfigurator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">ServerEndpointConfig</span>.Configurator &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">modifyHandshake</span><span class=\"hljs-params\">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> &#123;<br>        <span class=\"hljs-type\">HttpSession</span> <span class=\"hljs-variable\">httpSession</span> <span class=\"hljs-operator\">=</span> (HttpSession)request.getHttpSession();<br><br>        <span class=\"hljs-comment\">//将httpsession存到配置对象</span><br><br>        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-meta\">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br></code></pre></td></tr></table></figure>\n\n<p>获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Java\"><span class=\"hljs-meta\">@OnOpen</span><br>   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onOpen</span><span class=\"hljs-params\">(Session session, EndpointConfig config)</span>&#123;<br><br>       <span class=\"hljs-built_in\">this</span>.session = session;<br><br>       <span class=\"hljs-comment\">//获取Httpssion</span><br><br>      <span class=\"hljs-type\">HttpSession</span> <span class=\"hljs-variable\">httpSession</span> <span class=\"hljs-operator\">=</span> (HttpSession) \tconfig.getUserProperties().get(HttpSession.class.getName());<br>      &#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"前端怎么写-WebSocket\"><a href=\"#前端怎么写-WebSocket\" class=\"headerlink\" title=\"前端怎么写 WebSocket\"></a>前端怎么写 WebSocket</h4><p>前端其实也类似，写起来更简单，只需要 new 一个 websocket 对象就能够实现连接。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Typescript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">ws</span>: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-literal\">null</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>\t<span class=\"hljs-comment\">//连接</span><br>  <span class=\"hljs-title function_\">connect</span>(<span class=\"hljs-params\"></span>) &#123;<br>    ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&#x27;ws://localhost:8081/api/chat&#x27;</span>);<br>  &#125;,<br>\t<span class=\"hljs-comment\">//获取实例</span><br>  <span class=\"hljs-title function_\">getWs</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> ws;<br>  &#125;,<br>  <span class=\"hljs-comment\">//关闭连接，删除实例</span><br><br>  <span class=\"hljs-title function_\">removeWs</span>(<span class=\"hljs-params\"></span>) &#123;<br>    ws.<span class=\"hljs-title function_\">close</span>();<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Typescript\"><span class=\"hljs-comment\">//调用方法</span><br>ws.<span class=\"hljs-title function_\">connect</span>();<br><br>  ws.<span class=\"hljs-title function_\">getWs</span>().<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br><br>  &#125;;<br><br>  ws.<span class=\"hljs-title function_\">getWs</span>().<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt</span>) &#123;<br>  &#125;<br>  ws.<span class=\"hljs-title function_\">getWs</span>().<span class=\"hljs-property\">onclose</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br><br>  &#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"聊天怎么实现\"><a href=\"#聊天怎么实现\" class=\"headerlink\" title=\"聊天怎么实现\"></a>聊天怎么实现</h4><p>思路</p>\n<ol>\n<li> 每一个客户端与服务端建立连接就将 EndPoint 实例存入 userHashMap（这里使用静态的）中。</li>\n<li> 客户端断开连接，就将此用户从 userHashMap 去除，所以 userHashMap 始终存储在线用户</li>\n<li> 客户端发消息，消息内容需要有发消息人，收消息人，内容，时间，封装成一个对象。</li>\n<li> 服务端 onmessage 接收到就检查用户里 userHashMap 有没有此人（有表示在线），有就找到 session 直接转发给他，没有需要暂时存储到 chatsHashMap，存消息列表 。</li>\n<li> 那么我们还要修改 1 步骤，这里连接上就要检查 chatsHashMap 有没有自己的消息，有就转发给自己并去除 chatsHashMap 的消息，这样一来就实现了离线和在线用户的聊天功能。</li>\n</ol>\n<p>后端全部代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-meta\">@ServerEndpoint(value = &quot;/chat&quot;,configurator = GetHttpSessionConfigurator.class)</span><br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChatEndPoint</span> &#123;<br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 用来存储每个客户端对象对应的ChatEndpoint对象 key 是uid</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String,ChatEndPoint&gt; users = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     *  用来存储每个客户端对象对应的聊天记录 key 是uid value 是json</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String, ArrayList&lt;String&gt;&gt; chats = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * websocket session</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-keyword\">private</span>  Session session;<br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * httpsession</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> HttpSession httpSession;<br><br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     *  建立连接被调</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-meta\">@OnOpen</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onOpen</span><span class=\"hljs-params\">(Session session, EndpointConfig config)</span>&#123;<br><br>        <span class=\"hljs-built_in\">this</span>.session = session;<br><br>        <span class=\"hljs-comment\">//获取Httpssion</span><br><br>       <span class=\"hljs-type\">HttpSession</span> <span class=\"hljs-variable\">httpSession</span> <span class=\"hljs-operator\">=</span> (HttpSession) config.getUserProperties().get(HttpSession.class.getName());<br><br>       <span class=\"hljs-built_in\">this</span>.httpSession = httpSession;<br><br><br>       <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>        <span class=\"hljs-comment\">// 将当前对象存储在 容器中 key为uid</span><br><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">uid</span> <span class=\"hljs-operator\">=</span> String.valueOf(user.getUid());<br><br>       users.put(uid,<span class=\"hljs-built_in\">this</span>);<br><br>       <span class=\"hljs-comment\">// 判断并建立 暂存 聊天记录的数据结构</span><br><br>       <span class=\"hljs-keyword\">if</span>(!chats.containsKey(uid)) &#123;<br><br>           ArrayList&lt;String&gt; arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>           System.out.println(uid+<span class=\"hljs-string\">&quot;调用了一次&quot;</span>);<br>           chats.put(uid,arr);<br><br>       &#125;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> MessageUtils.getMessage(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">null</span>, getUsers());<br><br>        System.out.println(message);<br>        <span class=\"hljs-comment\">//连接就一条广播</span><br>        broadcastAllUsers(MessageUtils.getMessage(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">null</span>,<span class=\"hljs-string\">&quot;当前在线用户人数：&quot;</span>+users.size()+<span class=\"hljs-string\">&quot;人&quot;</span>));<br>        broadcastAllUsers(message);<br><br>        <span class=\"hljs-comment\">//获取该用户暂存离线消息并推送</span><br><br>        ArrayList&lt;String&gt; chatCache = chats.get(uid);<br><br><br>        <span class=\"hljs-keyword\">for</span>(String chat:chatCache)&#123;<br><span class=\"hljs-comment\">//            ChatEndPoint chatEndPoint = users.get(uid);</span><br><span class=\"hljs-comment\">//            System.out.println(chat);</span><br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-built_in\">this</span>.session.getBasicRemote().sendText(chat);<br>            &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        chats.remove(uid);<br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 获取容器里的用户</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span></span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> Set&lt;String&gt; <span class=\"hljs-title function_\">getUsers</span><span class=\"hljs-params\">()</span>&#123;<br><br>        <span class=\"hljs-keyword\">return</span> ChatEndPoint.users.keySet();<br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 推送所有客户端</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">broadcastAllUsers</span><span class=\"hljs-params\">(String message)</span>&#123;<br><br>        Set&lt;String&gt; usersSet = users.keySet();<br>            <span class=\"hljs-keyword\">try</span> &#123;<br><br>                <span class=\"hljs-keyword\">for</span> (String user : usersSet) &#123;<br>                    <span class=\"hljs-type\">ChatEndPoint</span> <span class=\"hljs-variable\">chatEndPoint</span> <span class=\"hljs-operator\">=</span> users.get(user);<br>                    chatEndPoint.session.getBasicRemote().sendText(message);<br>                &#125;&#125; <span class=\"hljs-keyword\">catch</span>(IOException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br><br><br>            &#125;<br><br><br><br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 接收数据被调用</span><br><span class=\"hljs-comment\">     */</span><br><br>    <span class=\"hljs-meta\">@OnMessage</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onMessage</span><span class=\"hljs-params\">(String message,Session session)</span>&#123;<br><br><br>        <span class=\"hljs-type\">ObjectMapper</span> <span class=\"hljs-variable\">mapper</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectMapper</span>();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-type\">Message</span> <span class=\"hljs-variable\">mess</span> <span class=\"hljs-operator\">=</span> mapper.readValue(message, Message.class);<br><br><span class=\"hljs-comment\">//            System.out.println(mess);</span><br><span class=\"hljs-comment\">// 消息的接收者</span><br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">toUid</span> <span class=\"hljs-operator\">=</span> mess.getToUid();<br><br>            <span class=\"hljs-type\">ChatEndPoint</span> <span class=\"hljs-variable\">chatEndPoint</span> <span class=\"hljs-operator\">=</span> users.get(toUid);<br><br>            <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br><br><br>            <span class=\"hljs-keyword\">if</span>(chatEndPoint!=<span class=\"hljs-literal\">null</span>)&#123;<br><br>                <span class=\"hljs-comment\">// 接收用户在线直接转发</span><br><br><br><br>                <span class=\"hljs-keyword\">if</span>(user==<span class=\"hljs-literal\">null</span>)&#123;<br><br>                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusinessException</span>(ErrorCode.LOGIN_ERROR);<br>                &#125;<br><br>                <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message1</span> <span class=\"hljs-operator\">=</span> MessageUtils.getMessage(<span class=\"hljs-literal\">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess);<br><br>                chatEndPoint.session.getBasicRemote().sendText(message1);<br><br><br><br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br><br>                <span class=\"hljs-comment\">//接收用户不在线 先暂时存储消息</span><br><br>                ArrayList&lt;String&gt; messages = chats.get(toUid);<br><br>                <span class=\"hljs-keyword\">if</span>(messages == <span class=\"hljs-literal\">null</span>)&#123;<br>                    messages = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>                    chats.put(toUid,messages);<br><br>                &#125;<br><br>                <span class=\"hljs-comment\">//存的就是json</span><br>                messages.add(MessageUtils.getMessage(<span class=\"hljs-literal\">false</span>, user.getUserName(), user.getUid(),user.getPhone(), mess));<br><br><br><br>            &#125;<br><br><br><br>        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 关闭连接调用</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-meta\">@OnClose</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onClose</span><span class=\"hljs-params\">(Session session)</span>&#123;<br><br><br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> (User)httpSession.getAttribute(USER_LOGIN_STATE);<br><br>        users.remove(user.getUid().toString());<br><br>        System.out.println(user.getUserName()+<span class=\"hljs-string\">&quot;下线了，当前在线人数：&quot;</span>+users.size()+<span class=\"hljs-string\">&quot;人&quot;</span>);<br><br><br><br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 获取当前时间戳，秒</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title function_\">getUnix</span><span class=\"hljs-params\">()</span>&#123;<br><br>        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">time</span> <span class=\"hljs-operator\">=</span> System.currentTimeMillis();<br><br><br>        time = time / <span class=\"hljs-number\">1000</span>;<br><br>        <span class=\"hljs-keyword\">return</span> String.valueOf(time);<br><br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>前端接收怎么存储呢？我暂时只想到存储在 sessionStorage 或者 localStorage 中，但这部分数据存储需要考虑去重和数据对应每个用户，不要疏忽了让别的用户看到了不属于自己的对话内容，那就出大问题了。整体思路挺简单的就是要细心。</p>\n<h4 id=\"实现展示\"><a href=\"#实现展示\" class=\"headerlink\" title=\"实现展示\"></a>实现展示</h4><p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171042690.png\" alt=\"image-20221125171042690\"></p>\n<p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171211620.png\" alt=\"image-20221125171211620\"></p>\n<p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/image-20221125171244569.png\" alt=\"image-20221125171244569\"></p>\n<p>组件采用的是 react-jwchat 感觉挺好看的，各项功能都正常，就是有时候会 websocket 连接了就断开了，猜测是没写 error 处理吧。</p>\n<h4 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h4><p>最后看我的二手交易系统的前后端源码（websocket 源码也在里面）</p>\n<p><a href=\"https://gitee.com/wx_504ae56474/react-jwchat\">react-jwchat 聊天组件</a></p>\n<p><a href=\"https://gitee.com/yilinyo/lkd-javee-trade-frontend\">二手交易系统前端</a></p>\n<p><a href=\"https://gitee.com/yilinyo/lkd-javaee-trade-backend\">二手交易系统后端</a></p>\n"},{"title":"Nginx 入门 server块 书写之 location 规则 （二）","date":"2023-04-09T06:00:00.000Z","_content":"\n# Nginx 入门 server块 书写之 location 规则 （二）\n\n接上文，我们学习了location 路由匹配规则和优先级，今天我们深入其内部来探寻实际处理的各个属性书写方式。\n\n### Return 指令\n\n**return一般用于对请求的客户端直接返回响应状态码。在该作用域内return后面的所有nginx配置都是无效的。可以使用在server、location以及if配置中。除了支持跟状态码，还可以跟字符串或者url链接。**\n\n```bash\n  1 server{\n  2     listen 80;\n  3     server_name www.aaa.com;\n  4     return 200 \"hello\";\n  5 }\n \n \n#说明：如果要想返回字符串，必须要加上状态码，否则会报错。\n \n \n  1 location ^~ /aming {\n  2     default_type application/json ;\n  3     return 200  '{\"name\":\"xhy\",\"id\":\"100\"}';\n  4 }\t\t\t\t\t\n#返回的字符串也支持json数据。\n \n \n  1 location /test {\n  2     return 200 \"$host $request_uri\";\n  3 }\t\t\t\t\t\n#返回的字符串也支持变量\n \n \n  1 server{\n  2     listen 80;\n  3     server_name www.aaa.com;\n  4     return http://www.baidu.com;\n  5     rewrite /(.*) /abc/$1;\t\t#该行配置位于return后，则不会被执行。\n  6 }\n \n# 注意：return后面的url必须是以http://或者https://开头的。\n```\n\n```bash\n#常见的重定向\nlocation = /tutorial/learning-nginx {\n     return 301 $scheme://example.com/nginx/understanding-nginx\n}\n```\n\n### Rewrite指令\n\n```\nrewrite regex replacement-url [flag];\nregex: 正则表达式\nreplacement-url: 替换的URL\nflag: 用于进行一些额外的处理\n\n```\n\n不同flag的效果：\n\n| flag      | 说明                                  |\n| :-------- | :---------------------------------- |\n| last      | 停止解析，并开始搜索与更改后的`URI`相匹配的`location`; |\n| break     | 中止 rewrite，不再继续匹配                   |\n| redirect  | 返回临时重定向的 HTTP 状态 302                |\n| permanent | 返回永久重定向的 HTTP 状态 301                |\n\n案例\n\n```bash\nlocation = /nginx-tutorial \n{ \n    rewrite ^/nginx-tutorial?$ /somePage.html last; \n}\n\n\n#把`https://example.com/nginx-tutorial`重写为#`https://example.com/somePage.html`\n\n```\n\n#####\n\n```bash\nlocation = /user.php \n{ \n    rewrite ^/user.php?id=([0-9]+)$ /user/$1 last; \n}\n##### 动态替换案例\n\n#把`https://www.example.com/user.php?id=11`重写为`https://exampleshop.com/user/11`\n\n# 其中`$1`表示`regex`中第一个括号中的值，第二个括号中的值可通过`$2`获取\n\n```\n\n```bash\nlocation = /\n{\n    if ($http_user_agent ~* (mobile|nokia|iphone|ipad|android|samsung|htc|blackberry)) {\n    rewrite ^(.*) https://m.example.com$1 redirect;\n    }\n}\n\n##### 手机访问重定向网址\n\n# 把`https://www.example.com`重写为`https://m.exampleshop.com`\n```\n\n### Proxy指令\n\n用于转发请求，常用于反向代理，注意以下细节\n\n*   proxy\\_pass的链接无`/`\n*   proxy\\_pass的链接有`/`\n\n#### **第一种：proxy\\_pass的链接无`/`**\n\n**proxy\\_pass中，不带『/』，则把『匹配字符串及后缀（/api/xxx）』均带给转发地址**\n\n```bash\n# 效果为：http://xxx.xxx.com/api/xxx -> http://127.0.0.1:7000/api/xxx. 转发的时候,包含了url前缀.\nlocation ^~ /api/ { \n    proxy_pass  http://127.0.0.1:7000; \n}\n\n# 效果与上面一致\nlocation ^~ /api {\n    proxy_pass  http://127.0.0.1:7000; \n}\n```\n\n#### 第二种：proxy\\_pass的链接有`/`\n\nproxy\\_pass中，带『/』，则把『请求地址排除匹配字符串（/api/）』后，再带给转发地址\n\n```bash\n# 效果为：http://xxx.xxx.com/api/xxx --> http://127.0.0.1:7000/xxx\nlocation ^~ /api/ {\n    proxy_pass  http://127.0.0.1:7000/; # 端口后多了斜杠『/』\n}\n\n# 注意：下面的代码会导致失败，原因为『/api/xxx排除了/api』后，会把『/xxx』带给转发地址，但转发地址中已有了斜杠，结果会多了一条斜杠，报错。\n# 效果为：http://xxx.xxx.com/api/xxx --> http://127.0.0.1:7000//xxx\nlocation ^~ /api {  # 这里的匹配字符串最后少了斜杠『/』\n    proxy_pass  http://127.0.0.1:7000/;\n}\n```\n\n**location的修饰符为正则匹配时，proxy\\_pass的地址最后不要带斜杠**\n\n一些简单的常用的 proxy\\_pass参数\n\n```bash\nlocation / {\n      proxy_pass http://game;\n      # 用户请求的时候HOST的值是game1.test.com, 那么代理服务会像后端传递请求的还是game1.test.com\n      proxy_set_header Host $http_host;\n      # 将$remote_addr的值放进变量X-Real-IP中，$remote_addr的值为客户端的ip\n      proxy_set_header X-Real-IP $remote_addr;\n      # 客户端通过代理服务访问后端服务, 后端服务通过该变量会记录真实客户端地址\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      # nginx代理与后端服务器连接超时时间(代理连接超时)\n      proxy_connect_timeout 10s;\n     # nginx代理等待后端服务器的响应时间 \n     proxy_read_timeout 10s;\n     # 后端服务器数据回传给nginx代理超时时间\n     proxy_send_timeout 10s;\n     # nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端，边收边传, 不是全部接收完再传给客户  \n     proxy_buffering on;\n     # 设置nginx代理保存用户头信息的缓冲区大小\n     proxy_buffer_size  8k;\n     # proxy_buffers 缓冲区 \n     proxy_buffers 8 8k;\n     # 状态标记\n     proxy_next_upstream http_404  http_500  http_502  http_503  http_504  http_403  http_429;\n}\n```\n\n### try\\_files指令\n\n　格式1：**try\\_files** *`file`* ... *`uri`*;  格式2：**try\\_files** *`file`* ... =*`code`*;\n\n> **Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the \\*`file`\\*parameter according to the [root](http://nginx.org/en/docs/http/ngx_http_core_module.html#root) and [alias](http://nginx.org/en/docs/http/ngx_http_core_module.html#alias) directives. It is possible to check directory’s existence by specifying a slash at the end of a name, e.g. “`$uri/`”. If none of the files were found, an internal redirect to the *****`uri`*** specified in the last parameter is made. \n\n*   　　关键点1：按指定的file顺序查找存在的文件，并使用第一个找到的文件进行请求处理\n\n\n\n*   　　关键点2：查找路径是按照给定的root或alias为根路径来查找的\n\n\n\n*   　　关键点3：如果给出的file都没有匹配到，则重新请求最后一个参数给定的uri，就是新的location匹配\n\n\n\n*   　　关键点4：如果是格式2，如果最后一个参数是 = 404 ，若给出的file都没有匹配到，则最后返回404的响应码\n\n```bash\nlocation /images/ {\n    root /opt/html/;\n    try_files $uri   $uri/  /images/default.gif; \n}\n# 比如 请求 127.0.0.1/images/test.gif 会依次查找 1.文#件/opt/html/images/test.gif   2.文件夹 /opt/html/images/test.gif/下的index文件  3. 请求127.0.0.1/images/default.gif\n\n```\n\n[nginx配置选项try\\_files详解 - 陈一风 - 博客园 (cnblogs.com)](https://www.cnblogs.com/jedi1995/p/10900224.html)\n\n### Nginx内置绑定变量\n\n[使用 Nginx 内置绑定变量 · OpenResty最佳实践 (gitbooks.io)](https://moonbingbing.gitbooks.io/openresty-best-practices/content/openresty/inline_var.html)\n","source":"_posts/Nginx 入门 server块 书写之 location 规则 （二）.md","raw":"\n---\ntitle: Nginx 入门 server块 书写之 location 规则 （二）\ntag: Nginx\ndate: 2023-4-9 14:00:00\n---\n\n# Nginx 入门 server块 书写之 location 规则 （二）\n\n接上文，我们学习了location 路由匹配规则和优先级，今天我们深入其内部来探寻实际处理的各个属性书写方式。\n\n### Return 指令\n\n**return一般用于对请求的客户端直接返回响应状态码。在该作用域内return后面的所有nginx配置都是无效的。可以使用在server、location以及if配置中。除了支持跟状态码，还可以跟字符串或者url链接。**\n\n```bash\n  1 server{\n  2     listen 80;\n  3     server_name www.aaa.com;\n  4     return 200 \"hello\";\n  5 }\n \n \n#说明：如果要想返回字符串，必须要加上状态码，否则会报错。\n \n \n  1 location ^~ /aming {\n  2     default_type application/json ;\n  3     return 200  '{\"name\":\"xhy\",\"id\":\"100\"}';\n  4 }\t\t\t\t\t\n#返回的字符串也支持json数据。\n \n \n  1 location /test {\n  2     return 200 \"$host $request_uri\";\n  3 }\t\t\t\t\t\n#返回的字符串也支持变量\n \n \n  1 server{\n  2     listen 80;\n  3     server_name www.aaa.com;\n  4     return http://www.baidu.com;\n  5     rewrite /(.*) /abc/$1;\t\t#该行配置位于return后，则不会被执行。\n  6 }\n \n# 注意：return后面的url必须是以http://或者https://开头的。\n```\n\n```bash\n#常见的重定向\nlocation = /tutorial/learning-nginx {\n     return 301 $scheme://example.com/nginx/understanding-nginx\n}\n```\n\n### Rewrite指令\n\n```\nrewrite regex replacement-url [flag];\nregex: 正则表达式\nreplacement-url: 替换的URL\nflag: 用于进行一些额外的处理\n\n```\n\n不同flag的效果：\n\n| flag      | 说明                                  |\n| :-------- | :---------------------------------- |\n| last      | 停止解析，并开始搜索与更改后的`URI`相匹配的`location`; |\n| break     | 中止 rewrite，不再继续匹配                   |\n| redirect  | 返回临时重定向的 HTTP 状态 302                |\n| permanent | 返回永久重定向的 HTTP 状态 301                |\n\n案例\n\n```bash\nlocation = /nginx-tutorial \n{ \n    rewrite ^/nginx-tutorial?$ /somePage.html last; \n}\n\n\n#把`https://example.com/nginx-tutorial`重写为#`https://example.com/somePage.html`\n\n```\n\n#####\n\n```bash\nlocation = /user.php \n{ \n    rewrite ^/user.php?id=([0-9]+)$ /user/$1 last; \n}\n##### 动态替换案例\n\n#把`https://www.example.com/user.php?id=11`重写为`https://exampleshop.com/user/11`\n\n# 其中`$1`表示`regex`中第一个括号中的值，第二个括号中的值可通过`$2`获取\n\n```\n\n```bash\nlocation = /\n{\n    if ($http_user_agent ~* (mobile|nokia|iphone|ipad|android|samsung|htc|blackberry)) {\n    rewrite ^(.*) https://m.example.com$1 redirect;\n    }\n}\n\n##### 手机访问重定向网址\n\n# 把`https://www.example.com`重写为`https://m.exampleshop.com`\n```\n\n### Proxy指令\n\n用于转发请求，常用于反向代理，注意以下细节\n\n*   proxy\\_pass的链接无`/`\n*   proxy\\_pass的链接有`/`\n\n#### **第一种：proxy\\_pass的链接无`/`**\n\n**proxy\\_pass中，不带『/』，则把『匹配字符串及后缀（/api/xxx）』均带给转发地址**\n\n```bash\n# 效果为：http://xxx.xxx.com/api/xxx -> http://127.0.0.1:7000/api/xxx. 转发的时候,包含了url前缀.\nlocation ^~ /api/ { \n    proxy_pass  http://127.0.0.1:7000; \n}\n\n# 效果与上面一致\nlocation ^~ /api {\n    proxy_pass  http://127.0.0.1:7000; \n}\n```\n\n#### 第二种：proxy\\_pass的链接有`/`\n\nproxy\\_pass中，带『/』，则把『请求地址排除匹配字符串（/api/）』后，再带给转发地址\n\n```bash\n# 效果为：http://xxx.xxx.com/api/xxx --> http://127.0.0.1:7000/xxx\nlocation ^~ /api/ {\n    proxy_pass  http://127.0.0.1:7000/; # 端口后多了斜杠『/』\n}\n\n# 注意：下面的代码会导致失败，原因为『/api/xxx排除了/api』后，会把『/xxx』带给转发地址，但转发地址中已有了斜杠，结果会多了一条斜杠，报错。\n# 效果为：http://xxx.xxx.com/api/xxx --> http://127.0.0.1:7000//xxx\nlocation ^~ /api {  # 这里的匹配字符串最后少了斜杠『/』\n    proxy_pass  http://127.0.0.1:7000/;\n}\n```\n\n**location的修饰符为正则匹配时，proxy\\_pass的地址最后不要带斜杠**\n\n一些简单的常用的 proxy\\_pass参数\n\n```bash\nlocation / {\n      proxy_pass http://game;\n      # 用户请求的时候HOST的值是game1.test.com, 那么代理服务会像后端传递请求的还是game1.test.com\n      proxy_set_header Host $http_host;\n      # 将$remote_addr的值放进变量X-Real-IP中，$remote_addr的值为客户端的ip\n      proxy_set_header X-Real-IP $remote_addr;\n      # 客户端通过代理服务访问后端服务, 后端服务通过该变量会记录真实客户端地址\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      # nginx代理与后端服务器连接超时时间(代理连接超时)\n      proxy_connect_timeout 10s;\n     # nginx代理等待后端服务器的响应时间 \n     proxy_read_timeout 10s;\n     # 后端服务器数据回传给nginx代理超时时间\n     proxy_send_timeout 10s;\n     # nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端，边收边传, 不是全部接收完再传给客户  \n     proxy_buffering on;\n     # 设置nginx代理保存用户头信息的缓冲区大小\n     proxy_buffer_size  8k;\n     # proxy_buffers 缓冲区 \n     proxy_buffers 8 8k;\n     # 状态标记\n     proxy_next_upstream http_404  http_500  http_502  http_503  http_504  http_403  http_429;\n}\n```\n\n### try\\_files指令\n\n　格式1：**try\\_files** *`file`* ... *`uri`*;  格式2：**try\\_files** *`file`* ... =*`code`*;\n\n> **Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the \\*`file`\\*parameter according to the [root](http://nginx.org/en/docs/http/ngx_http_core_module.html#root) and [alias](http://nginx.org/en/docs/http/ngx_http_core_module.html#alias) directives. It is possible to check directory’s existence by specifying a slash at the end of a name, e.g. “`$uri/`”. If none of the files were found, an internal redirect to the *****`uri`*** specified in the last parameter is made. \n\n*   　　关键点1：按指定的file顺序查找存在的文件，并使用第一个找到的文件进行请求处理\n\n\n\n*   　　关键点2：查找路径是按照给定的root或alias为根路径来查找的\n\n\n\n*   　　关键点3：如果给出的file都没有匹配到，则重新请求最后一个参数给定的uri，就是新的location匹配\n\n\n\n*   　　关键点4：如果是格式2，如果最后一个参数是 = 404 ，若给出的file都没有匹配到，则最后返回404的响应码\n\n```bash\nlocation /images/ {\n    root /opt/html/;\n    try_files $uri   $uri/  /images/default.gif; \n}\n# 比如 请求 127.0.0.1/images/test.gif 会依次查找 1.文#件/opt/html/images/test.gif   2.文件夹 /opt/html/images/test.gif/下的index文件  3. 请求127.0.0.1/images/default.gif\n\n```\n\n[nginx配置选项try\\_files详解 - 陈一风 - 博客园 (cnblogs.com)](https://www.cnblogs.com/jedi1995/p/10900224.html)\n\n### Nginx内置绑定变量\n\n[使用 Nginx 内置绑定变量 · OpenResty最佳实践 (gitbooks.io)](https://moonbingbing.gitbooks.io/openresty-best-practices/content/openresty/inline_var.html)\n","slug":"Nginx 入门 server块 书写之 location 规则 （二）","published":1,"updated":"2024-01-28T14:48:20.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrxrizt50006b4tn4g3s5mlk","content":"<h1 id=\"Nginx-入门-server块-书写之-location-规则-（二）\"><a href=\"#Nginx-入门-server块-书写之-location-规则-（二）\" class=\"headerlink\" title=\"Nginx 入门 server块 书写之 location 规则 （二）\"></a>Nginx 入门 server块 书写之 location 规则 （二）</h1><p>接上文，我们学习了location 路由匹配规则和优先级，今天我们深入其内部来探寻实际处理的各个属性书写方式。</p>\n<h3 id=\"Return-指令\"><a href=\"#Return-指令\" class=\"headerlink\" title=\"Return 指令\"></a>Return 指令</h3><p><strong>return一般用于对请求的客户端直接返回响应状态码。在该作用域内return后面的所有nginx配置都是无效的。可以使用在server、location以及if配置中。除了支持跟状态码，还可以跟字符串或者url链接。</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">  1 server&#123;<br>  2     listen 80;<br>  3     server_name www.aaa.com;<br>  4     <span class=\"hljs-built_in\">return</span> 200 <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>  5 &#125;<br> <br> <br><span class=\"hljs-comment\">#说明：如果要想返回字符串，必须要加上状态码，否则会报错。</span><br> <br> <br>  1 location ^~ /aming &#123;<br>  2     default_type application/json ;<br>  3     <span class=\"hljs-built_in\">return</span> 200  <span class=\"hljs-string\">&#x27;&#123;&quot;name&quot;:&quot;xhy&quot;,&quot;id&quot;:&quot;100&quot;&#125;&#x27;</span>;<br>  4 &#125;\t\t\t\t\t<br><span class=\"hljs-comment\">#返回的字符串也支持json数据。</span><br> <br> <br>  1 location /test &#123;<br>  2     <span class=\"hljs-built_in\">return</span> 200 <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$host</span> <span class=\"hljs-variable\">$request_uri</span>&quot;</span>;<br>  3 &#125;\t\t\t\t\t<br><span class=\"hljs-comment\">#返回的字符串也支持变量</span><br> <br> <br>  1 server&#123;<br>  2     listen 80;<br>  3     server_name www.aaa.com;<br>  4     <span class=\"hljs-built_in\">return</span> http://www.baidu.com;<br>  5     rewrite /(.*) /abc/<span class=\"hljs-variable\">$1</span>;\t\t<span class=\"hljs-comment\">#该行配置位于return后，则不会被执行。</span><br>  6 &#125;<br> <br><span class=\"hljs-comment\"># 注意：return后面的url必须是以http://或者https://开头的。</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#常见的重定向</span><br>location = /tutorial/learning-nginx &#123;<br>     <span class=\"hljs-built_in\">return</span> 301 <span class=\"hljs-variable\">$scheme</span>://example.com/nginx/understanding-nginx<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Rewrite指令\"><a href=\"#Rewrite指令\" class=\"headerlink\" title=\"Rewrite指令\"></a>Rewrite指令</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">rewrite regex replacement-url [flag];<br><span class=\"hljs-section\">regex: 正则表达式</span><br><span class=\"hljs-section\">replacement-url: 替换的URL</span><br><span class=\"hljs-section\">flag: 用于进行一些额外的处理</span><br><br></code></pre></td></tr></table></figure>\n\n<p>不同flag的效果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">flag</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">last</td>\n<td align=\"left\">停止解析，并开始搜索与更改后的<code>URI</code>相匹配的<code>location</code>;</td>\n</tr>\n<tr>\n<td align=\"left\">break</td>\n<td align=\"left\">中止 rewrite，不再继续匹配</td>\n</tr>\n<tr>\n<td align=\"left\">redirect</td>\n<td align=\"left\">返回临时重定向的 HTTP 状态 302</td>\n</tr>\n<tr>\n<td align=\"left\">permanent</td>\n<td align=\"left\">返回永久重定向的 HTTP 状态 301</td>\n</tr>\n</tbody></table>\n<p>案例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location = /nginx-tutorial <br>&#123; <br>    rewrite ^/nginx-tutorial?$ /somePage.html last; <br>&#125;<br><br><br><span class=\"hljs-comment\">#把`https://example.com/nginx-tutorial`重写为#`https://example.com/somePage.html`</span><br><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location = /user.php <br>&#123; <br>    rewrite ^/user.php?<span class=\"hljs-built_in\">id</span>=([0-9]+)$ /user/<span class=\"hljs-variable\">$1</span> last; <br>&#125;<br><span class=\"hljs-comment\">##### 动态替换案例</span><br><br><span class=\"hljs-comment\">#把`https://www.example.com/user.php?id=11`重写为`https://exampleshop.com/user/11`</span><br><br><span class=\"hljs-comment\"># 其中`$1`表示`regex`中第一个括号中的值，第二个括号中的值可通过`$2`获取</span><br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location = /<br>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">$http_user_agent</span> ~* (mobile|nokia|iphone|ipad|android|samsung|htc|blackberry)) &#123;<br>    rewrite ^(.*) https://m.example.com<span class=\"hljs-variable\">$1</span> redirect;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">##### 手机访问重定向网址</span><br><br><span class=\"hljs-comment\"># 把`https://www.example.com`重写为`https://m.exampleshop.com`</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Proxy指令\"><a href=\"#Proxy指令\" class=\"headerlink\" title=\"Proxy指令\"></a>Proxy指令</h3><p>用于转发请求，常用于反向代理，注意以下细节</p>\n<ul>\n<li>  proxy_pass的链接无<code>/</code></li>\n<li>  proxy_pass的链接有<code>/</code></li>\n</ul>\n<h4 id=\"第一种：proxy-pass的链接无\"><a href=\"#第一种：proxy-pass的链接无\" class=\"headerlink\" title=\"第一种：proxy_pass的链接无/\"></a><strong>第一种：proxy_pass的链接无<code>/</code></strong></h4><p><strong>proxy_pass中，不带『/』，则把『匹配字符串及后缀（/api/xxx）』均带给转发地址</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 效果为：http://xxx.xxx.com/api/xxx -&gt; http://127.0.0.1:7000/api/xxx. 转发的时候,包含了url前缀.</span><br>location ^~ /api/ &#123; <br>    proxy_pass  http://127.0.0.1:7000; <br>&#125;<br><br><span class=\"hljs-comment\"># 效果与上面一致</span><br>location ^~ /api &#123;<br>    proxy_pass  http://127.0.0.1:7000; <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"第二种：proxy-pass的链接有\"><a href=\"#第二种：proxy-pass的链接有\" class=\"headerlink\" title=\"第二种：proxy_pass的链接有/\"></a>第二种：proxy_pass的链接有<code>/</code></h4><p>proxy_pass中，带『/』，则把『请求地址排除匹配字符串（/api/）』后，再带给转发地址</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 效果为：http://xxx.xxx.com/api/xxx --&gt; http://127.0.0.1:7000/xxx</span><br>location ^~ /api/ &#123;<br>    proxy_pass  http://127.0.0.1:7000/; <span class=\"hljs-comment\"># 端口后多了斜杠『/』</span><br>&#125;<br><br><span class=\"hljs-comment\"># 注意：下面的代码会导致失败，原因为『/api/xxx排除了/api』后，会把『/xxx』带给转发地址，但转发地址中已有了斜杠，结果会多了一条斜杠，报错。</span><br><span class=\"hljs-comment\"># 效果为：http://xxx.xxx.com/api/xxx --&gt; http://127.0.0.1:7000//xxx</span><br>location ^~ /api &#123;  <span class=\"hljs-comment\"># 这里的匹配字符串最后少了斜杠『/』</span><br>    proxy_pass  http://127.0.0.1:7000/;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>location的修饰符为正则匹配时，proxy_pass的地址最后不要带斜杠</strong></p>\n<p>一些简单的常用的 proxy_pass参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location / &#123;<br>      proxy_pass http://game;<br>      <span class=\"hljs-comment\"># 用户请求的时候HOST的值是game1.test.com, 那么代理服务会像后端传递请求的还是game1.test.com</span><br>      proxy_set_header Host <span class=\"hljs-variable\">$http_host</span>;<br>      <span class=\"hljs-comment\"># 将$remote_addr的值放进变量X-Real-IP中，$remote_addr的值为客户端的ip</span><br>      proxy_set_header X-Real-IP <span class=\"hljs-variable\">$remote_addr</span>;<br>      <span class=\"hljs-comment\"># 客户端通过代理服务访问后端服务, 后端服务通过该变量会记录真实客户端地址</span><br>      proxy_set_header X-Forwarded-For <span class=\"hljs-variable\">$proxy_add_x_forwarded_for</span>;<br>      <span class=\"hljs-comment\"># nginx代理与后端服务器连接超时时间(代理连接超时)</span><br>      proxy_connect_timeout 10s;<br>     <span class=\"hljs-comment\"># nginx代理等待后端服务器的响应时间 </span><br>     proxy_read_timeout 10s;<br>     <span class=\"hljs-comment\"># 后端服务器数据回传给nginx代理超时时间</span><br>     proxy_send_timeout 10s;<br>     <span class=\"hljs-comment\"># nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端，边收边传, 不是全部接收完再传给客户  </span><br>     proxy_buffering on;<br>     <span class=\"hljs-comment\"># 设置nginx代理保存用户头信息的缓冲区大小</span><br>     proxy_buffer_size  8k;<br>     <span class=\"hljs-comment\"># proxy_buffers 缓冲区 </span><br>     proxy_buffers 8 8k;<br>     <span class=\"hljs-comment\"># 状态标记</span><br>     proxy_next_upstream http_404  http_500  http_502  http_503  http_504  http_403  http_429;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"try-files指令\"><a href=\"#try-files指令\" class=\"headerlink\" title=\"try_files指令\"></a>try_files指令</h3><p>　格式1：<strong>try_files</strong> <em><code>file</code></em> … <em><code>uri</code></em>;  格式2：<strong>try_files</strong> <em><code>file</code></em> … =<em><code>code</code></em>;</p>\n<blockquote>\n<p>**Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the *<code>file</code>*parameter according to the <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#root\">root</a> and <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#alias\">alias</a> directives. It is possible to check directory’s existence by specifying a slash at the end of a name, e.g. “<code>$uri/</code>”. If none of the files were found, an internal redirect to the *****<code>uri</code>*** specified in the last parameter is made. </p>\n</blockquote>\n<ul>\n<li>  　　关键点1：按指定的file顺序查找存在的文件，并使用第一个找到的文件进行请求处理</li>\n</ul>\n<ul>\n<li>  　　关键点2：查找路径是按照给定的root或alias为根路径来查找的</li>\n</ul>\n<ul>\n<li>  　　关键点3：如果给出的file都没有匹配到，则重新请求最后一个参数给定的uri，就是新的location匹配</li>\n</ul>\n<ul>\n<li>  　　关键点4：如果是格式2，如果最后一个参数是 = 404 ，若给出的file都没有匹配到，则最后返回404的响应码</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location /images/ &#123;<br>    root /opt/html/;<br>    try_files <span class=\"hljs-variable\">$uri</span>   <span class=\"hljs-variable\">$uri</span>/  /images/default.gif; <br>&#125;<br><span class=\"hljs-comment\"># 比如 请求 127.0.0.1/images/test.gif 会依次查找 1.文#件/opt/html/images/test.gif   2.文件夹 /opt/html/images/test.gif/下的index文件  3. 请求127.0.0.1/images/default.gif</span><br><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.cnblogs.com/jedi1995/p/10900224.html\">nginx配置选项try_files详解 - 陈一风 - 博客园 (cnblogs.com)</a></p>\n<h3 id=\"Nginx内置绑定变量\"><a href=\"#Nginx内置绑定变量\" class=\"headerlink\" title=\"Nginx内置绑定变量\"></a>Nginx内置绑定变量</h3><p><a href=\"https://moonbingbing.gitbooks.io/openresty-best-practices/content/openresty/inline_var.html\">使用 Nginx 内置绑定变量 · OpenResty最佳实践 (gitbooks.io)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Nginx-入门-server块-书写之-location-规则-（二）\"><a href=\"#Nginx-入门-server块-书写之-location-规则-（二）\" class=\"headerlink\" title=\"Nginx 入门 server块 书写之 location 规则 （二）\"></a>Nginx 入门 server块 书写之 location 规则 （二）</h1><p>接上文，我们学习了location 路由匹配规则和优先级，今天我们深入其内部来探寻实际处理的各个属性书写方式。</p>\n<h3 id=\"Return-指令\"><a href=\"#Return-指令\" class=\"headerlink\" title=\"Return 指令\"></a>Return 指令</h3><p><strong>return一般用于对请求的客户端直接返回响应状态码。在该作用域内return后面的所有nginx配置都是无效的。可以使用在server、location以及if配置中。除了支持跟状态码，还可以跟字符串或者url链接。</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">  1 server&#123;<br>  2     listen 80;<br>  3     server_name www.aaa.com;<br>  4     <span class=\"hljs-built_in\">return</span> 200 <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>  5 &#125;<br> <br> <br><span class=\"hljs-comment\">#说明：如果要想返回字符串，必须要加上状态码，否则会报错。</span><br> <br> <br>  1 location ^~ /aming &#123;<br>  2     default_type application/json ;<br>  3     <span class=\"hljs-built_in\">return</span> 200  <span class=\"hljs-string\">&#x27;&#123;&quot;name&quot;:&quot;xhy&quot;,&quot;id&quot;:&quot;100&quot;&#125;&#x27;</span>;<br>  4 &#125;\t\t\t\t\t<br><span class=\"hljs-comment\">#返回的字符串也支持json数据。</span><br> <br> <br>  1 location /test &#123;<br>  2     <span class=\"hljs-built_in\">return</span> 200 <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$host</span> <span class=\"hljs-variable\">$request_uri</span>&quot;</span>;<br>  3 &#125;\t\t\t\t\t<br><span class=\"hljs-comment\">#返回的字符串也支持变量</span><br> <br> <br>  1 server&#123;<br>  2     listen 80;<br>  3     server_name www.aaa.com;<br>  4     <span class=\"hljs-built_in\">return</span> http://www.baidu.com;<br>  5     rewrite /(.*) /abc/<span class=\"hljs-variable\">$1</span>;\t\t<span class=\"hljs-comment\">#该行配置位于return后，则不会被执行。</span><br>  6 &#125;<br> <br><span class=\"hljs-comment\"># 注意：return后面的url必须是以http://或者https://开头的。</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#常见的重定向</span><br>location = /tutorial/learning-nginx &#123;<br>     <span class=\"hljs-built_in\">return</span> 301 <span class=\"hljs-variable\">$scheme</span>://example.com/nginx/understanding-nginx<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Rewrite指令\"><a href=\"#Rewrite指令\" class=\"headerlink\" title=\"Rewrite指令\"></a>Rewrite指令</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">rewrite regex replacement-url [flag];<br><span class=\"hljs-section\">regex: 正则表达式</span><br><span class=\"hljs-section\">replacement-url: 替换的URL</span><br><span class=\"hljs-section\">flag: 用于进行一些额外的处理</span><br><br></code></pre></td></tr></table></figure>\n\n<p>不同flag的效果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">flag</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">last</td>\n<td align=\"left\">停止解析，并开始搜索与更改后的<code>URI</code>相匹配的<code>location</code>;</td>\n</tr>\n<tr>\n<td align=\"left\">break</td>\n<td align=\"left\">中止 rewrite，不再继续匹配</td>\n</tr>\n<tr>\n<td align=\"left\">redirect</td>\n<td align=\"left\">返回临时重定向的 HTTP 状态 302</td>\n</tr>\n<tr>\n<td align=\"left\">permanent</td>\n<td align=\"left\">返回永久重定向的 HTTP 状态 301</td>\n</tr>\n</tbody></table>\n<p>案例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location = /nginx-tutorial <br>&#123; <br>    rewrite ^/nginx-tutorial?$ /somePage.html last; <br>&#125;<br><br><br><span class=\"hljs-comment\">#把`https://example.com/nginx-tutorial`重写为#`https://example.com/somePage.html`</span><br><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location = /user.php <br>&#123; <br>    rewrite ^/user.php?<span class=\"hljs-built_in\">id</span>=([0-9]+)$ /user/<span class=\"hljs-variable\">$1</span> last; <br>&#125;<br><span class=\"hljs-comment\">##### 动态替换案例</span><br><br><span class=\"hljs-comment\">#把`https://www.example.com/user.php?id=11`重写为`https://exampleshop.com/user/11`</span><br><br><span class=\"hljs-comment\"># 其中`$1`表示`regex`中第一个括号中的值，第二个括号中的值可通过`$2`获取</span><br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location = /<br>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">$http_user_agent</span> ~* (mobile|nokia|iphone|ipad|android|samsung|htc|blackberry)) &#123;<br>    rewrite ^(.*) https://m.example.com<span class=\"hljs-variable\">$1</span> redirect;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">##### 手机访问重定向网址</span><br><br><span class=\"hljs-comment\"># 把`https://www.example.com`重写为`https://m.exampleshop.com`</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Proxy指令\"><a href=\"#Proxy指令\" class=\"headerlink\" title=\"Proxy指令\"></a>Proxy指令</h3><p>用于转发请求，常用于反向代理，注意以下细节</p>\n<ul>\n<li>  proxy_pass的链接无<code>/</code></li>\n<li>  proxy_pass的链接有<code>/</code></li>\n</ul>\n<h4 id=\"第一种：proxy-pass的链接无\"><a href=\"#第一种：proxy-pass的链接无\" class=\"headerlink\" title=\"第一种：proxy_pass的链接无/\"></a><strong>第一种：proxy_pass的链接无<code>/</code></strong></h4><p><strong>proxy_pass中，不带『/』，则把『匹配字符串及后缀（/api/xxx）』均带给转发地址</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 效果为：http://xxx.xxx.com/api/xxx -&gt; http://127.0.0.1:7000/api/xxx. 转发的时候,包含了url前缀.</span><br>location ^~ /api/ &#123; <br>    proxy_pass  http://127.0.0.1:7000; <br>&#125;<br><br><span class=\"hljs-comment\"># 效果与上面一致</span><br>location ^~ /api &#123;<br>    proxy_pass  http://127.0.0.1:7000; <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"第二种：proxy-pass的链接有\"><a href=\"#第二种：proxy-pass的链接有\" class=\"headerlink\" title=\"第二种：proxy_pass的链接有/\"></a>第二种：proxy_pass的链接有<code>/</code></h4><p>proxy_pass中，带『/』，则把『请求地址排除匹配字符串（/api/）』后，再带给转发地址</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 效果为：http://xxx.xxx.com/api/xxx --&gt; http://127.0.0.1:7000/xxx</span><br>location ^~ /api/ &#123;<br>    proxy_pass  http://127.0.0.1:7000/; <span class=\"hljs-comment\"># 端口后多了斜杠『/』</span><br>&#125;<br><br><span class=\"hljs-comment\"># 注意：下面的代码会导致失败，原因为『/api/xxx排除了/api』后，会把『/xxx』带给转发地址，但转发地址中已有了斜杠，结果会多了一条斜杠，报错。</span><br><span class=\"hljs-comment\"># 效果为：http://xxx.xxx.com/api/xxx --&gt; http://127.0.0.1:7000//xxx</span><br>location ^~ /api &#123;  <span class=\"hljs-comment\"># 这里的匹配字符串最后少了斜杠『/』</span><br>    proxy_pass  http://127.0.0.1:7000/;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>location的修饰符为正则匹配时，proxy_pass的地址最后不要带斜杠</strong></p>\n<p>一些简单的常用的 proxy_pass参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location / &#123;<br>      proxy_pass http://game;<br>      <span class=\"hljs-comment\"># 用户请求的时候HOST的值是game1.test.com, 那么代理服务会像后端传递请求的还是game1.test.com</span><br>      proxy_set_header Host <span class=\"hljs-variable\">$http_host</span>;<br>      <span class=\"hljs-comment\"># 将$remote_addr的值放进变量X-Real-IP中，$remote_addr的值为客户端的ip</span><br>      proxy_set_header X-Real-IP <span class=\"hljs-variable\">$remote_addr</span>;<br>      <span class=\"hljs-comment\"># 客户端通过代理服务访问后端服务, 后端服务通过该变量会记录真实客户端地址</span><br>      proxy_set_header X-Forwarded-For <span class=\"hljs-variable\">$proxy_add_x_forwarded_for</span>;<br>      <span class=\"hljs-comment\"># nginx代理与后端服务器连接超时时间(代理连接超时)</span><br>      proxy_connect_timeout 10s;<br>     <span class=\"hljs-comment\"># nginx代理等待后端服务器的响应时间 </span><br>     proxy_read_timeout 10s;<br>     <span class=\"hljs-comment\"># 后端服务器数据回传给nginx代理超时时间</span><br>     proxy_send_timeout 10s;<br>     <span class=\"hljs-comment\"># nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端，边收边传, 不是全部接收完再传给客户  </span><br>     proxy_buffering on;<br>     <span class=\"hljs-comment\"># 设置nginx代理保存用户头信息的缓冲区大小</span><br>     proxy_buffer_size  8k;<br>     <span class=\"hljs-comment\"># proxy_buffers 缓冲区 </span><br>     proxy_buffers 8 8k;<br>     <span class=\"hljs-comment\"># 状态标记</span><br>     proxy_next_upstream http_404  http_500  http_502  http_503  http_504  http_403  http_429;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"try-files指令\"><a href=\"#try-files指令\" class=\"headerlink\" title=\"try_files指令\"></a>try_files指令</h3><p>　格式1：<strong>try_files</strong> <em><code>file</code></em> … <em><code>uri</code></em>;  格式2：<strong>try_files</strong> <em><code>file</code></em> … =<em><code>code</code></em>;</p>\n<blockquote>\n<p>**Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the *<code>file</code>*parameter according to the <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#root\">root</a> and <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#alias\">alias</a> directives. It is possible to check directory’s existence by specifying a slash at the end of a name, e.g. “<code>$uri/</code>”. If none of the files were found, an internal redirect to the *****<code>uri</code>*** specified in the last parameter is made. </p>\n</blockquote>\n<ul>\n<li>  　　关键点1：按指定的file顺序查找存在的文件，并使用第一个找到的文件进行请求处理</li>\n</ul>\n<ul>\n<li>  　　关键点2：查找路径是按照给定的root或alias为根路径来查找的</li>\n</ul>\n<ul>\n<li>  　　关键点3：如果给出的file都没有匹配到，则重新请求最后一个参数给定的uri，就是新的location匹配</li>\n</ul>\n<ul>\n<li>  　　关键点4：如果是格式2，如果最后一个参数是 = 404 ，若给出的file都没有匹配到，则最后返回404的响应码</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">location /images/ &#123;<br>    root /opt/html/;<br>    try_files <span class=\"hljs-variable\">$uri</span>   <span class=\"hljs-variable\">$uri</span>/  /images/default.gif; <br>&#125;<br><span class=\"hljs-comment\"># 比如 请求 127.0.0.1/images/test.gif 会依次查找 1.文#件/opt/html/images/test.gif   2.文件夹 /opt/html/images/test.gif/下的index文件  3. 请求127.0.0.1/images/default.gif</span><br><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.cnblogs.com/jedi1995/p/10900224.html\">nginx配置选项try_files详解 - 陈一风 - 博客园 (cnblogs.com)</a></p>\n<h3 id=\"Nginx内置绑定变量\"><a href=\"#Nginx内置绑定变量\" class=\"headerlink\" title=\"Nginx内置绑定变量\"></a>Nginx内置绑定变量</h3><p><a href=\"https://moonbingbing.gitbooks.io/openresty-best-practices/content/openresty/inline_var.html\">使用 Nginx 内置绑定变量 · OpenResty最佳实践 (gitbooks.io)</a></p>\n"},{"title":"伙伴匹配系统收获","date":"2023-02-05T15:37:00.000Z","_content":"\n\n#  伙伴匹配系统收获\n\n伙伴匹配系统前前后后花了40+小时，最后完成了这个基于Vue、Vant、Vite 以及SpringBoot的移动端 项目，有了用户中心的 基础架构，这个系统主要围绕功能如用户组队匹配以及性能优化进行开发，由于是轻量前端框架，开发上手较为容易。\n\n## 后端\n本次项目 的 Swagger + Knife4j 接口文档的 引入 极大的提高了之前前后端联调的效率，可以自动根据Controller上的handler 方法的参数 生成对应的 前端数据格式。这个在日常开发还是很常用的.\n\n在登录优化时引入了分布式Session, 以前的登录的Session 我们 是直接存在一台机器的服务上，但单个SpringBoot session 应用只能应用本服务。如果我们将项目拆分成微服务 或 集群部署，Session的状态就无法共享,引入spring-session-data-redis 就能够轻松的将Session 信息在redis维护，实现了分布式Session。\n\nRedis 基于内存的 nosql 数据库 的引入让我体验到其性能的强大，除了这种分布式Session的应用，它还能广泛的应用于数据缓存，在此系统的用户表我插入了大量的模拟用户，导致查询性能大大下降，后端响应到前端的时间大概要花10来秒。这样一来用户的体验感会大大下降。利用redis 的 基于内存的存储 成功的将 第二次访问的 速度降低到了毫秒级别。\n\n好像计算机的世界里 无论遇到什么问题加一层 缓存总能解决问题。然而引入 一个新的东西总会带来新的问题。从业务层面来说就是 我们需要维护 数据库和缓存的数据一致，但既然存在缓存我们就不可避免 两者的数据 会出现不一致，要做的就是将这种情况带来损失降低，比如设置合适的过期时间，既能带给用户良好的体验也不至于数据长时间不更新。其次就是就是只对变化不明显的数据使用缓存，这样用户感知体验会很少。从性能层面来说就是redis利用了内存，我们不能长时间占有，所以缓存的数据量一定要合适，而且一定要设置过期时间，一旦内存爆了，不然不但提升不了性能还会降低性能，同时redis 自我淘汰机制还会将重要数据淘汰掉。\n\n还有一个细节就是使用了缓存可是我们每次第一次访问还是比较慢，这里想要第一次也读的是缓存数据就需要缓存预热，缓存预热可以是定时任务也可以是触发某个事件。然后这里引出了基于Redisson的分布式锁(感觉这里有点为了用这个技术而用了🙄) 解决分布式环境下多个应用服务只想执行一次 缓存预热的定时任务。有点类似线程里的lock锁，设置然后抢锁然后执行预热然后释放锁.多线程和分布式其实就好像一个微观下一个宏观下的竞争对手，都是为了抢夺资源，只不过前者是为了抢夺计算机资源，后者是为了提供用户的服务的资源。这里Redisson的Rlock还实现了看门狗机制，就是如果一个服务抢到锁后 在执行分布式锁住的内容时 如果过了设置最大时间还没完就会自动续期一段时间。\n\n这个项目运用到的Redis 客户端有spring-boot-starter-data-redis、Redisson 后者比较高级支持线程安全同步。Rlock就是里面的。前者是SpringBoot推荐的。而且默认使用了jdk的序列化方法，就是最后到redis里都是一堆乱码其实是序列化号的，我们可以定制其的序列化方式增强可读性或者效率,只需要定制化配置redisTemplate的bean。\n\n然后值得一提的就是数据库表的建立以前都是一堆数据放在一张表，查起来确实爽但是极大的浪费了性能，大量的数据冗余。维护一张关系表虽然操作起来麻烦但还是能减少IO，记得使用事物注解就行了。这次开发又熟悉了下mybatis plus。它确实强大。记得自己写的sql语句没有自动添加逻辑删除的条件。\n\n\n最最最大收获就是这次的业务逻辑了，这次真的是经历了业务的完整流程，首先一定要想好需求分析再想好怎么实现，整个项目最多的地方就是在鉴权，因为队伍的创建者以及队伍的状态是有区别的。我们需要层层的判断是否有权限进行操作不然就会出现问题，有些鉴权可以直接判断，而有一些鉴权需要查数据库比如一个人最多加入5个队伍，我们要尽量让那些不要查数据库的鉴权在前面检查以减少数据库的访问。在开发过程尽量不要直接传递数据库的查询对象，多封装dto，vo来隔离原始数据，保证数据安全和数据格式统一。必要的时候对于相同的也逻辑要整体抽离。\n\n算法这一块用的是dp实现的最小编辑距离方法，感觉这个算法还是有局限性的，可以实现更好的匹配或者推荐算法，后续有机会我再试一试。\n\n\n## 前端\n前端这次用的3V三剑客，总体来说比较轻量，这次基本学会了其使用方法，这次🐟带我们实现了之前用户中心他们实现的一些功能，比如如和自己封装axios 全局拦截器，比如自己实现用户缓存，比如vue router跳转等等，了解到了Vue开发项目的结构，比如设置模板设置组件设置路由页面，其实这个项目就是一个单页面项目，Vue-router确实方便。总体上Vue3和React还是很像的，甚至更简单，v-if，v-for太好用了，ref响应式变量也很好好用，就是要注意Vue的生命周期，这些在后面再后面细细学习把\n\n## 写在最后\n这个项目还可以构建小程序等等，由于赶着总结项目找实习先不弄了，这次项目后端知识点很零碎但还是不算太难，然后就是lambda表达式操作集合类是真的很爽！！！！\n","source":"_posts/伙伴匹配系统收获.md","raw":"---\ntitle: 伙伴匹配系统收获\ntag: 总结\ndate: 2023-2-5 23:37:00\n---\n\n\n#  伙伴匹配系统收获\n\n伙伴匹配系统前前后后花了40+小时，最后完成了这个基于Vue、Vant、Vite 以及SpringBoot的移动端 项目，有了用户中心的 基础架构，这个系统主要围绕功能如用户组队匹配以及性能优化进行开发，由于是轻量前端框架，开发上手较为容易。\n\n## 后端\n本次项目 的 Swagger + Knife4j 接口文档的 引入 极大的提高了之前前后端联调的效率，可以自动根据Controller上的handler 方法的参数 生成对应的 前端数据格式。这个在日常开发还是很常用的.\n\n在登录优化时引入了分布式Session, 以前的登录的Session 我们 是直接存在一台机器的服务上，但单个SpringBoot session 应用只能应用本服务。如果我们将项目拆分成微服务 或 集群部署，Session的状态就无法共享,引入spring-session-data-redis 就能够轻松的将Session 信息在redis维护，实现了分布式Session。\n\nRedis 基于内存的 nosql 数据库 的引入让我体验到其性能的强大，除了这种分布式Session的应用，它还能广泛的应用于数据缓存，在此系统的用户表我插入了大量的模拟用户，导致查询性能大大下降，后端响应到前端的时间大概要花10来秒。这样一来用户的体验感会大大下降。利用redis 的 基于内存的存储 成功的将 第二次访问的 速度降低到了毫秒级别。\n\n好像计算机的世界里 无论遇到什么问题加一层 缓存总能解决问题。然而引入 一个新的东西总会带来新的问题。从业务层面来说就是 我们需要维护 数据库和缓存的数据一致，但既然存在缓存我们就不可避免 两者的数据 会出现不一致，要做的就是将这种情况带来损失降低，比如设置合适的过期时间，既能带给用户良好的体验也不至于数据长时间不更新。其次就是就是只对变化不明显的数据使用缓存，这样用户感知体验会很少。从性能层面来说就是redis利用了内存，我们不能长时间占有，所以缓存的数据量一定要合适，而且一定要设置过期时间，一旦内存爆了，不然不但提升不了性能还会降低性能，同时redis 自我淘汰机制还会将重要数据淘汰掉。\n\n还有一个细节就是使用了缓存可是我们每次第一次访问还是比较慢，这里想要第一次也读的是缓存数据就需要缓存预热，缓存预热可以是定时任务也可以是触发某个事件。然后这里引出了基于Redisson的分布式锁(感觉这里有点为了用这个技术而用了🙄) 解决分布式环境下多个应用服务只想执行一次 缓存预热的定时任务。有点类似线程里的lock锁，设置然后抢锁然后执行预热然后释放锁.多线程和分布式其实就好像一个微观下一个宏观下的竞争对手，都是为了抢夺资源，只不过前者是为了抢夺计算机资源，后者是为了提供用户的服务的资源。这里Redisson的Rlock还实现了看门狗机制，就是如果一个服务抢到锁后 在执行分布式锁住的内容时 如果过了设置最大时间还没完就会自动续期一段时间。\n\n这个项目运用到的Redis 客户端有spring-boot-starter-data-redis、Redisson 后者比较高级支持线程安全同步。Rlock就是里面的。前者是SpringBoot推荐的。而且默认使用了jdk的序列化方法，就是最后到redis里都是一堆乱码其实是序列化号的，我们可以定制其的序列化方式增强可读性或者效率,只需要定制化配置redisTemplate的bean。\n\n然后值得一提的就是数据库表的建立以前都是一堆数据放在一张表，查起来确实爽但是极大的浪费了性能，大量的数据冗余。维护一张关系表虽然操作起来麻烦但还是能减少IO，记得使用事物注解就行了。这次开发又熟悉了下mybatis plus。它确实强大。记得自己写的sql语句没有自动添加逻辑删除的条件。\n\n\n最最最大收获就是这次的业务逻辑了，这次真的是经历了业务的完整流程，首先一定要想好需求分析再想好怎么实现，整个项目最多的地方就是在鉴权，因为队伍的创建者以及队伍的状态是有区别的。我们需要层层的判断是否有权限进行操作不然就会出现问题，有些鉴权可以直接判断，而有一些鉴权需要查数据库比如一个人最多加入5个队伍，我们要尽量让那些不要查数据库的鉴权在前面检查以减少数据库的访问。在开发过程尽量不要直接传递数据库的查询对象，多封装dto，vo来隔离原始数据，保证数据安全和数据格式统一。必要的时候对于相同的也逻辑要整体抽离。\n\n算法这一块用的是dp实现的最小编辑距离方法，感觉这个算法还是有局限性的，可以实现更好的匹配或者推荐算法，后续有机会我再试一试。\n\n\n## 前端\n前端这次用的3V三剑客，总体来说比较轻量，这次基本学会了其使用方法，这次🐟带我们实现了之前用户中心他们实现的一些功能，比如如和自己封装axios 全局拦截器，比如自己实现用户缓存，比如vue router跳转等等，了解到了Vue开发项目的结构，比如设置模板设置组件设置路由页面，其实这个项目就是一个单页面项目，Vue-router确实方便。总体上Vue3和React还是很像的，甚至更简单，v-if，v-for太好用了，ref响应式变量也很好好用，就是要注意Vue的生命周期，这些在后面再后面细细学习把\n\n## 写在最后\n这个项目还可以构建小程序等等，由于赶着总结项目找实习先不弄了，这次项目后端知识点很零碎但还是不算太难，然后就是lambda表达式操作集合类是真的很爽！！！！\n","slug":"伙伴匹配系统收获","published":1,"updated":"2024-01-28T14:48:20.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrxrizt70009b4tn8kljh84b","content":"<h1 id=\"伙伴匹配系统收获\"><a href=\"#伙伴匹配系统收获\" class=\"headerlink\" title=\"伙伴匹配系统收获\"></a>伙伴匹配系统收获</h1><p>伙伴匹配系统前前后后花了40+小时，最后完成了这个基于Vue、Vant、Vite 以及SpringBoot的移动端 项目，有了用户中心的 基础架构，这个系统主要围绕功能如用户组队匹配以及性能优化进行开发，由于是轻量前端框架，开发上手较为容易。</p>\n<h2 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h2><p>本次项目 的 Swagger + Knife4j 接口文档的 引入 极大的提高了之前前后端联调的效率，可以自动根据Controller上的handler 方法的参数 生成对应的 前端数据格式。这个在日常开发还是很常用的.</p>\n<p>在登录优化时引入了分布式Session, 以前的登录的Session 我们 是直接存在一台机器的服务上，但单个SpringBoot session 应用只能应用本服务。如果我们将项目拆分成微服务 或 集群部署，Session的状态就无法共享,引入spring-session-data-redis 就能够轻松的将Session 信息在redis维护，实现了分布式Session。</p>\n<p>Redis 基于内存的 nosql 数据库 的引入让我体验到其性能的强大，除了这种分布式Session的应用，它还能广泛的应用于数据缓存，在此系统的用户表我插入了大量的模拟用户，导致查询性能大大下降，后端响应到前端的时间大概要花10来秒。这样一来用户的体验感会大大下降。利用redis 的 基于内存的存储 成功的将 第二次访问的 速度降低到了毫秒级别。</p>\n<p>好像计算机的世界里 无论遇到什么问题加一层 缓存总能解决问题。然而引入 一个新的东西总会带来新的问题。从业务层面来说就是 我们需要维护 数据库和缓存的数据一致，但既然存在缓存我们就不可避免 两者的数据 会出现不一致，要做的就是将这种情况带来损失降低，比如设置合适的过期时间，既能带给用户良好的体验也不至于数据长时间不更新。其次就是就是只对变化不明显的数据使用缓存，这样用户感知体验会很少。从性能层面来说就是redis利用了内存，我们不能长时间占有，所以缓存的数据量一定要合适，而且一定要设置过期时间，一旦内存爆了，不然不但提升不了性能还会降低性能，同时redis 自我淘汰机制还会将重要数据淘汰掉。</p>\n<p>还有一个细节就是使用了缓存可是我们每次第一次访问还是比较慢，这里想要第一次也读的是缓存数据就需要缓存预热，缓存预热可以是定时任务也可以是触发某个事件。然后这里引出了基于Redisson的分布式锁(感觉这里有点为了用这个技术而用了🙄) 解决分布式环境下多个应用服务只想执行一次 缓存预热的定时任务。有点类似线程里的lock锁，设置然后抢锁然后执行预热然后释放锁.多线程和分布式其实就好像一个微观下一个宏观下的竞争对手，都是为了抢夺资源，只不过前者是为了抢夺计算机资源，后者是为了提供用户的服务的资源。这里Redisson的Rlock还实现了看门狗机制，就是如果一个服务抢到锁后 在执行分布式锁住的内容时 如果过了设置最大时间还没完就会自动续期一段时间。</p>\n<p>这个项目运用到的Redis 客户端有spring-boot-starter-data-redis、Redisson 后者比较高级支持线程安全同步。Rlock就是里面的。前者是SpringBoot推荐的。而且默认使用了jdk的序列化方法，就是最后到redis里都是一堆乱码其实是序列化号的，我们可以定制其的序列化方式增强可读性或者效率,只需要定制化配置redisTemplate的bean。</p>\n<p>然后值得一提的就是数据库表的建立以前都是一堆数据放在一张表，查起来确实爽但是极大的浪费了性能，大量的数据冗余。维护一张关系表虽然操作起来麻烦但还是能减少IO，记得使用事物注解就行了。这次开发又熟悉了下mybatis plus。它确实强大。记得自己写的sql语句没有自动添加逻辑删除的条件。</p>\n<p>最最最大收获就是这次的业务逻辑了，这次真的是经历了业务的完整流程，首先一定要想好需求分析再想好怎么实现，整个项目最多的地方就是在鉴权，因为队伍的创建者以及队伍的状态是有区别的。我们需要层层的判断是否有权限进行操作不然就会出现问题，有些鉴权可以直接判断，而有一些鉴权需要查数据库比如一个人最多加入5个队伍，我们要尽量让那些不要查数据库的鉴权在前面检查以减少数据库的访问。在开发过程尽量不要直接传递数据库的查询对象，多封装dto，vo来隔离原始数据，保证数据安全和数据格式统一。必要的时候对于相同的也逻辑要整体抽离。</p>\n<p>算法这一块用的是dp实现的最小编辑距离方法，感觉这个算法还是有局限性的，可以实现更好的匹配或者推荐算法，后续有机会我再试一试。</p>\n<h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><p>前端这次用的3V三剑客，总体来说比较轻量，这次基本学会了其使用方法，这次🐟带我们实现了之前用户中心他们实现的一些功能，比如如和自己封装axios 全局拦截器，比如自己实现用户缓存，比如vue router跳转等等，了解到了Vue开发项目的结构，比如设置模板设置组件设置路由页面，其实这个项目就是一个单页面项目，Vue-router确实方便。总体上Vue3和React还是很像的，甚至更简单，v-if，v-for太好用了，ref响应式变量也很好好用，就是要注意Vue的生命周期，这些在后面再后面细细学习把</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>这个项目还可以构建小程序等等，由于赶着总结项目找实习先不弄了，这次项目后端知识点很零碎但还是不算太难，然后就是lambda表达式操作集合类是真的很爽！！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"伙伴匹配系统收获\"><a href=\"#伙伴匹配系统收获\" class=\"headerlink\" title=\"伙伴匹配系统收获\"></a>伙伴匹配系统收获</h1><p>伙伴匹配系统前前后后花了40+小时，最后完成了这个基于Vue、Vant、Vite 以及SpringBoot的移动端 项目，有了用户中心的 基础架构，这个系统主要围绕功能如用户组队匹配以及性能优化进行开发，由于是轻量前端框架，开发上手较为容易。</p>\n<h2 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h2><p>本次项目 的 Swagger + Knife4j 接口文档的 引入 极大的提高了之前前后端联调的效率，可以自动根据Controller上的handler 方法的参数 生成对应的 前端数据格式。这个在日常开发还是很常用的.</p>\n<p>在登录优化时引入了分布式Session, 以前的登录的Session 我们 是直接存在一台机器的服务上，但单个SpringBoot session 应用只能应用本服务。如果我们将项目拆分成微服务 或 集群部署，Session的状态就无法共享,引入spring-session-data-redis 就能够轻松的将Session 信息在redis维护，实现了分布式Session。</p>\n<p>Redis 基于内存的 nosql 数据库 的引入让我体验到其性能的强大，除了这种分布式Session的应用，它还能广泛的应用于数据缓存，在此系统的用户表我插入了大量的模拟用户，导致查询性能大大下降，后端响应到前端的时间大概要花10来秒。这样一来用户的体验感会大大下降。利用redis 的 基于内存的存储 成功的将 第二次访问的 速度降低到了毫秒级别。</p>\n<p>好像计算机的世界里 无论遇到什么问题加一层 缓存总能解决问题。然而引入 一个新的东西总会带来新的问题。从业务层面来说就是 我们需要维护 数据库和缓存的数据一致，但既然存在缓存我们就不可避免 两者的数据 会出现不一致，要做的就是将这种情况带来损失降低，比如设置合适的过期时间，既能带给用户良好的体验也不至于数据长时间不更新。其次就是就是只对变化不明显的数据使用缓存，这样用户感知体验会很少。从性能层面来说就是redis利用了内存，我们不能长时间占有，所以缓存的数据量一定要合适，而且一定要设置过期时间，一旦内存爆了，不然不但提升不了性能还会降低性能，同时redis 自我淘汰机制还会将重要数据淘汰掉。</p>\n<p>还有一个细节就是使用了缓存可是我们每次第一次访问还是比较慢，这里想要第一次也读的是缓存数据就需要缓存预热，缓存预热可以是定时任务也可以是触发某个事件。然后这里引出了基于Redisson的分布式锁(感觉这里有点为了用这个技术而用了🙄) 解决分布式环境下多个应用服务只想执行一次 缓存预热的定时任务。有点类似线程里的lock锁，设置然后抢锁然后执行预热然后释放锁.多线程和分布式其实就好像一个微观下一个宏观下的竞争对手，都是为了抢夺资源，只不过前者是为了抢夺计算机资源，后者是为了提供用户的服务的资源。这里Redisson的Rlock还实现了看门狗机制，就是如果一个服务抢到锁后 在执行分布式锁住的内容时 如果过了设置最大时间还没完就会自动续期一段时间。</p>\n<p>这个项目运用到的Redis 客户端有spring-boot-starter-data-redis、Redisson 后者比较高级支持线程安全同步。Rlock就是里面的。前者是SpringBoot推荐的。而且默认使用了jdk的序列化方法，就是最后到redis里都是一堆乱码其实是序列化号的，我们可以定制其的序列化方式增强可读性或者效率,只需要定制化配置redisTemplate的bean。</p>\n<p>然后值得一提的就是数据库表的建立以前都是一堆数据放在一张表，查起来确实爽但是极大的浪费了性能，大量的数据冗余。维护一张关系表虽然操作起来麻烦但还是能减少IO，记得使用事物注解就行了。这次开发又熟悉了下mybatis plus。它确实强大。记得自己写的sql语句没有自动添加逻辑删除的条件。</p>\n<p>最最最大收获就是这次的业务逻辑了，这次真的是经历了业务的完整流程，首先一定要想好需求分析再想好怎么实现，整个项目最多的地方就是在鉴权，因为队伍的创建者以及队伍的状态是有区别的。我们需要层层的判断是否有权限进行操作不然就会出现问题，有些鉴权可以直接判断，而有一些鉴权需要查数据库比如一个人最多加入5个队伍，我们要尽量让那些不要查数据库的鉴权在前面检查以减少数据库的访问。在开发过程尽量不要直接传递数据库的查询对象，多封装dto，vo来隔离原始数据，保证数据安全和数据格式统一。必要的时候对于相同的也逻辑要整体抽离。</p>\n<p>算法这一块用的是dp实现的最小编辑距离方法，感觉这个算法还是有局限性的，可以实现更好的匹配或者推荐算法，后续有机会我再试一试。</p>\n<h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><p>前端这次用的3V三剑客，总体来说比较轻量，这次基本学会了其使用方法，这次🐟带我们实现了之前用户中心他们实现的一些功能，比如如和自己封装axios 全局拦截器，比如自己实现用户缓存，比如vue router跳转等等，了解到了Vue开发项目的结构，比如设置模板设置组件设置路由页面，其实这个项目就是一个单页面项目，Vue-router确实方便。总体上Vue3和React还是很像的，甚至更简单，v-if，v-for太好用了，ref响应式变量也很好好用，就是要注意Vue的生命周期，这些在后面再后面细细学习把</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>这个项目还可以构建小程序等等，由于赶着总结项目找实习先不弄了，这次项目后端知识点很零碎但还是不算太难，然后就是lambda表达式操作集合类是真的很爽！！！！</p>\n"},{"title":"Hello Git","date":"2023-02-06T15:37:00.000Z","_content":"\nGit 入门笔记，带你快速使用 Git Bash 命令\n\n# Git 入门\n\ngit 分布式版本控制\n\n记录版本号 ，每个版本都有（高效的压缩解压算法）\n\n## 本地库\n\n本地结构\n\n    1. 本地库\n    1. 暂存区\n    1. 工作区\n\n#### git init\n\n初始化本地库\n\n#### git add **git commit**\n\n工作区 -》**git add** 【】暂存区 -》**git commit** 【】 本地库\n\n工作区 下（.git 同级）未 git add\n\n缓存区 已经 git add 未 git commit\n\n#### git status\n\n查看工作状态\n\n#### git log\n\n提交日志（由近到远）\n\n每一条内容 有一个 key 索引唯一对应\n\n不同展示样式：\n\n##### git log --pretty=oneline\n\n##### git log --oneline\n\n##### git reflog\n\n#### git reset --【】索引\n\n1.使用 hard（使用最多）\n\n​ 本地库的指针移动的同时 同步工作区、暂存区、本地库\n\n2.使用 mixed\n\n​ 本地库的指针移动的同时 同步暂存区、本地库\n\n2.使用 soft\n\n​ 只会让本地移动\n\n#### git diff\n\n比较工作区和暂存区的差异 （带文件比文件 ，不带比所有）\n\n### 分支\n\n新建分支会先将主分支的最新版本然后加到分支\n\n_各自分支相互独立_\n\n#### git branch\n\n##### git branch -v\n\n​ 查看当前所有分支\n\n##### git branch 【】\n\n创建分支\n\n##### git checkout 【】\n\n切换分支\n\n主分支合并 其他分支\n\n1. 切换到主分支\n2. 使用 git merge 【分支】（当主分支和其他分支 都修改了同一文件的同一位置就会冲突）\n3. 解决冲突方法：直接文件选择性删除 （再添加 提交）\n\n## 远程库\n\n**github**\n\n**gitee**\n\n**gitlab**\n\n#### git remote add 【name】【https://.....】\n\n本地库起远程库别名\n\n#### git remote -v\n\n查看别名\n\n**git push 【name】【分支】**\n\n向远程仓库（别名）推送 本地仓库 的指定分支\n\n**git clone 【https://.....】**\n\n初始化本地库 从远程库克隆到本地 起了别名 origin\n\n**库的拥有者拉取**\n\n1. fetch +merge 操作\n\n##### git fetch 【name】 【分支】\n\n从远程库抓取到本地库，工作区不变 这时候本地有个分支是 **name/分支**\n\n切换到本地 master 分支 调用 git merge name/分支 就可以合并\n\n2. pull 操作\n\n##### git pull【name】 【分支】\n\n冲突产生 需要到本地 解决再 push 到 远程仓库\n\n## 免密操作\n\n$ ssh-keygen -t rsa -C【email】\n\n### 常用操作\n\nidea 远程 pull 前提准备\n\ngit pull origin master --allow-unrelated-histories\n\n推送到上游其它分支\n\ngit push --set-upstream origin myblog（分支）\n","source":"_posts/hello-git.md","raw":"---\ntitle: Hello Git\ntag: 工具\ndate: 2023-2-6 23:37:00\n---\n\nGit 入门笔记，带你快速使用 Git Bash 命令\n\n# Git 入门\n\ngit 分布式版本控制\n\n记录版本号 ，每个版本都有（高效的压缩解压算法）\n\n## 本地库\n\n本地结构\n\n    1. 本地库\n    1. 暂存区\n    1. 工作区\n\n#### git init\n\n初始化本地库\n\n#### git add **git commit**\n\n工作区 -》**git add** 【】暂存区 -》**git commit** 【】 本地库\n\n工作区 下（.git 同级）未 git add\n\n缓存区 已经 git add 未 git commit\n\n#### git status\n\n查看工作状态\n\n#### git log\n\n提交日志（由近到远）\n\n每一条内容 有一个 key 索引唯一对应\n\n不同展示样式：\n\n##### git log --pretty=oneline\n\n##### git log --oneline\n\n##### git reflog\n\n#### git reset --【】索引\n\n1.使用 hard（使用最多）\n\n​ 本地库的指针移动的同时 同步工作区、暂存区、本地库\n\n2.使用 mixed\n\n​ 本地库的指针移动的同时 同步暂存区、本地库\n\n2.使用 soft\n\n​ 只会让本地移动\n\n#### git diff\n\n比较工作区和暂存区的差异 （带文件比文件 ，不带比所有）\n\n### 分支\n\n新建分支会先将主分支的最新版本然后加到分支\n\n_各自分支相互独立_\n\n#### git branch\n\n##### git branch -v\n\n​ 查看当前所有分支\n\n##### git branch 【】\n\n创建分支\n\n##### git checkout 【】\n\n切换分支\n\n主分支合并 其他分支\n\n1. 切换到主分支\n2. 使用 git merge 【分支】（当主分支和其他分支 都修改了同一文件的同一位置就会冲突）\n3. 解决冲突方法：直接文件选择性删除 （再添加 提交）\n\n## 远程库\n\n**github**\n\n**gitee**\n\n**gitlab**\n\n#### git remote add 【name】【https://.....】\n\n本地库起远程库别名\n\n#### git remote -v\n\n查看别名\n\n**git push 【name】【分支】**\n\n向远程仓库（别名）推送 本地仓库 的指定分支\n\n**git clone 【https://.....】**\n\n初始化本地库 从远程库克隆到本地 起了别名 origin\n\n**库的拥有者拉取**\n\n1. fetch +merge 操作\n\n##### git fetch 【name】 【分支】\n\n从远程库抓取到本地库，工作区不变 这时候本地有个分支是 **name/分支**\n\n切换到本地 master 分支 调用 git merge name/分支 就可以合并\n\n2. pull 操作\n\n##### git pull【name】 【分支】\n\n冲突产生 需要到本地 解决再 push 到 远程仓库\n\n## 免密操作\n\n$ ssh-keygen -t rsa -C【email】\n\n### 常用操作\n\nidea 远程 pull 前提准备\n\ngit pull origin master --allow-unrelated-histories\n\n推送到上游其它分支\n\ngit push --set-upstream origin myblog（分支）\n","slug":"hello-git","published":1,"updated":"2024-01-28T14:48:20.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrxrizt8000ab4tn9vxq5bq4","content":"<p>Git 入门笔记，带你快速使用 Git Bash 命令</p>\n<h1 id=\"Git-入门\"><a href=\"#Git-入门\" class=\"headerlink\" title=\"Git 入门\"></a>Git 入门</h1><p>git 分布式版本控制</p>\n<p>记录版本号 ，每个版本都有（高效的压缩解压算法）</p>\n<h2 id=\"本地库\"><a href=\"#本地库\" class=\"headerlink\" title=\"本地库\"></a>本地库</h2><p>本地结构</p>\n<pre><code class=\"hljs\">1. 本地库\n1. 暂存区\n1. 工作区\n</code></pre>\n<h4 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h4><p>初始化本地库</p>\n<h4 id=\"git-add-git-commit\"><a href=\"#git-add-git-commit\" class=\"headerlink\" title=\"git add git commit\"></a>git add <strong>git commit</strong></h4><p>工作区 -》<strong>git add</strong> 【】暂存区 -》<strong>git commit</strong> 【】 本地库</p>\n<p>工作区 下（.git 同级）未 git add</p>\n<p>缓存区 已经 git add 未 git commit</p>\n<h4 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h4><p>查看工作状态</p>\n<h4 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h4><p>提交日志（由近到远）</p>\n<p>每一条内容 有一个 key 索引唯一对应</p>\n<p>不同展示样式：</p>\n<h5 id=\"git-log-–pretty-oneline\"><a href=\"#git-log-–pretty-oneline\" class=\"headerlink\" title=\"git log –pretty=oneline\"></a>git log –pretty=oneline</h5><h5 id=\"git-log-–oneline\"><a href=\"#git-log-–oneline\" class=\"headerlink\" title=\"git log –oneline\"></a>git log –oneline</h5><h5 id=\"git-reflog\"><a href=\"#git-reflog\" class=\"headerlink\" title=\"git reflog\"></a>git reflog</h5><h4 id=\"git-reset-–【】索引\"><a href=\"#git-reset-–【】索引\" class=\"headerlink\" title=\"git reset –【】索引\"></a>git reset –【】索引</h4><p>1.使用 hard（使用最多）</p>\n<p>​ 本地库的指针移动的同时 同步工作区、暂存区、本地库</p>\n<p>2.使用 mixed</p>\n<p>​ 本地库的指针移动的同时 同步暂存区、本地库</p>\n<p>2.使用 soft</p>\n<p>​ 只会让本地移动</p>\n<h4 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h4><p>比较工作区和暂存区的差异 （带文件比文件 ，不带比所有）</p>\n<h3 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h3><p>新建分支会先将主分支的最新版本然后加到分支</p>\n<p><em>各自分支相互独立</em></p>\n<h4 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h4><h5 id=\"git-branch-v\"><a href=\"#git-branch-v\" class=\"headerlink\" title=\"git branch -v\"></a>git branch -v</h5><p>​ 查看当前所有分支</p>\n<h5 id=\"git-branch-【】\"><a href=\"#git-branch-【】\" class=\"headerlink\" title=\"git branch 【】\"></a>git branch 【】</h5><p>创建分支</p>\n<h5 id=\"git-checkout-【】\"><a href=\"#git-checkout-【】\" class=\"headerlink\" title=\"git checkout 【】\"></a>git checkout 【】</h5><p>切换分支</p>\n<p>主分支合并 其他分支</p>\n<ol>\n<li>切换到主分支</li>\n<li>使用 git merge 【分支】（当主分支和其他分支 都修改了同一文件的同一位置就会冲突）</li>\n<li>解决冲突方法：直接文件选择性删除 （再添加 提交）</li>\n</ol>\n<h2 id=\"远程库\"><a href=\"#远程库\" class=\"headerlink\" title=\"远程库\"></a>远程库</h2><p><strong>github</strong></p>\n<p><strong>gitee</strong></p>\n<p><strong>gitlab</strong></p>\n<h4 id=\"git-remote-add-【name】【https-…-】\"><a href=\"#git-remote-add-【name】【https-…-】\" class=\"headerlink\" title=\"git remote add 【name】【https://…..】\"></a>git remote add 【name】【https://…..】</h4><p>本地库起远程库别名</p>\n<h4 id=\"git-remote-v\"><a href=\"#git-remote-v\" class=\"headerlink\" title=\"git remote -v\"></a>git remote -v</h4><p>查看别名</p>\n<p><strong>git push 【name】【分支】</strong></p>\n<p>向远程仓库（别名）推送 本地仓库 的指定分支</p>\n<p><strong>git clone 【https://…..】</strong></p>\n<p>初始化本地库 从远程库克隆到本地 起了别名 origin</p>\n<p><strong>库的拥有者拉取</strong></p>\n<ol>\n<li>fetch +merge 操作</li>\n</ol>\n<h5 id=\"git-fetch-【name】-【分支】\"><a href=\"#git-fetch-【name】-【分支】\" class=\"headerlink\" title=\"git fetch 【name】 【分支】\"></a>git fetch 【name】 【分支】</h5><p>从远程库抓取到本地库，工作区不变 这时候本地有个分支是 <strong>name/分支</strong></p>\n<p>切换到本地 master 分支 调用 git merge name/分支 就可以合并</p>\n<ol start=\"2\">\n<li>pull 操作</li>\n</ol>\n<h5 id=\"git-pull【name】-【分支】\"><a href=\"#git-pull【name】-【分支】\" class=\"headerlink\" title=\"git pull【name】 【分支】\"></a>git pull【name】 【分支】</h5><p>冲突产生 需要到本地 解决再 push 到 远程仓库</p>\n<h2 id=\"免密操作\"><a href=\"#免密操作\" class=\"headerlink\" title=\"免密操作\"></a>免密操作</h2><p>$ ssh-keygen -t rsa -C【email】</p>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p>idea 远程 pull 前提准备</p>\n<p>git pull origin master –allow-unrelated-histories</p>\n<p>推送到上游其它分支</p>\n<p>git push –set-upstream origin myblog（分支）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Git 入门笔记，带你快速使用 Git Bash 命令</p>\n<h1 id=\"Git-入门\"><a href=\"#Git-入门\" class=\"headerlink\" title=\"Git 入门\"></a>Git 入门</h1><p>git 分布式版本控制</p>\n<p>记录版本号 ，每个版本都有（高效的压缩解压算法）</p>\n<h2 id=\"本地库\"><a href=\"#本地库\" class=\"headerlink\" title=\"本地库\"></a>本地库</h2><p>本地结构</p>\n<pre><code>1. 本地库\n1. 暂存区\n1. 工作区\n</code></pre>\n<h4 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h4><p>初始化本地库</p>\n<h4 id=\"git-add-git-commit\"><a href=\"#git-add-git-commit\" class=\"headerlink\" title=\"git add git commit\"></a>git add <strong>git commit</strong></h4><p>工作区 -》<strong>git add</strong> 【】暂存区 -》<strong>git commit</strong> 【】 本地库</p>\n<p>工作区 下（.git 同级）未 git add</p>\n<p>缓存区 已经 git add 未 git commit</p>\n<h4 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h4><p>查看工作状态</p>\n<h4 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h4><p>提交日志（由近到远）</p>\n<p>每一条内容 有一个 key 索引唯一对应</p>\n<p>不同展示样式：</p>\n<h5 id=\"git-log-–pretty-oneline\"><a href=\"#git-log-–pretty-oneline\" class=\"headerlink\" title=\"git log –pretty=oneline\"></a>git log –pretty=oneline</h5><h5 id=\"git-log-–oneline\"><a href=\"#git-log-–oneline\" class=\"headerlink\" title=\"git log –oneline\"></a>git log –oneline</h5><h5 id=\"git-reflog\"><a href=\"#git-reflog\" class=\"headerlink\" title=\"git reflog\"></a>git reflog</h5><h4 id=\"git-reset-–【】索引\"><a href=\"#git-reset-–【】索引\" class=\"headerlink\" title=\"git reset –【】索引\"></a>git reset –【】索引</h4><p>1.使用 hard（使用最多）</p>\n<p>​ 本地库的指针移动的同时 同步工作区、暂存区、本地库</p>\n<p>2.使用 mixed</p>\n<p>​ 本地库的指针移动的同时 同步暂存区、本地库</p>\n<p>2.使用 soft</p>\n<p>​ 只会让本地移动</p>\n<h4 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h4><p>比较工作区和暂存区的差异 （带文件比文件 ，不带比所有）</p>\n<h3 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h3><p>新建分支会先将主分支的最新版本然后加到分支</p>\n<p><em>各自分支相互独立</em></p>\n<h4 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h4><h5 id=\"git-branch-v\"><a href=\"#git-branch-v\" class=\"headerlink\" title=\"git branch -v\"></a>git branch -v</h5><p>​ 查看当前所有分支</p>\n<h5 id=\"git-branch-【】\"><a href=\"#git-branch-【】\" class=\"headerlink\" title=\"git branch 【】\"></a>git branch 【】</h5><p>创建分支</p>\n<h5 id=\"git-checkout-【】\"><a href=\"#git-checkout-【】\" class=\"headerlink\" title=\"git checkout 【】\"></a>git checkout 【】</h5><p>切换分支</p>\n<p>主分支合并 其他分支</p>\n<ol>\n<li>切换到主分支</li>\n<li>使用 git merge 【分支】（当主分支和其他分支 都修改了同一文件的同一位置就会冲突）</li>\n<li>解决冲突方法：直接文件选择性删除 （再添加 提交）</li>\n</ol>\n<h2 id=\"远程库\"><a href=\"#远程库\" class=\"headerlink\" title=\"远程库\"></a>远程库</h2><p><strong>github</strong></p>\n<p><strong>gitee</strong></p>\n<p><strong>gitlab</strong></p>\n<h4 id=\"git-remote-add-【name】【https-…-】\"><a href=\"#git-remote-add-【name】【https-…-】\" class=\"headerlink\" title=\"git remote add 【name】【https://…..】\"></a>git remote add 【name】【https://…..】</h4><p>本地库起远程库别名</p>\n<h4 id=\"git-remote-v\"><a href=\"#git-remote-v\" class=\"headerlink\" title=\"git remote -v\"></a>git remote -v</h4><p>查看别名</p>\n<p><strong>git push 【name】【分支】</strong></p>\n<p>向远程仓库（别名）推送 本地仓库 的指定分支</p>\n<p><strong>git clone 【https://…..】</strong></p>\n<p>初始化本地库 从远程库克隆到本地 起了别名 origin</p>\n<p><strong>库的拥有者拉取</strong></p>\n<ol>\n<li>fetch +merge 操作</li>\n</ol>\n<h5 id=\"git-fetch-【name】-【分支】\"><a href=\"#git-fetch-【name】-【分支】\" class=\"headerlink\" title=\"git fetch 【name】 【分支】\"></a>git fetch 【name】 【分支】</h5><p>从远程库抓取到本地库，工作区不变 这时候本地有个分支是 <strong>name/分支</strong></p>\n<p>切换到本地 master 分支 调用 git merge name/分支 就可以合并</p>\n<ol start=\"2\">\n<li>pull 操作</li>\n</ol>\n<h5 id=\"git-pull【name】-【分支】\"><a href=\"#git-pull【name】-【分支】\" class=\"headerlink\" title=\"git pull【name】 【分支】\"></a>git pull【name】 【分支】</h5><p>冲突产生 需要到本地 解决再 push 到 远程仓库</p>\n<h2 id=\"免密操作\"><a href=\"#免密操作\" class=\"headerlink\" title=\"免密操作\"></a>免密操作</h2><p>$ ssh-keygen -t rsa -C【email】</p>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p>idea 远程 pull 前提准备</p>\n<p>git pull origin master –allow-unrelated-histories</p>\n<p>推送到上游其它分支</p>\n<p>git push –set-upstream origin myblog（分支）</p>\n"},{"title":"记一次比赛开发心得","date":"2023-05-01T16:27:00.000Z","_content":"\n\n# 应用开发的理解及效率的提升？换语言如何开发？\n\n\n\n### 前言\n最近结束了一个比赛的项目开发，做的是人工智能与图像识别相关的。本来是不打算参加的也是受人委托，当时拿到需求确实觉得简单，但是落实起来还是以遇到了许多困难。加上很久没有写大项目了也有些生疏了...虽然最后也完成了任务，但总觉得不够完美，当然此次开发确实是让我跳出了我自己的舒适圈，本来是打算上我最拿手的java,由于某些原因我不得不使用Python来开发后端,开发的过程完全是从0摸索，真的想吐槽一下Python，报错后的错误真的很难定位到...为什么包之间不向下兼容啊。技术实现还是大同小异，本篇博客不会着重描述，只是单纯记录开发历程和一些新get到的方法。我觉得还是蛮有意义的写这样一篇技术性随笔....\n![图像识别](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000759.png)\n![视频识别](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000809.png)\n\n### 为什么选择Python\n起初项目孵化的时候，一些简单的crud我套用的是之前一个老SpringBoot的项目，后来由于项目使用了YoloV8，看了其相关文档，毕竟是Python环境下的项目，用Python直接提供了其调用Demo，如果使用java我查阅到的资料可能最后还是会回到在java中调用Python这种套娃情况。又或者写一个图像识别的Python服务然后采用Java在进程级别进行通信，可是这样的实施成本又太高了，权衡之下最终选择了直接上Python,因为之前老早就想试试Python的fastapi。\n刚上手的时候确实我非常惊讶于fastapi的项目配置和启动，在以往的JavaWeb开发中光是配一个Tomcat我都弄了好久，加上入门时我还要为一个一个的Servlet配配置文件以及重写方法，当时学的时候就觉得这些好麻烦，而fastapi给我的体验就是一种打开了新世界大门的写法，一行挂载一行注释一个函数一个路由就写好了，这也太便捷了，这简直让web开发的成本一下降低了好几个档次。\n如果你对fastapi感谢趣不妨去看看他的[官方文档](https://fastapi.tiangolo.com/zh/)，你就会惊叹其便捷之处了！\n\n### 简单带来的问题\n上手快的确带来了一时爽，在开发过程中健壮性、易维护性的问题却会逐渐的暴露出来，当然这里仅是一位初级Python web开发者的拙见。在运行时的报错虽然能够利用Pydanic来抑制错误信息的暴露，但在开发过程中错误的定位让我非常难受，有时候一个错误很细节但他的报错却深入到源码底层，不是特别熟悉的玩家还真是头大，其次就是一些包他实现的功能可能和你预期的不太一样，需要细细甄别，然后就是环境问题了，也许就是一个不同的版本的包造成的结果会是一堆爆红，如果你不是老手还真是很难发现其中的奥秘......总而言之我还是非常欣赏这种web开发框架的设计方式，规范问题需要的是程序员自己积累，开发一些小型后台api确实省时省力。\n\n### 协程函数\n这是自上次面试背八股在实际开发遇到的有关协程的问题。其实早在JavaScript 就有打过交道的await 和 async。协程不同于线程和进程，他是由程序员自己创建出来的帮我们提高代码IO阻塞代码效率的一种调度方式，当然这样说还是有点牵强的，但是有一点是必须的那就是协程一定是在线程之上的，一个线程的阻塞不会让协程也停止调度，异步IO将会挂起切换到其他协程，是一种分时复用的思想，听起来好像和多线程差不多，但是其实协程的切换是在用户态，他也不需要额外的内存空间，效率非常高。[什么是协程?](https://zhuanlan.zhihu.com/p/172471249)\n\n\n|  | 进程 | 线程(特指内核态线程) | 协程 \n| --- | --- | --- |---|\n| 切换者 | \t操作系统 | 操作系统 | 用户 |\n| 切换时机 | \t根据操作系统自己的切换策略，用户不感知 | \t根据操作系统自己的切换策略，用户不感知 | 用户觉定 |\n| 切换内容 | 页全局目录、内核栈、硬件上下文 |内核栈、硬件上下文  | 硬件上下文 |\n| 切换内容的保存 | 保存于内核栈中 | 保存于内核栈中 | （用户栈/堆）|\n| 切换过程 | 用户态-内核态-用户态 | 用户态-内核态-用户态 | 用户态 |\n\n[浅析Python中异步和同步函数](https://m.elecfans.com/article/1589126.html)\n\n### 工程化的项目\n软件开发的一个重要目标就是要容易维护，无论是前端还是后端严格的分层次带来的长期收益是巨大的，例如前端我以前经常会把一个页面的组件、逻辑、数据写到一个文件里，一旦逻辑复杂一点，整个项目就会显得非常臃肿.这次我几乎大改了新版的ant design pro,踩了好多坑也自己实现了许多之前他自带的很多全局方法。最重要的还是**组件化的思想**，组件可以独立的拆分你的UI视图，他们是可以复用的，独立的单元。和函数类似，React中组件接收的输入源称为props，并且返回react元素。react元素是对UI界面的描述。你可以告诉react你期望的UI界面，剩下的工作可以交给react来处理。我们拿乘坐计程车打比方，当你告诉司机你想要去的地方，司机就会按照你期望地点将你安全的送到目的地。而不用你自己亲自开车。\n在FastApi 我依旧沿用了MVC 的开发模式，当然这里V由react代替了，只不过Python好像大部分也是在写函数式的M和C.\n**函数式编程（Functional Programming）是一种编程方式，它将计算机运算视为数学函数的计算，并且避免了状态变量和可变数据。函数式编程强调函数的纯粹性，即一个函数的返回结果只由输入决定，不受外部环境影响。** 这里要区别于面向过程和面向过程的编程，他们强调的点不一样,在此就不详细讨论了，后续会有专门的文章来讲讲其中的差异.\n\n### 人工智能将取代程序员？\n说实话此次开发，chatgpt帮了我很多忙，我甚至让他帮我写了很多组件和工具函数，其中不乏一些核心的yolov8结合opencv的视频视频逻辑，其准确率异常的高，不得不说现在的人工智能的出现对一些行业是会出现一定的冲击。但是他依旧会存在一些问题如果你的需求不够具体，这就像产品经理像程序员提需求一样，不说个清楚，写出来又不满意哈哈◑﹏◐\n但是要是说人工智能会取代我们程序员还是有待商榷，因为在一个项目中，其业务逻辑还是很复杂的，很有可能不同模块是不同人开发的，你让他完整的写一个程序他考虑的东西还是太少了，你让他写一部分程序，他又不能严格按照我们的代码风格为我们服务，总之用它写一些不需要多模块联动交互的逻辑工具方法还是挺方便的，能够极大提高效率，完全依赖于它也许不是一个很好的办法。我们还是动动脑子的...\n\n![chatgpt帮我写代码](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502001816.png)\n\n","source":"_posts/记一次比赛开发心得.md","raw":"\n---\ntitle: 记一次比赛开发心得\ntag: 心得\ndate: 2023-5-2 00:27:00\n---\n\n\n# 应用开发的理解及效率的提升？换语言如何开发？\n\n\n\n### 前言\n最近结束了一个比赛的项目开发，做的是人工智能与图像识别相关的。本来是不打算参加的也是受人委托，当时拿到需求确实觉得简单，但是落实起来还是以遇到了许多困难。加上很久没有写大项目了也有些生疏了...虽然最后也完成了任务，但总觉得不够完美，当然此次开发确实是让我跳出了我自己的舒适圈，本来是打算上我最拿手的java,由于某些原因我不得不使用Python来开发后端,开发的过程完全是从0摸索，真的想吐槽一下Python，报错后的错误真的很难定位到...为什么包之间不向下兼容啊。技术实现还是大同小异，本篇博客不会着重描述，只是单纯记录开发历程和一些新get到的方法。我觉得还是蛮有意义的写这样一篇技术性随笔....\n![图像识别](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000759.png)\n![视频识别](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000809.png)\n\n### 为什么选择Python\n起初项目孵化的时候，一些简单的crud我套用的是之前一个老SpringBoot的项目，后来由于项目使用了YoloV8，看了其相关文档，毕竟是Python环境下的项目，用Python直接提供了其调用Demo，如果使用java我查阅到的资料可能最后还是会回到在java中调用Python这种套娃情况。又或者写一个图像识别的Python服务然后采用Java在进程级别进行通信，可是这样的实施成本又太高了，权衡之下最终选择了直接上Python,因为之前老早就想试试Python的fastapi。\n刚上手的时候确实我非常惊讶于fastapi的项目配置和启动，在以往的JavaWeb开发中光是配一个Tomcat我都弄了好久，加上入门时我还要为一个一个的Servlet配配置文件以及重写方法，当时学的时候就觉得这些好麻烦，而fastapi给我的体验就是一种打开了新世界大门的写法，一行挂载一行注释一个函数一个路由就写好了，这也太便捷了，这简直让web开发的成本一下降低了好几个档次。\n如果你对fastapi感谢趣不妨去看看他的[官方文档](https://fastapi.tiangolo.com/zh/)，你就会惊叹其便捷之处了！\n\n### 简单带来的问题\n上手快的确带来了一时爽，在开发过程中健壮性、易维护性的问题却会逐渐的暴露出来，当然这里仅是一位初级Python web开发者的拙见。在运行时的报错虽然能够利用Pydanic来抑制错误信息的暴露，但在开发过程中错误的定位让我非常难受，有时候一个错误很细节但他的报错却深入到源码底层，不是特别熟悉的玩家还真是头大，其次就是一些包他实现的功能可能和你预期的不太一样，需要细细甄别，然后就是环境问题了，也许就是一个不同的版本的包造成的结果会是一堆爆红，如果你不是老手还真是很难发现其中的奥秘......总而言之我还是非常欣赏这种web开发框架的设计方式，规范问题需要的是程序员自己积累，开发一些小型后台api确实省时省力。\n\n### 协程函数\n这是自上次面试背八股在实际开发遇到的有关协程的问题。其实早在JavaScript 就有打过交道的await 和 async。协程不同于线程和进程，他是由程序员自己创建出来的帮我们提高代码IO阻塞代码效率的一种调度方式，当然这样说还是有点牵强的，但是有一点是必须的那就是协程一定是在线程之上的，一个线程的阻塞不会让协程也停止调度，异步IO将会挂起切换到其他协程，是一种分时复用的思想，听起来好像和多线程差不多，但是其实协程的切换是在用户态，他也不需要额外的内存空间，效率非常高。[什么是协程?](https://zhuanlan.zhihu.com/p/172471249)\n\n\n|  | 进程 | 线程(特指内核态线程) | 协程 \n| --- | --- | --- |---|\n| 切换者 | \t操作系统 | 操作系统 | 用户 |\n| 切换时机 | \t根据操作系统自己的切换策略，用户不感知 | \t根据操作系统自己的切换策略，用户不感知 | 用户觉定 |\n| 切换内容 | 页全局目录、内核栈、硬件上下文 |内核栈、硬件上下文  | 硬件上下文 |\n| 切换内容的保存 | 保存于内核栈中 | 保存于内核栈中 | （用户栈/堆）|\n| 切换过程 | 用户态-内核态-用户态 | 用户态-内核态-用户态 | 用户态 |\n\n[浅析Python中异步和同步函数](https://m.elecfans.com/article/1589126.html)\n\n### 工程化的项目\n软件开发的一个重要目标就是要容易维护，无论是前端还是后端严格的分层次带来的长期收益是巨大的，例如前端我以前经常会把一个页面的组件、逻辑、数据写到一个文件里，一旦逻辑复杂一点，整个项目就会显得非常臃肿.这次我几乎大改了新版的ant design pro,踩了好多坑也自己实现了许多之前他自带的很多全局方法。最重要的还是**组件化的思想**，组件可以独立的拆分你的UI视图，他们是可以复用的，独立的单元。和函数类似，React中组件接收的输入源称为props，并且返回react元素。react元素是对UI界面的描述。你可以告诉react你期望的UI界面，剩下的工作可以交给react来处理。我们拿乘坐计程车打比方，当你告诉司机你想要去的地方，司机就会按照你期望地点将你安全的送到目的地。而不用你自己亲自开车。\n在FastApi 我依旧沿用了MVC 的开发模式，当然这里V由react代替了，只不过Python好像大部分也是在写函数式的M和C.\n**函数式编程（Functional Programming）是一种编程方式，它将计算机运算视为数学函数的计算，并且避免了状态变量和可变数据。函数式编程强调函数的纯粹性，即一个函数的返回结果只由输入决定，不受外部环境影响。** 这里要区别于面向过程和面向过程的编程，他们强调的点不一样,在此就不详细讨论了，后续会有专门的文章来讲讲其中的差异.\n\n### 人工智能将取代程序员？\n说实话此次开发，chatgpt帮了我很多忙，我甚至让他帮我写了很多组件和工具函数，其中不乏一些核心的yolov8结合opencv的视频视频逻辑，其准确率异常的高，不得不说现在的人工智能的出现对一些行业是会出现一定的冲击。但是他依旧会存在一些问题如果你的需求不够具体，这就像产品经理像程序员提需求一样，不说个清楚，写出来又不满意哈哈◑﹏◐\n但是要是说人工智能会取代我们程序员还是有待商榷，因为在一个项目中，其业务逻辑还是很复杂的，很有可能不同模块是不同人开发的，你让他完整的写一个程序他考虑的东西还是太少了，你让他写一部分程序，他又不能严格按照我们的代码风格为我们服务，总之用它写一些不需要多模块联动交互的逻辑工具方法还是挺方便的，能够极大提高效率，完全依赖于它也许不是一个很好的办法。我们还是动动脑子的...\n\n![chatgpt帮我写代码](https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502001816.png)\n\n","slug":"记一次比赛开发心得","published":1,"updated":"2024-01-28T14:48:20.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrxrizta000cb4tn7e30fl76","content":"<h1 id=\"应用开发的理解及效率的提升？换语言如何开发？\"><a href=\"#应用开发的理解及效率的提升？换语言如何开发？\" class=\"headerlink\" title=\"应用开发的理解及效率的提升？换语言如何开发？\"></a>应用开发的理解及效率的提升？换语言如何开发？</h1><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近结束了一个比赛的项目开发，做的是人工智能与图像识别相关的。本来是不打算参加的也是受人委托，当时拿到需求确实觉得简单，但是落实起来还是以遇到了许多困难。加上很久没有写大项目了也有些生疏了…虽然最后也完成了任务，但总觉得不够完美，当然此次开发确实是让我跳出了我自己的舒适圈，本来是打算上我最拿手的java,由于某些原因我不得不使用Python来开发后端,开发的过程完全是从0摸索，真的想吐槽一下Python，报错后的错误真的很难定位到…为什么包之间不向下兼容啊。技术实现还是大同小异，本篇博客不会着重描述，只是单纯记录开发历程和一些新get到的方法。我觉得还是蛮有意义的写这样一篇技术性随笔….<br><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000759.png\" alt=\"图像识别\"><br><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000809.png\" alt=\"视频识别\"></p>\n<h3 id=\"为什么选择Python\"><a href=\"#为什么选择Python\" class=\"headerlink\" title=\"为什么选择Python\"></a>为什么选择Python</h3><p>起初项目孵化的时候，一些简单的crud我套用的是之前一个老SpringBoot的项目，后来由于项目使用了YoloV8，看了其相关文档，毕竟是Python环境下的项目，用Python直接提供了其调用Demo，如果使用java我查阅到的资料可能最后还是会回到在java中调用Python这种套娃情况。又或者写一个图像识别的Python服务然后采用Java在进程级别进行通信，可是这样的实施成本又太高了，权衡之下最终选择了直接上Python,因为之前老早就想试试Python的fastapi。<br>刚上手的时候确实我非常惊讶于fastapi的项目配置和启动，在以往的JavaWeb开发中光是配一个Tomcat我都弄了好久，加上入门时我还要为一个一个的Servlet配配置文件以及重写方法，当时学的时候就觉得这些好麻烦，而fastapi给我的体验就是一种打开了新世界大门的写法，一行挂载一行注释一个函数一个路由就写好了，这也太便捷了，这简直让web开发的成本一下降低了好几个档次。<br>如果你对fastapi感谢趣不妨去看看他的<a href=\"https://fastapi.tiangolo.com/zh/\">官方文档</a>，你就会惊叹其便捷之处了！</p>\n<h3 id=\"简单带来的问题\"><a href=\"#简单带来的问题\" class=\"headerlink\" title=\"简单带来的问题\"></a>简单带来的问题</h3><p>上手快的确带来了一时爽，在开发过程中健壮性、易维护性的问题却会逐渐的暴露出来，当然这里仅是一位初级Python web开发者的拙见。在运行时的报错虽然能够利用Pydanic来抑制错误信息的暴露，但在开发过程中错误的定位让我非常难受，有时候一个错误很细节但他的报错却深入到源码底层，不是特别熟悉的玩家还真是头大，其次就是一些包他实现的功能可能和你预期的不太一样，需要细细甄别，然后就是环境问题了，也许就是一个不同的版本的包造成的结果会是一堆爆红，如果你不是老手还真是很难发现其中的奥秘……总而言之我还是非常欣赏这种web开发框架的设计方式，规范问题需要的是程序员自己积累，开发一些小型后台api确实省时省力。</p>\n<h3 id=\"协程函数\"><a href=\"#协程函数\" class=\"headerlink\" title=\"协程函数\"></a>协程函数</h3><p>这是自上次面试背八股在实际开发遇到的有关协程的问题。其实早在JavaScript 就有打过交道的await 和 async。协程不同于线程和进程，他是由程序员自己创建出来的帮我们提高代码IO阻塞代码效率的一种调度方式，当然这样说还是有点牵强的，但是有一点是必须的那就是协程一定是在线程之上的，一个线程的阻塞不会让协程也停止调度，异步IO将会挂起切换到其他协程，是一种分时复用的思想，听起来好像和多线程差不多，但是其实协程的切换是在用户态，他也不需要额外的内存空间，效率非常高。<a href=\"https://zhuanlan.zhihu.com/p/172471249\">什么是协程?</a></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>进程</th>\n<th>线程(特指内核态线程)</th>\n<th>协程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>切换者</td>\n<td>操作系统</td>\n<td>操作系统</td>\n<td>用户</td>\n</tr>\n<tr>\n<td>切换时机</td>\n<td>根据操作系统自己的切换策略，用户不感知</td>\n<td>根据操作系统自己的切换策略，用户不感知</td>\n<td>用户觉定</td>\n</tr>\n<tr>\n<td>切换内容</td>\n<td>页全局目录、内核栈、硬件上下文</td>\n<td>内核栈、硬件上下文</td>\n<td>硬件上下文</td>\n</tr>\n<tr>\n<td>切换内容的保存</td>\n<td>保存于内核栈中</td>\n<td>保存于内核栈中</td>\n<td>（用户栈/堆）</td>\n</tr>\n<tr>\n<td>切换过程</td>\n<td>用户态-内核态-用户态</td>\n<td>用户态-内核态-用户态</td>\n<td>用户态</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://m.elecfans.com/article/1589126.html\">浅析Python中异步和同步函数</a></p>\n<h3 id=\"工程化的项目\"><a href=\"#工程化的项目\" class=\"headerlink\" title=\"工程化的项目\"></a>工程化的项目</h3><p>软件开发的一个重要目标就是要容易维护，无论是前端还是后端严格的分层次带来的长期收益是巨大的，例如前端我以前经常会把一个页面的组件、逻辑、数据写到一个文件里，一旦逻辑复杂一点，整个项目就会显得非常臃肿.这次我几乎大改了新版的ant design pro,踩了好多坑也自己实现了许多之前他自带的很多全局方法。最重要的还是<strong>组件化的思想</strong>，组件可以独立的拆分你的UI视图，他们是可以复用的，独立的单元。和函数类似，React中组件接收的输入源称为props，并且返回react元素。react元素是对UI界面的描述。你可以告诉react你期望的UI界面，剩下的工作可以交给react来处理。我们拿乘坐计程车打比方，当你告诉司机你想要去的地方，司机就会按照你期望地点将你安全的送到目的地。而不用你自己亲自开车。<br>在FastApi 我依旧沿用了MVC 的开发模式，当然这里V由react代替了，只不过Python好像大部分也是在写函数式的M和C.<br><strong>函数式编程（Functional Programming）是一种编程方式，它将计算机运算视为数学函数的计算，并且避免了状态变量和可变数据。函数式编程强调函数的纯粹性，即一个函数的返回结果只由输入决定，不受外部环境影响。</strong> 这里要区别于面向过程和面向过程的编程，他们强调的点不一样,在此就不详细讨论了，后续会有专门的文章来讲讲其中的差异.</p>\n<h3 id=\"人工智能将取代程序员？\"><a href=\"#人工智能将取代程序员？\" class=\"headerlink\" title=\"人工智能将取代程序员？\"></a>人工智能将取代程序员？</h3><p>说实话此次开发，chatgpt帮了我很多忙，我甚至让他帮我写了很多组件和工具函数，其中不乏一些核心的yolov8结合opencv的视频视频逻辑，其准确率异常的高，不得不说现在的人工智能的出现对一些行业是会出现一定的冲击。但是他依旧会存在一些问题如果你的需求不够具体，这就像产品经理像程序员提需求一样，不说个清楚，写出来又不满意哈哈◑﹏◐<br>但是要是说人工智能会取代我们程序员还是有待商榷，因为在一个项目中，其业务逻辑还是很复杂的，很有可能不同模块是不同人开发的，你让他完整的写一个程序他考虑的东西还是太少了，你让他写一部分程序，他又不能严格按照我们的代码风格为我们服务，总之用它写一些不需要多模块联动交互的逻辑工具方法还是挺方便的，能够极大提高效率，完全依赖于它也许不是一个很好的办法。我们还是动动脑子的…</p>\n<p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502001816.png\" alt=\"chatgpt帮我写代码\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"应用开发的理解及效率的提升？换语言如何开发？\"><a href=\"#应用开发的理解及效率的提升？换语言如何开发？\" class=\"headerlink\" title=\"应用开发的理解及效率的提升？换语言如何开发？\"></a>应用开发的理解及效率的提升？换语言如何开发？</h1><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近结束了一个比赛的项目开发，做的是人工智能与图像识别相关的。本来是不打算参加的也是受人委托，当时拿到需求确实觉得简单，但是落实起来还是以遇到了许多困难。加上很久没有写大项目了也有些生疏了…虽然最后也完成了任务，但总觉得不够完美，当然此次开发确实是让我跳出了我自己的舒适圈，本来是打算上我最拿手的java,由于某些原因我不得不使用Python来开发后端,开发的过程完全是从0摸索，真的想吐槽一下Python，报错后的错误真的很难定位到…为什么包之间不向下兼容啊。技术实现还是大同小异，本篇博客不会着重描述，只是单纯记录开发历程和一些新get到的方法。我觉得还是蛮有意义的写这样一篇技术性随笔….<br><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000759.png\" alt=\"图像识别\"><br><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502000809.png\" alt=\"视频识别\"></p>\n<h3 id=\"为什么选择Python\"><a href=\"#为什么选择Python\" class=\"headerlink\" title=\"为什么选择Python\"></a>为什么选择Python</h3><p>起初项目孵化的时候，一些简单的crud我套用的是之前一个老SpringBoot的项目，后来由于项目使用了YoloV8，看了其相关文档，毕竟是Python环境下的项目，用Python直接提供了其调用Demo，如果使用java我查阅到的资料可能最后还是会回到在java中调用Python这种套娃情况。又或者写一个图像识别的Python服务然后采用Java在进程级别进行通信，可是这样的实施成本又太高了，权衡之下最终选择了直接上Python,因为之前老早就想试试Python的fastapi。<br>刚上手的时候确实我非常惊讶于fastapi的项目配置和启动，在以往的JavaWeb开发中光是配一个Tomcat我都弄了好久，加上入门时我还要为一个一个的Servlet配配置文件以及重写方法，当时学的时候就觉得这些好麻烦，而fastapi给我的体验就是一种打开了新世界大门的写法，一行挂载一行注释一个函数一个路由就写好了，这也太便捷了，这简直让web开发的成本一下降低了好几个档次。<br>如果你对fastapi感谢趣不妨去看看他的<a href=\"https://fastapi.tiangolo.com/zh/\">官方文档</a>，你就会惊叹其便捷之处了！</p>\n<h3 id=\"简单带来的问题\"><a href=\"#简单带来的问题\" class=\"headerlink\" title=\"简单带来的问题\"></a>简单带来的问题</h3><p>上手快的确带来了一时爽，在开发过程中健壮性、易维护性的问题却会逐渐的暴露出来，当然这里仅是一位初级Python web开发者的拙见。在运行时的报错虽然能够利用Pydanic来抑制错误信息的暴露，但在开发过程中错误的定位让我非常难受，有时候一个错误很细节但他的报错却深入到源码底层，不是特别熟悉的玩家还真是头大，其次就是一些包他实现的功能可能和你预期的不太一样，需要细细甄别，然后就是环境问题了，也许就是一个不同的版本的包造成的结果会是一堆爆红，如果你不是老手还真是很难发现其中的奥秘……总而言之我还是非常欣赏这种web开发框架的设计方式，规范问题需要的是程序员自己积累，开发一些小型后台api确实省时省力。</p>\n<h3 id=\"协程函数\"><a href=\"#协程函数\" class=\"headerlink\" title=\"协程函数\"></a>协程函数</h3><p>这是自上次面试背八股在实际开发遇到的有关协程的问题。其实早在JavaScript 就有打过交道的await 和 async。协程不同于线程和进程，他是由程序员自己创建出来的帮我们提高代码IO阻塞代码效率的一种调度方式，当然这样说还是有点牵强的，但是有一点是必须的那就是协程一定是在线程之上的，一个线程的阻塞不会让协程也停止调度，异步IO将会挂起切换到其他协程，是一种分时复用的思想，听起来好像和多线程差不多，但是其实协程的切换是在用户态，他也不需要额外的内存空间，效率非常高。<a href=\"https://zhuanlan.zhihu.com/p/172471249\">什么是协程?</a></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>进程</th>\n<th>线程(特指内核态线程)</th>\n<th>协程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>切换者</td>\n<td>操作系统</td>\n<td>操作系统</td>\n<td>用户</td>\n</tr>\n<tr>\n<td>切换时机</td>\n<td>根据操作系统自己的切换策略，用户不感知</td>\n<td>根据操作系统自己的切换策略，用户不感知</td>\n<td>用户觉定</td>\n</tr>\n<tr>\n<td>切换内容</td>\n<td>页全局目录、内核栈、硬件上下文</td>\n<td>内核栈、硬件上下文</td>\n<td>硬件上下文</td>\n</tr>\n<tr>\n<td>切换内容的保存</td>\n<td>保存于内核栈中</td>\n<td>保存于内核栈中</td>\n<td>（用户栈/堆）</td>\n</tr>\n<tr>\n<td>切换过程</td>\n<td>用户态-内核态-用户态</td>\n<td>用户态-内核态-用户态</td>\n<td>用户态</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://m.elecfans.com/article/1589126.html\">浅析Python中异步和同步函数</a></p>\n<h3 id=\"工程化的项目\"><a href=\"#工程化的项目\" class=\"headerlink\" title=\"工程化的项目\"></a>工程化的项目</h3><p>软件开发的一个重要目标就是要容易维护，无论是前端还是后端严格的分层次带来的长期收益是巨大的，例如前端我以前经常会把一个页面的组件、逻辑、数据写到一个文件里，一旦逻辑复杂一点，整个项目就会显得非常臃肿.这次我几乎大改了新版的ant design pro,踩了好多坑也自己实现了许多之前他自带的很多全局方法。最重要的还是<strong>组件化的思想</strong>，组件可以独立的拆分你的UI视图，他们是可以复用的，独立的单元。和函数类似，React中组件接收的输入源称为props，并且返回react元素。react元素是对UI界面的描述。你可以告诉react你期望的UI界面，剩下的工作可以交给react来处理。我们拿乘坐计程车打比方，当你告诉司机你想要去的地方，司机就会按照你期望地点将你安全的送到目的地。而不用你自己亲自开车。<br>在FastApi 我依旧沿用了MVC 的开发模式，当然这里V由react代替了，只不过Python好像大部分也是在写函数式的M和C.<br><strong>函数式编程（Functional Programming）是一种编程方式，它将计算机运算视为数学函数的计算，并且避免了状态变量和可变数据。函数式编程强调函数的纯粹性，即一个函数的返回结果只由输入决定，不受外部环境影响。</strong> 这里要区别于面向过程和面向过程的编程，他们强调的点不一样,在此就不详细讨论了，后续会有专门的文章来讲讲其中的差异.</p>\n<h3 id=\"人工智能将取代程序员？\"><a href=\"#人工智能将取代程序员？\" class=\"headerlink\" title=\"人工智能将取代程序员？\"></a>人工智能将取代程序员？</h3><p>说实话此次开发，chatgpt帮了我很多忙，我甚至让他帮我写了很多组件和工具函数，其中不乏一些核心的yolov8结合opencv的视频视频逻辑，其准确率异常的高，不得不说现在的人工智能的出现对一些行业是会出现一定的冲击。但是他依旧会存在一些问题如果你的需求不够具体，这就像产品经理像程序员提需求一样，不说个清楚，写出来又不满意哈哈◑﹏◐<br>但是要是说人工智能会取代我们程序员还是有待商榷，因为在一个项目中，其业务逻辑还是很复杂的，很有可能不同模块是不同人开发的，你让他完整的写一个程序他考虑的东西还是太少了，你让他写一部分程序，他又不能严格按照我们的代码风格为我们服务，总之用它写一些不需要多模块联动交互的逻辑工具方法还是挺方便的，能够极大提高效率，完全依赖于它也许不是一个很好的办法。我们还是动动脑子的…</p>\n<p><img src=\"https://yilin-1307688338.cos.ap-nanjing.myqcloud.com/blog/20230502001816.png\" alt=\"chatgpt帮我写代码\"></p>\n"},{"title":"鱼皮用户中心收获","date":"2023-02-05T15:37:00.000Z","_content":"# 鱼皮用户中心收获\n\n用户中心花了大概30+小时 看了🐟所有视频\n\n借鉴了部分同学的 笔记 ，虽然这种项目以前也做过，很多东西之前也体验过，但还是一步一步地 跟着来了一边完整的，收获确实很多。同时这个过程还额外自己补了很多细节基础。\n\n### 后端\n\n首先最大的收获应该 不是代码层面的 因为业务很简单就是普通的对用户表的crud，而应该是整个 后端Java 的开发流程和规范 ，比如一些工具类，请求类，错误类的封装，这里尤其有收获的是 business错误类的引入 和  GlobelExceptionHandel 引入来处理错误信息 来像前端提供规范以及安全接口数据。其次就是 一些逻辑上的细节，还有一些敏捷开发的插件。整个后端 构建的流程和过程是很有意义的。\n\n### 前端\n\n然后就是前端方面的一些，这里之前只有简单三件套的基础，虽然能听懂，但还是促使我去稍微入门学习了 一下Vue、React 还有TS ，框架上手很简单但不熟练，所以看ant design pro 和 umi我看了好几遍，勉强能简单应用，在前端视频中 我觉得比较重要的收获是 前端这些主流框架的 项目结构 ，无论是Vue react还是umi 其实都差不多，所以听一遍理解其它很快捷，然后就是ts的细节了，ts确实对java程序员很友好，学了ts的一些语法理解ant design pro 非常的便捷，然后在前端的细节其实有很多，比如api的封装以及组件库的复用、路由的利用、生产模式对proxy代理的利用、以及异步axios请求（umi里的REQUEST）请求拦截器、响应拦截器、基础配置等等。总而言之，前端总是很细。\n\n### 登录\n\n哦，有一点就是登录保持登陆状态这个以前没系统学，利用这个antdesign 的框架大概熟悉了 整个流程 和 如何实现前后端 ，之前笔记有提到。\n\n\n\n### 多环境\n\n多环境指的是在前端和后端要配置 多种环境的数据 （数据库、消息队列、redis、端口）在启动时可供选择\n\n\n\n### 部署上线\n\n然后就是部署上线\n\n这里 基础的几个方式我就不讲了，主要收获应该是Docker容器部署吧，因为很早就想学了但是一直没机会.Docker 其实就是 服务器里的清新小服务器（有自己的端口、目录啥） ，在里面下环境只需要几行代码 ，然后我们利用镜像来打包 代码和环境，这样形成一个又一个的小软件就能够 通过Docker 来运行，方便快捷且独立。\n\n\n\n### 跨域问题\n\n然后是跨域问题\n\n之前解决过跨域问题，但没有带cookie这次带了cookie 由于做nginx之前没看鱼皮视频 自己搞了半天 踩了好多坑，这里的收获就是前端携带 cookie 就必须要在后端设置 返回头要带上 几个重要的头，尤其是cookie要设置path和当前请求url保持一致 ，这样setcookie才会生效。这里Nginx反向代理需要配置正常\n\n然后还有不使用反向代理，直接后端也有几种解决方法。\n\n\n\n### 写在最后\n\n然后我也自己拓展了一些接口比如查询等等\n\n这个项目应该会成为后面项目用户的数据中心吧，可以更单多的拓展。\n\n最后也希望以后写自己项目时时刻要提醒自己这些规范，以后要多回来看看，感谢鱼皮。\n\n\n\n\n\n","source":"_posts/鱼皮用户中心收获.md","raw":"---\ntitle: 鱼皮用户中心收获\ntag: 心得\ndate: 2023-2-5 23:37:00\n---\n# 鱼皮用户中心收获\n\n用户中心花了大概30+小时 看了🐟所有视频\n\n借鉴了部分同学的 笔记 ，虽然这种项目以前也做过，很多东西之前也体验过，但还是一步一步地 跟着来了一边完整的，收获确实很多。同时这个过程还额外自己补了很多细节基础。\n\n### 后端\n\n首先最大的收获应该 不是代码层面的 因为业务很简单就是普通的对用户表的crud，而应该是整个 后端Java 的开发流程和规范 ，比如一些工具类，请求类，错误类的封装，这里尤其有收获的是 business错误类的引入 和  GlobelExceptionHandel 引入来处理错误信息 来像前端提供规范以及安全接口数据。其次就是 一些逻辑上的细节，还有一些敏捷开发的插件。整个后端 构建的流程和过程是很有意义的。\n\n### 前端\n\n然后就是前端方面的一些，这里之前只有简单三件套的基础，虽然能听懂，但还是促使我去稍微入门学习了 一下Vue、React 还有TS ，框架上手很简单但不熟练，所以看ant design pro 和 umi我看了好几遍，勉强能简单应用，在前端视频中 我觉得比较重要的收获是 前端这些主流框架的 项目结构 ，无论是Vue react还是umi 其实都差不多，所以听一遍理解其它很快捷，然后就是ts的细节了，ts确实对java程序员很友好，学了ts的一些语法理解ant design pro 非常的便捷，然后在前端的细节其实有很多，比如api的封装以及组件库的复用、路由的利用、生产模式对proxy代理的利用、以及异步axios请求（umi里的REQUEST）请求拦截器、响应拦截器、基础配置等等。总而言之，前端总是很细。\n\n### 登录\n\n哦，有一点就是登录保持登陆状态这个以前没系统学，利用这个antdesign 的框架大概熟悉了 整个流程 和 如何实现前后端 ，之前笔记有提到。\n\n\n\n### 多环境\n\n多环境指的是在前端和后端要配置 多种环境的数据 （数据库、消息队列、redis、端口）在启动时可供选择\n\n\n\n### 部署上线\n\n然后就是部署上线\n\n这里 基础的几个方式我就不讲了，主要收获应该是Docker容器部署吧，因为很早就想学了但是一直没机会.Docker 其实就是 服务器里的清新小服务器（有自己的端口、目录啥） ，在里面下环境只需要几行代码 ，然后我们利用镜像来打包 代码和环境，这样形成一个又一个的小软件就能够 通过Docker 来运行，方便快捷且独立。\n\n\n\n### 跨域问题\n\n然后是跨域问题\n\n之前解决过跨域问题，但没有带cookie这次带了cookie 由于做nginx之前没看鱼皮视频 自己搞了半天 踩了好多坑，这里的收获就是前端携带 cookie 就必须要在后端设置 返回头要带上 几个重要的头，尤其是cookie要设置path和当前请求url保持一致 ，这样setcookie才会生效。这里Nginx反向代理需要配置正常\n\n然后还有不使用反向代理，直接后端也有几种解决方法。\n\n\n\n### 写在最后\n\n然后我也自己拓展了一些接口比如查询等等\n\n这个项目应该会成为后面项目用户的数据中心吧，可以更单多的拓展。\n\n最后也希望以后写自己项目时时刻要提醒自己这些规范，以后要多回来看看，感谢鱼皮。\n\n\n\n\n\n","slug":"鱼皮用户中心收获","published":1,"updated":"2024-01-28T14:48:20.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrxriztc000eb4tn1why5us0","content":"<h1 id=\"鱼皮用户中心收获\"><a href=\"#鱼皮用户中心收获\" class=\"headerlink\" title=\"鱼皮用户中心收获\"></a>鱼皮用户中心收获</h1><p>用户中心花了大概30+小时 看了🐟所有视频</p>\n<p>借鉴了部分同学的 笔记 ，虽然这种项目以前也做过，很多东西之前也体验过，但还是一步一步地 跟着来了一边完整的，收获确实很多。同时这个过程还额外自己补了很多细节基础。</p>\n<h3 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h3><p>首先最大的收获应该 不是代码层面的 因为业务很简单就是普通的对用户表的crud，而应该是整个 后端Java 的开发流程和规范 ，比如一些工具类，请求类，错误类的封装，这里尤其有收获的是 business错误类的引入 和  GlobelExceptionHandel 引入来处理错误信息 来像前端提供规范以及安全接口数据。其次就是 一些逻辑上的细节，还有一些敏捷开发的插件。整个后端 构建的流程和过程是很有意义的。</p>\n<h3 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h3><p>然后就是前端方面的一些，这里之前只有简单三件套的基础，虽然能听懂，但还是促使我去稍微入门学习了 一下Vue、React 还有TS ，框架上手很简单但不熟练，所以看ant design pro 和 umi我看了好几遍，勉强能简单应用，在前端视频中 我觉得比较重要的收获是 前端这些主流框架的 项目结构 ，无论是Vue react还是umi 其实都差不多，所以听一遍理解其它很快捷，然后就是ts的细节了，ts确实对java程序员很友好，学了ts的一些语法理解ant design pro 非常的便捷，然后在前端的细节其实有很多，比如api的封装以及组件库的复用、路由的利用、生产模式对proxy代理的利用、以及异步axios请求（umi里的REQUEST）请求拦截器、响应拦截器、基础配置等等。总而言之，前端总是很细。</p>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><p>哦，有一点就是登录保持登陆状态这个以前没系统学，利用这个antdesign 的框架大概熟悉了 整个流程 和 如何实现前后端 ，之前笔记有提到。</p>\n<h3 id=\"多环境\"><a href=\"#多环境\" class=\"headerlink\" title=\"多环境\"></a>多环境</h3><p>多环境指的是在前端和后端要配置 多种环境的数据 （数据库、消息队列、redis、端口）在启动时可供选择</p>\n<h3 id=\"部署上线\"><a href=\"#部署上线\" class=\"headerlink\" title=\"部署上线\"></a>部署上线</h3><p>然后就是部署上线</p>\n<p>这里 基础的几个方式我就不讲了，主要收获应该是Docker容器部署吧，因为很早就想学了但是一直没机会.Docker 其实就是 服务器里的清新小服务器（有自己的端口、目录啥） ，在里面下环境只需要几行代码 ，然后我们利用镜像来打包 代码和环境，这样形成一个又一个的小软件就能够 通过Docker 来运行，方便快捷且独立。</p>\n<h3 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h3><p>然后是跨域问题</p>\n<p>之前解决过跨域问题，但没有带cookie这次带了cookie 由于做nginx之前没看鱼皮视频 自己搞了半天 踩了好多坑，这里的收获就是前端携带 cookie 就必须要在后端设置 返回头要带上 几个重要的头，尤其是cookie要设置path和当前请求url保持一致 ，这样setcookie才会生效。这里Nginx反向代理需要配置正常</p>\n<p>然后还有不使用反向代理，直接后端也有几种解决方法。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>然后我也自己拓展了一些接口比如查询等等</p>\n<p>这个项目应该会成为后面项目用户的数据中心吧，可以更单多的拓展。</p>\n<p>最后也希望以后写自己项目时时刻要提醒自己这些规范，以后要多回来看看，感谢鱼皮。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"鱼皮用户中心收获\"><a href=\"#鱼皮用户中心收获\" class=\"headerlink\" title=\"鱼皮用户中心收获\"></a>鱼皮用户中心收获</h1><p>用户中心花了大概30+小时 看了🐟所有视频</p>\n<p>借鉴了部分同学的 笔记 ，虽然这种项目以前也做过，很多东西之前也体验过，但还是一步一步地 跟着来了一边完整的，收获确实很多。同时这个过程还额外自己补了很多细节基础。</p>\n<h3 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h3><p>首先最大的收获应该 不是代码层面的 因为业务很简单就是普通的对用户表的crud，而应该是整个 后端Java 的开发流程和规范 ，比如一些工具类，请求类，错误类的封装，这里尤其有收获的是 business错误类的引入 和  GlobelExceptionHandel 引入来处理错误信息 来像前端提供规范以及安全接口数据。其次就是 一些逻辑上的细节，还有一些敏捷开发的插件。整个后端 构建的流程和过程是很有意义的。</p>\n<h3 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h3><p>然后就是前端方面的一些，这里之前只有简单三件套的基础，虽然能听懂，但还是促使我去稍微入门学习了 一下Vue、React 还有TS ，框架上手很简单但不熟练，所以看ant design pro 和 umi我看了好几遍，勉强能简单应用，在前端视频中 我觉得比较重要的收获是 前端这些主流框架的 项目结构 ，无论是Vue react还是umi 其实都差不多，所以听一遍理解其它很快捷，然后就是ts的细节了，ts确实对java程序员很友好，学了ts的一些语法理解ant design pro 非常的便捷，然后在前端的细节其实有很多，比如api的封装以及组件库的复用、路由的利用、生产模式对proxy代理的利用、以及异步axios请求（umi里的REQUEST）请求拦截器、响应拦截器、基础配置等等。总而言之，前端总是很细。</p>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><p>哦，有一点就是登录保持登陆状态这个以前没系统学，利用这个antdesign 的框架大概熟悉了 整个流程 和 如何实现前后端 ，之前笔记有提到。</p>\n<h3 id=\"多环境\"><a href=\"#多环境\" class=\"headerlink\" title=\"多环境\"></a>多环境</h3><p>多环境指的是在前端和后端要配置 多种环境的数据 （数据库、消息队列、redis、端口）在启动时可供选择</p>\n<h3 id=\"部署上线\"><a href=\"#部署上线\" class=\"headerlink\" title=\"部署上线\"></a>部署上线</h3><p>然后就是部署上线</p>\n<p>这里 基础的几个方式我就不讲了，主要收获应该是Docker容器部署吧，因为很早就想学了但是一直没机会.Docker 其实就是 服务器里的清新小服务器（有自己的端口、目录啥） ，在里面下环境只需要几行代码 ，然后我们利用镜像来打包 代码和环境，这样形成一个又一个的小软件就能够 通过Docker 来运行，方便快捷且独立。</p>\n<h3 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h3><p>然后是跨域问题</p>\n<p>之前解决过跨域问题，但没有带cookie这次带了cookie 由于做nginx之前没看鱼皮视频 自己搞了半天 踩了好多坑，这里的收获就是前端携带 cookie 就必须要在后端设置 返回头要带上 几个重要的头，尤其是cookie要设置path和当前请求url保持一致 ，这样setcookie才会生效。这里Nginx反向代理需要配置正常</p>\n<p>然后还有不使用反向代理，直接后端也有几种解决方法。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>然后我也自己拓展了一些接口比如查询等等</p>\n<p>这个项目应该会成为后面项目用户的数据中心吧，可以更单多的拓展。</p>\n<p>最后也希望以后写自己项目时时刻要提醒自己这些规范，以后要多回来看看，感谢鱼皮。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clrxrizsq0001b4tn6uhk2150","tag_id":"clrxrizsz0003b4tn7666b3us","_id":"clrxrizt60008b4tn0ahce549"},{"post_id":"clrxrizsx0002b4tnef478zd9","tag_id":"clrxrizt60007b4tn181hc9b7","_id":"clrxriztc000db4tn2hu80w3s"},{"post_id":"clrxrizt10004b4tn0q06bk9q","tag_id":"clrxrizt9000bb4tn0531030y","_id":"clrxrizte000gb4tnangze8g7"},{"post_id":"clrxrizt30005b4tnhiil3r2o","tag_id":"clrxrizte000fb4tnaps47dky","_id":"clrxriztg000ib4tndqpvfrxt"},{"post_id":"clrxrizt50006b4tn4g3s5mlk","tag_id":"clrxrizt9000bb4tn0531030y","_id":"clrxrizth000kb4tn08ddcnrt"},{"post_id":"clrxrizt70009b4tn8kljh84b","tag_id":"clrxrizth000jb4tn6zq5dmmk","_id":"clrxrizti000mb4tngcla2yv9"},{"post_id":"clrxrizt8000ab4tn9vxq5bq4","tag_id":"clrxrizti000lb4tndxjqdjgc","_id":"clrxriztj000ob4tn04x2aigv"},{"post_id":"clrxrizta000cb4tn7e30fl76","tag_id":"clrxrizti000nb4tnbpwrglwf","_id":"clrxriztk000qb4tnaqgr8fij"},{"post_id":"clrxriztc000eb4tn1why5us0","tag_id":"clrxrizti000nb4tnbpwrglwf","_id":"clrxriztk000rb4tnct030zm7"}],"Tag":[{"name":"Docker","_id":"clrxrizsz0003b4tn7666b3us"},{"name":"NIO","_id":"clrxrizt60007b4tn181hc9b7"},{"name":"Nginx","_id":"clrxrizt9000bb4tn0531030y"},{"name":"项目","_id":"clrxrizte000fb4tnaps47dky"},{"name":"总结","_id":"clrxrizth000jb4tn6zq5dmmk"},{"name":"工具","_id":"clrxrizti000lb4tndxjqdjgc"},{"name":"心得","_id":"clrxrizti000nb4tnbpwrglwf"}]}}